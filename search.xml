<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++面向对象</title>
      <link href="/2023/08/30/c-mian-xiang-dui-xiang/"/>
      <url>/2023/08/30/c-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><p>public 共有成员<br>谁都可以访问(使用/调用)<br>protected保护成员<br>只有自己和子类可以访问<br>private 私有成员<br>只有自己（类内部）可以访问<br>成员访问<br>访问限定符仅作用于类，因此同一个类的不同对象，可以相互访问非共有部分。<br>类和结构体区别<br>在C++中，类和结构没有本质区别，唯一不同在于<br>类的默认访问控制属性为private<br>结构的默认访问控制属性为public<br>封装<br>对不同成员的控制访问属性加以区分，体现了C++作为面向对象语言的封装特性</p><h3 id="在栈中创建对象"><a href="#在栈中创建对象" class="headerlink" title="在栈中创建对象"></a>在栈中创建对象</h3><p>在栈中创建一个对象<br>格式: 类名 对象名<br>People people;<br>在栈中创建多个对象<br>类名 对象数组名[元素个数]</p><h3 id="在堆中创建对象"><a href="#在堆中创建对象" class="headerlink" title="在堆中创建对象"></a>在堆中创建对象</h3><p>在堆中创建单个对象</p><p>类名 *指针名 = new 类名<br>People *sirius = new People;<br>在堆中创建多个对象<br>类名 *对象数组指针名 = new 类名[元素个数]<br><img src="/./img/1686015643781.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class dog{public:    void eat()    {        cout &lt;&lt; "吃饭";    }    void run()    {        cout &lt;&lt; "跑步";    }    void sleep()    {        cout &lt;&lt; "睡觉";    }private:    string name, kind, color;    int age;};int main(){    // 堆区创建对象    cout &lt;&lt; "我是堆区的对象" &lt;&lt; endl;    dog *dui = new dog();    dui-&gt;eat();    dui-&gt;run();    dui-&gt;sleep();    cout &lt;&lt; endl;    // 栈区创建对象    dog zhan;    cout &lt;&lt; "我是栈区的对象" &lt;&lt; endl;    zhan.eat();    zhan.run();    zhan.sleep();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是堆区的对象<br>吃饭跑步睡觉<br>我是栈区的对象<br>吃饭跑步睡觉</p><p><img src="/./img/1686015729660.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{  private:    int sno,        grade;};int main(){    // 指针数组的方式创建对象    student *p[4];    for (int i = 0; i &lt; 4; i++)    {        p[i] = new student; // 让数组中的每一个指针指向一个对象    }    cout &lt;&lt; sizeof(p) &lt;&lt; endl;    // 一次性创建4个对象    student *q = new student[4];    cout &lt;&lt; sizeof(q);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>32<br>8</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p>构造函数为什么要放在public<br>在外部实例化对象时自动调用构造函数，如果是其他访问方式，没办法调用构造函数，也就不能实例化对象</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><h3 id="参数初始化表"><a href="#参数初始化表" class="headerlink" title="参数初始化表"></a>参数初始化表</h3><p>注意，参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。<br>如果用户没有定义，编译器会自动生成一个默认的析构函数。这个析构函数的函数体是空的，也没有形参，也不执行任何操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{public:    student(int a, int b) : sno(a), grade(b)    {        cout &lt;&lt; "我是构造有参数" &lt;&lt; endl;    };    student()    {        cout &lt;&lt; "我是构造无参数" &lt;&lt; endl;    };    ~student() // 不能被重载    {        cout &lt;&lt; "我是析构" &lt;&lt; endl;    }private:    int sno,        grade;};int main(){    student *p = new student(3, 4);    student *q = new student[4];    delete p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造有参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是析构</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p><h3 id="类中const成员"><a href="#类中const成员" class="headerlink" title="类中const成员"></a>类中const成员</h3><ol><li>const成员变量<br>必须使用初始化参数列表，初始化后不能修改</li><li>const成员函数<br>const成员函数不能修改基本成员变量。不能调用非const成员函数</li><li>const对象<br>对象中的数据成员不允许被改变。<br>常对象只能调用常成员函数</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    const int a;//常数据成员    int b;    void fun() const//常成员函数    {        cout &lt;&lt; "我是常成员函数";    }     Test(int c) : a(c) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;a &lt;&lt; this-&gt;b &lt;&lt; endl; }};int main(){    const Test p1(2);//常对象    p1.fun();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造函数20<br>我是常成员函数</p><h3 id="拷贝构造函数（复制构造函数）"><a href="#拷贝构造函数（复制构造函数）" class="headerlink" title="拷贝构造函数（复制构造函数）"></a>拷贝构造函数（复制构造函数）</h3><p><img src="/./img/1686376068957.png"></p><p>同构造函数一样，如果用户不提供拷贝构造函数，编译器提供默认拷贝构造函数。<br><strong>注意：因为拷贝构造函数属于构造函数，有的编译器会在用户提供构造函数的时候也不再提供拷贝构造。</strong></p><h4 id="浅拷贝（复制地址）"><a href="#浅拷贝（复制地址）" class="headerlink" title="浅拷贝（复制地址）"></a>浅拷贝（复制地址）</h4><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，<strong>当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。</strong></p><p><img src="/./img/1686397072070.png"></p><h4 id="深拷贝（复制内存）"><a href="#深拷贝（复制内存）" class="headerlink" title="深拷贝（复制内存）"></a>深拷贝（复制内存）</h4><p>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的。<strong>拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</strong></p><p><img src="/./img/1686397184821.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    int a;    char *name;    Test(int c, char *name) : a(c), name(name) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;name &lt;&lt; endl; }    Test(const Test &amp;TestA) { cout &lt;&lt; "我是拷贝构造函数" &lt;&lt; TestA.name &lt;&lt; endl; }    ~Test() { cout &lt;&lt; "我是析构" &lt;&lt; endl; }};int main(){    Test *p1 = new Test(2, "张三");    Test *p2 = new Test(*p1); // 拷贝构造函数Test(const Test &amp;);    delete p1;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>我是构造函数张三<br>我是拷贝构造函数张三<br>我是析构</p><h3 id="类static成员"><a href="#类static成员" class="headerlink" title="类static成员"></a>类static成员</h3><ul><li>静态成员在类的所有对象中是公有的</li><li>内存是程序运行时分配</li><li>使用前必须初始化且只能初始化一次</li><li>初始化不能在类定义中，通过作用域限定符初始化</li><li>优点<br>static成员的名字是在类的作用域中，因此可以<strong>避免与其它类成员或全局对象名字冲突。</strong><br>可以实施封装，<strong>static成员可以是私有的，而全局对象不可以。</strong><br>阅读程序容易看出static成员与某个类相关联，这种<strong>可见性可以清晰地反映程序员的意图</strong></li></ul><p>类型 类名 :: 变量名=值；</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><ul><li>不再属于对象，不需要通过对象访问</li><li><strong>static成员函数没有this指针</strong>，所以静态成员函数不可以访问非静态成员。只能访问静态成员（静态成员和静态变量）</li><li>非静态成员函数可以访问静态成员</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span>class Test<span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Test<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> Test<span class="token operator">::</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单例模式-待"><a href="#单例模式-待" class="headerlink" title="单例模式(待)"></a>单例模式(待)</h3><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，<strong>但是友元函数并不是成员函数。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    friend void fun(const Test &amp;a);    Test(int a) : b(a) {}private:    int b;};void fun(const Test &amp;a){    cout &lt;&lt; a.b &lt;&lt; "我是友元函数" &lt;&lt; endl;}int main(){    Test a(2);    fun(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2我是友元函数</p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p><p><strong>只有友元可以访问，其他依然不能访问</strong>。若类B是类A的友元。则只有类B的成员函数可以访问类A中的隐藏信息</p><p><strong>友元是单向的，不具有交换性</strong>。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p><p><strong>友元关系不具有传递性</strong>。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
      
      
      <categories>
          
          <category> – C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言进阶篇</title>
      <link href="/2023/08/30/c-yu-yan-jin-jie-pian/"/>
      <url>/2023/08/30/c-yu-yan-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言进阶篇"><a href="#C语言进阶篇" class="headerlink" title="C语言进阶篇"></a>C语言进阶篇</h1><p>本文是对</p><p>文章进行的学习总结</p><h2 id="结构体的介绍"><a href="#结构体的介绍" class="headerlink" title="结构体的介绍"></a>结构体的介绍</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><h4 id="第一种直接struct-加结构体名定义"><a href="#第一种直接struct-加结构体名定义" class="headerlink" title="第一种直接struct 加结构体名定义"></a>第一种直接struct 加结构体名定义</h4><p>struct  结构体名</p><p>{ </p><p>类型 属性名；</p><p>类型 属性名；</p><p>….</p><p>类型 属性名；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token comment">//student为结构体名</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//结构的属性</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">;</span><span class="token comment">//a为结构体变量一种定义变量的方式1</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//struct student a;//这也是一种定义变量的方式2</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为10a。</p><h4 id="第二种利用typedef-struct-结构体名定义结构体"><a href="#第二种利用typedef-struct-结构体名定义结构体" class="headerlink" title="第二种利用typedef struct 结构体名定义结构体"></a>第二种利用typedef struct 结构体名定义结构体</h4><p>typedef struct 结构体名{</p><p>类型 属性名；</p><p>类型 属性名；</p><p>…</p><p>类型 属性名；</p><p>}m;<em>//struct student 是数据类型，typedef 数据类型 p，p就是（struct student）只是重新修改了而已</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> m<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    m a<span class="token punctuation">;</span><span class="token comment">//定义结构体变量名a</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a。</p><h4 id="第三种嵌套定义结构体"><a href="#第三种嵌套定义结构体" class="headerlink" title="第三种嵌套定义结构体"></a>第三种嵌套定义结构体</h4><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>属性名：属性值；</p><p>}</p><p>属性名：属性值；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">teacher</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> b<span class="token punctuation">;</span>     <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a</p><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>定义格式和一般定义结构差不多，只是变量名为数组。每一个数组都有结构体的属性。但属性值要分别定义。以下用循环定义每一个结构体数组的属性值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结构为</p><p>10a</p><p>10a。</p><h4 id="计算结构体所占用的内存"><a href="#计算结构体所占用的内存" class="headerlink" title="计算结构体所占用的内存"></a>计算结构体所占用的内存</h4><p>结构体的内存存储讲究对齐法则。<strong>所有属性所占的内存向占最大内存的那个属性对齐</strong>，例如计算以下结构体所占内存，char类型占1个字节，而int类型占4个字节，所以char类型向int类型对齐，则以下结构体所占内存为8。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为8。</p><p><img src="/./img/1685427766651.png"></p><p>以上为student结构体在内存的情况，0-3为整型类型num的存储空间，4-7为char类型sex的存储空间。</p><h2 id="共用体的简单介绍"><a href="#共用体的简单介绍" class="headerlink" title="共用体的简单介绍"></a>共用体的简单介绍</h2><p>上述结构体所占内存可见非常废内存，char类型占用1个字节就占一个字节，为什么占用4个字节，所以共用体就比较节约内存了。<strong>共用体内存看所占内存最大的那个类型。其他类型共用它的内存。</strong></p><p>共用体的定义和结构体的定义差不多，结构体定义所用的关键字为struct，共用体的定义所用关键字为union。所以以下仅对共用体所占内存进行描述。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">union</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> uni<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>uni <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>uni<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的结果为</p><p>a</p><p>a</p><p>1。</p><p><img src="/./img/1685428496266.png" alt="1685428496266"></p><p>以上为共用体的占用内存情况，uni和sex，因为uni和sex都仅占一个内存，所以赋值进行的覆盖，先赋值b，如何赋值a，但共用一个内存，所以a覆盖了b。</p><h2 id="枚举的介绍"><a href="#枚举的介绍" class="headerlink" title="枚举的介绍"></a>枚举的介绍</h2><p>之前介绍了结构体和共用体，结构体的关键字为struct，共用体的关键字为union，而枚举定义的关键字为enum。枚举类型简化了#define定义多个值的操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">,</span>    c<span class="token punctuation">,</span>    d<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//week为枚举名，p为枚举变量</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为0123。可以认为枚举中的变量值从0开始赋值。</p><h4 id="枚举的简单应用"><a href="#枚举的简单应用" class="headerlink" title="枚举的简单应用"></a>枚举的简单应用</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token comment">//枚举名</span><span class="token punctuation">{</span>    first<span class="token punctuation">,</span>    two<span class="token punctuation">,</span>    three<span class="token punctuation">,</span>    four<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//枚举的变量名p</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span>k<span class="token punctuation">;</span><span class="token comment">//对枚举变量进行赋值的变量也要是枚举类型，所以这里要进行强制类型转换</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">case</span> first<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> two<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> three<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> four<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为first。可以认为枚举变量中存储了</p><h4 id="枚举所占空间"><a href="#枚举所占空间" class="headerlink" title="枚举所占空间"></a>枚举所占空间</h4><p>C++标准文档中是这样说明的：“<strong>枚举类型的尺寸是以能够容纳最大枚举子的值的整数的尺寸</strong>”，同时标准中也说名了：“<strong>枚举类型中的枚举子的值必须要能够用一个int类型表述</strong>”。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论怎么添加枚举中的成员，输出的结果都为4个字节即一个整型类型的大小</p><h2 id="指针变量的介绍"><a href="#指针变量的介绍" class="headerlink" title="指针变量的介绍"></a>指针变量的介绍</h2><p>变量有int类型 char类型 doubke类型等等,指针变量也有同样的类型,不过指针的值是一个变量的地址,,<strong>实际上的是指针指向的是变量的地址</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> <span class="token comment">// 定义了一个整型类型的指针</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>             <span class="token comment">// 指针变量a指向整型变量b的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a指向变量的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印a指向的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打印变量b的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为</p><p>8<br>6487572<br>6487576<br>6487572</p><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>  <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// a为结构体变量,p为结构体指针,p指向a的地址</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10a</p><p>10a</p><h4 id="void类型的指针"><a href="#void类型的指针" class="headerlink" title="void类型的指针"></a>void类型的指针</h4><p>C语言中的void类型，代表任意类型，而不是空的意思，而是说它的类型是未知的，是还没指定的。<br>void * 是void类型的指针。void类型的指针的含义是：这是一个指针变量，该指针指向一个<br>void类型的数。void类型的数就是说这个数有可能是int，也有可能是float，也有可能是个结构体，哪种类型都有可能，只是我当前不知道。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>                    <span class="token comment">// p指向这个地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是int类型的，所以要强制转换成对应类型的指针</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是char类型的，所以要强制转换成对应类型的指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>a</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><strong>函数指针是实质上就是一个指针，不过他指向的是一个函数的地址。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义了一个函数指针</span>    p <span class="token operator">=</span> sum<span class="token punctuation">;</span><span class="token comment">//函数指针指向sum函数</span>    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span>     <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>9<br>9</p><h4 id="指针函数（和函数指针区别）"><a href="#指针函数（和函数指针区别）" class="headerlink" title="指针函数（和函数指针区别）"></a>指针函数（和函数指针区别）</h4><p>说到函数指针就不得不提到指针函数了，<strong>指针函数实质上是一个函数不过返回的是一个指针</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 定义一个指针用来接收返回的地址</span>    p <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指针p接收指针函数的返回的指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>max<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span> <span class="token comment">// 返回一个指针，这个指针指向的是最大值的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>数组指针同理，<strong>本质上也是一个指针不过指向的是一个数组</strong>，直接上代码感觉下面的代码已经很详细了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个二维数组的指针，注意要[3]为该数组指针的边界值</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>      <span class="token comment">// 二维数组指针指向b数组</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义了一个一维数组的指针</span>    q <span class="token operator">=</span> a<span class="token punctuation">;</span>      <span class="token comment">// 一维数组指针指向a数组</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意如果没有给出数组指针p的[3]这个边界值*(p+1)会报错说没有给出指针的边界值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>2<br>5</p><h4 id="指针数组（和数组指针区别）"><a href="#指针数组（和数组指针区别）" class="headerlink" title="指针数组（和数组指针区别）"></a>指针数组（和数组指针区别）</h4><p>同理，<strong>指针数组是一个是数组不过里面存放的是指针。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个指针数组</span>    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 数组里面的元素指向一个地址</span>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出指向地址的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2</p><p>3</p><p>4</p><h4 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>        <span class="token comment">// 指向这个指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// p1的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a的值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>000000000062FE08<br>000000000062FE14<br>000000000062FE14<br>5</p><h2 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h2><p>理解为一种思想，用结构体指针来实现的，结构体中的成员包括数据和结构体指针，结构体中的结构体指针指向的是下个结构体的地址，即用结构体中的结构体指针来链接各个结构体，整体称谓链表，那么有了链表就需要一个头指针来输出他，可以理解链表是多米诺骨牌，牌已经摆好了，只用推一下这个链表就展现到你眼前了，而这个推一下的动作就是头指针，</p><p><img src="/./img/1685508777711.png" alt="1685508777711"></p><h3 id="第一种静态链表的介绍与实现"><a href="#第一种静态链表的介绍与实现" class="headerlink" title="第一种静态链表的介绍与实现"></a>第一种静态链表的介绍与实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 创建一个节点</span><span class="token punctuation">}</span> p<span class="token punctuation">;</span>                      <span class="token comment">// 重新定义了struct student这个类型</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 给结构体变量赋值</span>    b<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>     <span class="token comment">// 头指针保存a的地址</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment">// a的节点保存结构体变量b的地址</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>   <span class="token comment">// b的节点保存结构体变量c的地址</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>   <span class="token comment">// c的节点保存结构体变量d的地址</span>    d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 给最后一个节点写个内容 用于判断节点是否已经遍历完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 头指针如果没有保存最后一个节点的内容 就一直遍历</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d  "</span><span class="token punctuation">,</span> head<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历score</span>        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>           <span class="token comment">// 把结构体中的next指针赋值给head结构体指针，则head指针指向的是下一个节点的地址。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10  20  30  40 </p><h3 id="第二种动态链表的介绍与实现"><a href="#第二种动态链表的介绍与实现" class="headerlink" title="第二种动态链表的介绍与实现"></a>第二种动态链表的介绍与实现</h3><p>静态链表是提前知道了有几个结构体变量，而实际上我们并不知道我们需要10个或者100个结构体变量来满足我们的需求，所以我们就需要一个动态的链表，我们需要多少它就给多少。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 定义结构体指用来指向下一个结构体的地址</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token comment">// 定义结构体指针函数用来动态定义链表并返回链表的头指针</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>                       <span class="token comment">// head指针指向链表的头指针，new指针指向新创建的结构体地址，last指针指向链表最后一个结构体</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先给头指针分配内存空间，不分配默认为4个字节</span>    last <span class="token operator">=</span> head<span class="token punctuation">;</span>                                             <span class="token comment">// 尾指针指向链表的最后一个结构体的地址</span>    head<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        q<span class="token operator">++</span><span class="token punctuation">;</span>        new <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给新添加的结点分配内存空间</span>        new<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>        last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span> <span class="token comment">// 链表与新创建的结构体链接起来</span>        last <span class="token operator">=</span> new<span class="token punctuation">;</span>       <span class="token comment">// 尾指针指向链表的最后一个结构体地址</span>    <span class="token punctuation">}</span>    last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 尾指针的值为空代表链表结束</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>       <span class="token comment">// 返回链表的头节点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 用来接收链表的头节点</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// 循环遍历链表并输出值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入5</p><p>输出的结果为01234</p><p>注意上述malloc分配的地址空间是连续的，比如为int *p整型指针分配8个字节，则8个字节的内存空间是连续的，并且可以用 *(p+0)和 *(p+1)来分别为其赋值。</p><h2 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break<strong>用于打断循环，也就是执行到break，直接跳出循环，</strong>可以打断for，switch，while，do..while。break可以跳出for，但是如果用一个以上的for，则是打断离它最近的for。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue<strong>用于跳出本次循环，不是退出循环，而是只跳出本次的循环</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>1.修饰全局变量，如果static修饰了全局变量，那只能在本工程使用，其他工程就不能调用了，</p><p>2.修饰局部变量，它是存储在静态存储区的，用static修饰过后，就是函数执行结束，值依然在，如果static未被赋值，默认值就是 0；</p><p>3.static修饰函数，函数也只能在本工程使用，其他工程不可调用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 修饰局部变量</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>12<br>11</p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token comment">// 注用extern修饰的变量要提前赋值且不能在为其赋值了，不然会报错。</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>0<br>1</p><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。</p><p>例如 typedef int a;表示的是为int取别名a，之后定int类型的变量可以 a  b；来定义一个整型变量b</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>1.对变量声明只读特性，保护变量值以防被修改</p><p>2.节省空间，避免不必要的内存分配。const修饰的变量在程序运行过程中只有一份拷贝</p><h3 id="define-无参"><a href="#define-无参" class="headerlink" title="#define 无参"></a>#define 无参</h3><p>#define 既不是定义，也不是声明，所以是不分配内存的，#define说白了就是替换的意思。</p><p>#define 宏名 字符串</p><h3 id="define-有参"><a href="#define-有参" class="headerlink" title="#define 有参"></a>#define 有参</h3><p>带参就是跟函数一样可以代替一些操作。</p><p>#define N(y) ((y)*(y))</p><h3 id="if"><a href="#if" class="headerlink" title="#if"></a>#if</h3><p>#if N </p><p>…</p><p>#else</p><p>…</p><p>如果N为真执行#if和#else之间的语句，否则执行#else之后的语句</p><h3 id="写过的题目"><a href="#写过的题目" class="headerlink" title="写过的题目"></a>写过的题目</h3><h4 id="一-链表的反转"><a href="#一-链表的反转" class="headerlink" title="一.链表的反转"></a>一.链表的反转</h4><p><img src="/./img/1685792379205.png" alt="1685792379205"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span><span class="token function">ReverseList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>pHead<span class="token punctuation">)</span><span class="token comment">//反转的指针函数</span><span class="token punctuation">{</span>    <span class="token comment">// write code here</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pHead <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pHead<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            q <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>            pHead <span class="token operator">=</span> pHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//遍历完之后要把头结点指向p</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ReverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用了两个指针，q和p分别指向头结点的前两个结点，可以说头节点带着q和p去找链表的结点，p改变结点的指向，</p><p>q保存了被指向的结点。</p><p>输出结果为321</p><h4 id="二-链表的合并"><a href="#二-链表的合并" class="headerlink" title="二.链表的合并"></a>二.链表的合并</h4><p><img src="/./img/1685875845805.png" alt="1685875845805"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//前面两个条件剔除了空链表的情况</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>val<span class="token operator">&lt;</span>list2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list1<span class="token operator">-&gt;</span>next<span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//让最小的节点指向下一次遍历返回的结果</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span><span class="token comment">//返回较小的节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>     <span class="token punctuation">{</span>        list2<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用到了递归算法，每次把两个链表较小的那个结点放入栈 的最低端，一直到其中一个链表遍历完，如何释放，得到链表的头结点点。</p>]]></content>
      
      
      <categories>
          
          <category> – C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本篇</title>
      <link href="/2023/08/30/c-ji-chu-pian/"/>
      <url>/2023/08/30/c-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<p>C++学习（进阶加基础）</p><p>本文笔记链接</p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>C++有自己的头文件，例如iostream 没有.h<br>也可以用C的头文件 例如stdio.h 有.h<br>或者将C文件C++化 例如<a href="https://so.csdn.net/so/search?q=cstdio&amp;spm=1001.2101.3001.7020">cstdio</a> 前面加c没有.h</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>1.划分逻辑单元。避免名字冲突，</p><p>2.同名的命名空间可以合并，有时候一个名字空间太冗余或者其他原因需要分开实现在不同地方，</p><p>3.声明和定义分开，在命名空间中声明的函数，定义时要加：：作用域限定符。</p><p>4.命名空间可以嵌套，调用时则用a：：b：：要调用的对象。</p><p>5.using namespace 名字空间名<br>使用后该名字空间对于当前作用域可见，可以不再使用作用域限定符，一旦使用，不可再隐藏。<br>std名字空间全局可见。std标准库定义名字空间。</p><h3 id="：：作用域限定符"><a href="#：：作用域限定符" class="headerlink" title="：：作用域限定符"></a>：：作用域限定符</h3><p>表示：：后面的内容属于：：前面。翻译成中文就是 的<br>如果：：前面没有内容表示全局</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;namespace a{    char name = 'a';    void eat()    {        cout &lt;&lt; "吃饭" &lt;&lt; endl;    }}namespace b{    char name = 'a';    void eat()    {        cout &lt;&lt; "喝水" &lt;&lt; endl;    }}int main(){    a::eat();    b::eat();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>吃饭<br>喝水</p><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><ul><li>true表示真 单字节整数1</li><li>false表示假 单字节整数0</li></ul><p>boolalpha bool类型使用字符输出<br>noboolalpha bool关闭字符输出，数值输出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    bool b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> boolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"字符输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> noboolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"数值输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> <span class="token string">"内存大小"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>字符输出true<br>数值输出1<br>内存大小1</p><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><ul><li>用函数已被编译好的二进制代码，替换对该函数的调用指令。提高效率，避免函数调用开销。</li><li><strong>使用inline关键字期望该函数被优化为内联，是否内联由编译器决定</strong>。</li><li>内联会使可执行文件内存变大，只有频繁调用的简单函数适合内联。复杂函数和递归函数都不适合内联。</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一作用域中，函数名相同，参数表不同的函数。重载和返回值和参数名没有关系。</p><blockquote><p>函数作用域不是定义决定的，是声明决定的。</p></blockquote><blockquote><p>重载是编译器通过换名实现，<br>在linux下 用gcc -c 获取.o 使用nm .o文件查看<br>在windows下查看obj文件，或者不定义函数，只声明和使用<br>通过extern “C”可以要求C++编译器按照C方式处理函数接口</p></blockquote><h4 id="缺省参数和哑元"><a href="#缺省参数和哑元" class="headerlink" title="缺省参数和哑元"></a>缺省参数和哑元</h4><p>为函数指定缺省值，调用时若未指定实参，则对应的形参取缺省值</p><h4 id="缺省参数的特点"><a href="#缺省参数的特点" class="headerlink" title="缺省参数的特点"></a>缺省参数的特点</h4><ol><li>最好在函数声明中指定。可以利用声明改缺省值。</li><li>禁止在声明和定义同时指定缺省参数。可能不一致，编译器禁止</li><li>缺省参数只能在最后，即你某个参数指定为缺省参数，后面所有参数都要有缺省值</li><li>不要因为是用缺省参数导致重载歧义</li></ol><p>只指定类型而不指定名称的函数参数，叫做哑元。<br>使用哑元1.兼容之前版本。二.形成函数重载</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）是c++对c语言的重要扩充。<br>引用就是某一变量（内存）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：<br>类型 &amp;引用变量名 = 已定义过的变量名。</p><p>&amp;符号：跟在类型后是引用，没有类型是取地址<br>*符号：跟在类型后是指针，没有类型是解引用</p><h4 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点"></a>引用的特点</h4><ul><li>一个变量可取多个别名。</li><li>引用必须初始化，不能为空。</li><li>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量</li></ul><h4 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h4><p>引用变量和被引用的变量虽然是同一个变量，但是可以被不同修饰符修饰</p><h4 id="引用做参数"><a href="#引用做参数" class="headerlink" title="引用做参数"></a>引用做参数</h4><ul><li>节省空间+提高效率</li><li>值传递，形参生成局部临时变量接收实参的值。</li><li>引用传递，形参是实参的别名</li><li>指针传递，传入实参的地址，指针通过地址访问修改值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void fun1(int a){    a += 1;}void fun2(int &amp;a){    a += 1;}void fun3(int *a){    *a += 1;}int main(){    int a = 10;    fun1(a);    cout &lt;&lt; a &lt;&lt; endl;    fun2(a);    cout &lt;&lt; a &lt;&lt; endl;    fun3(&amp;a);    cout &lt;&lt; a &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10<br>11<br>12</p><h4 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h4><p>当引用做函数的返回值时: 函数可以放在赋值语句的左边(可以当左值)</p><p>实现了动态引用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int &amp;fun1(int &amp;a){    return a;}int main(){    int b;    int c = 3;    int d = 4;    fun1(b) = c;    cout &lt;&lt; b &lt;&lt; endl;    fun1(b) = d;    cout &lt;&lt; b &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>3<br>4</p><h3 id="动态分配-内存池"><a href="#动态分配-内存池" class="headerlink" title="动态分配+内存池"></a>动态分配+内存池</h3><h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>C语言使用malloc来动态分配内存空间，free释放内存空间，C++使用new和delete来创建和释放内存空间</p><p>在分配内存的同时初始化 int *p=new int(100);表示 *p的值为100；数组方式new的需要以数组方式delete</p><p>int *p = new int[2]{4, 2};  delete [ ]p;</p><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>预先分配好，放到进程空间的内存块，用户申请与释放内存其实都是在进程内进行,遇到小对象时就是基于内存池的。只有当内存池空间不够时，才会再从系统找一块很大的内存</p><h3 id="引用和指针的区别和联系"><a href="#引用和指针的区别和联系" class="headerlink" title="引用和指针的区别和联系"></a>引用和指针的区别和联系</h3><p>两者都是地址的概念<br>指针指向一块内存，其内容为所指内存的地址；<br>引用是某块儿内存的别名。</p><p>1.指针是一个实体，而引用仅是个别名；<br>2.引用使用时无需解引用(*)，指针需要解引用；<br>3.引用只能在定义时被初始化一次，之后不可变；指针可变；<br>4.引用没有 const，指针有 const；const修饰的指针不可变；<br>5.引用不能为空，指针可以为空；<br>6.“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；<br>7.指针和引用的自增(++)运算意义不一样；<br>8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><h3 id="new-和delete实现二维数组的动态申请内存"><a href="#new-和delete实现二维数组的动态申请内存" class="headerlink" title="new 和delete实现二维数组的动态申请内存"></a>new 和delete实现二维数组的动态申请内存</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int **arr = NULL;int **fun(int a, int b) // 动态分配数组函数{    int i;    arr = new int *[a]; // 创建指向一维数组的指针数组    for (int i = 0; i &lt; b; i++)    {        arr[i] = new int[b]; // 为每一个指针数组的值进行赋值    }    arr[0][0] = 5;    return arr;}int main(){    int **q; // 用来接收函数返回的二维数组的头地址    int a, b;    cin &gt;&gt; a &gt;&gt; b; // 输入行列    q = fun(a, b);    cout &lt;&lt; **q &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入</p><p>2</p><p>2</p><p>输出结果为</p><p>5</p>]]></content>
      
      
      <categories>
          
          <category> – C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2023/08/30/jvm-la-ji-hui-shou/"/>
      <url>/2023/08/30/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h4 id="1-1-引用计数器"><a href="#1-1-引用计数器" class="headerlink" title="1.1.引用计数器"></a>1.1.引用计数器</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>垃圾回收引用计数法（Reference Counting Garbage Collection）是一种常用的垃圾回收算法，它的基本思想是对每个对象记录它的引用计数，当引用计数为0时，就可以将这个对象回收掉。</li></ul><h5 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h5><ul><li>为每个对象维护一个引用计数器，记录当前有多少个指针引用了这个对象。</li><li>当有一个指针指向了这个对象时，引用计数器加1；当有一个指针不再引用这个对象时，引用计数器减1。</li><li>当引用计数器为0时，说明这个对象已经没有任何指针引用它了，可以将这个对象回收掉。</li></ul><h5 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><p><strong>优点</strong></p><p>​可以实现快速的内存回收，因为它不需要遍历整个堆内存，只需要回收引用计数为0的对象即可。</p><p><strong>缺点</strong></p><p>​实现比较复杂，需要为每个对象维护引用计数器，而且容易出现循环引用的问题，导致内存泄漏。</p><p><img src="/./img/6.5.png"></p><p>​<strong>循环引用指的是两个或多个对象之间相互引用，形成了一个闭环，如果这些对象的引用计数都不为0，那么它们将永远无法被回收，从而导致内存泄漏。</strong></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2.可达性分析算法"></a>1.2.可达性分析算法</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>​可达性分析算法（Reachability Analysis Algorithm）是现代垃圾回收算法中最常用的一种。它的基本思想是从一组根对象开始，通过<strong>遍历对象之间的引用关系</strong>，找到所有可以被访问到的对象，并将这些对象标记为存<strong>活对象</strong>。所有未被标记的对象则可以被视为<strong>垃圾对象</strong>，可以被回收</p><h5 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h5><ol><li><p>从一组根对象(gc_roots)开始，例如Java虚拟机中的堆栈、静态变量等。</p></li><li><p>遍历所有根对象能够访问到的对象，将这些对象标记为存活对象。</p></li><li><p>遍历所有已标记的存活对象，找到它们所引用的对象，将这些对象也标记为存活对象。</p></li><li><p>重复步骤3，直到所有可达对象都被标记为存活对象。</p></li><li><p>将未被标记的对象作为垃圾对象，进行回收。</p><p><strong>根对象(gc_roots)的查看（MAT工具）</strong></p><p><img src="/./img/6.6.png"></p></li></ol><h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3.四种引用"></a>1.3.四种引用</h4><p><img src="/./img/6.7.png"></p><h5 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h5><ul><li>强引用是最常见的引用类型</li><li>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li><li>通过<strong>new关键字创建一个对象</strong>，该对象具有强引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h5><ul><li>软引用是一种相对强引用弱化了一些的引用类型。</li><li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时</strong>会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li><li>常用于<strong>缓存对象，例如，图片缓存、数据缓存</strong>等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h5><ul><li>弱引用比软引用还要弱化一些。</li><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li><li>常用于<strong>ThreadLocal、WeakHashMap</strong>等</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h5><ul><li><p>虚引用是最弱化的引用类型。</p></li><li><p>如果一个对象只具有虚引用，那么无法通过虚引用获取到该对象，也无法通过虚引用对该对象进行任何操作。</p></li><li><p>虚引用主要用于在对象被回收时收到一个系统通知，例如，当一个对象被回收时，可以在虚引用的引用队列中收到通知。</p></li><li><p>必须配合引用队列使用，主要配合 <strong>ByteBuffer</strong>使用，被引用对象回收时，会将虚引用入队，由<strong>Reference Handler</strong>线程调用虚引用相关方法释放直接内存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="5-终结器引用"><a href="#5-终结器引用" class="headerlink" title="5.终结器引用"></a>5.终结器引用</h5><ul><li>终结器引用是一种特殊的引用类型，用于在对象被回收之前执行特定的清理操作。</li><li>无需手动编码，但其内部配合引用队列使用</li><li>终结器引用入队（被引用对象暂时没有被回收)，再由<strong>Finalizer线程</strong>通过终结器引用找到被引用对象并调用它的<strong>finalize方法</strong>，第二次GC时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1.标记清除"></a>2.1.标记清除</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记清除（Mark and Sweep）是一种垃圾回收算法，用于自动内存管理。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法分为两个阶段：标记和清除。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在清除阶段，垃圾回收器清除未被标记的对象，释放它们占用的内存。</li></ul><p><img src="/./img/7.1.png"></p><h5 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点：可以处理循环引用的情况，即当两个或多个对象相互引用时，它们之间的引用关系会被正确地识别和处理。</li><li>缺点：清除内存的过程可能会导致内存碎片化。</li></ul><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2.标记整理"></a>2.2.标记整理</h4><h5 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记整理（Mark and Compact）是标记清除算法的改进版本，在标记和清除阶段之后，还会对内存进行<strong>整理</strong>，以解决标记清除算法可能导致的内存碎片化问题。</p><h5 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h5><p>算法也分为两个阶段：标记和整理。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在整理阶段，垃圾回收器将所有标记为“存活”的对象移动到内存的一端，将未被标记的对象移动到内存的另一端，然后将这些未被标记的内存区域释放掉，以形成一块<strong>连续的内存空间</strong>。</li></ul><p><img src="/./img/7.2.png"></p><h5 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以解决标记清除算法可能导致的内存碎片化问题，从而减少了内存分配失败的概率。</li><li>缺点在于它需要在程序暂停时执行垃圾回收操作，可能会影响程序的性能。</li></ul><h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3.复制"></a>2.3.复制</h4><h5 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h5><p>复制（Copying）是将内存分为两个区域，每次只使用其中的一半。当当前区域的内存使用率达到一定阈值时，垃圾回收器会扫描当前区域中的存活对象，将它们复制到另一个空闲区域中，然后将当前区域清空，以便下一轮内存分配使用。</p><h5 id="2-作用-2"><a href="#2-作用-2" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法的主要步骤如下：</p><ol><li><p>将内存分为两个大小相等的区域，分别称为“From Space”和“To Space”。初始时，所有对象存放在From Space中。当From Space中的内存使用率达到一定阈值时，垃圾回收器开始扫描From Space中的存活对象。</p><p><img src="/./img/8.1.png"></p></li><li><p>垃圾回收器将这些存活对象复制到To Space中，并按照它们在From Space中的顺序排列。</p><p><img src="/./img/8.2.png"></p></li><li><p>垃圾回收器清空From Space，使其成为空闲空间。<img src="/./img/8.3.png"></p></li><li><p>交换From Space和To Space的角色，使To Space成为新的From Space，From Space成为空闲空间。</p><p><img src="/./img/8.4.png"></p></li></ol><h5 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以避免内存碎片化问题，因为每次复制存活对象时，都会将它们按顺序排列在新的空间中，从而形成一块连续的内存空间。另外，复制算法不需要执行标记和清除或标记和整理等额外的操作，因此执行起来比较高效。</li><li>缺点在于它需要使用双倍的内存空间来执行复制操作，这可能会导致<strong>内存使用率较低</strong>。此外，复制算法不能有效地处理长时间存活的对象，因为这些对象需要被反复复制，导致垃圾回收的效率降低。因此，复制算法通常用于<strong>处理生命周期短的对象</strong>，例如临时变量和函数调用栈中的对象。</li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3.分代垃圾回收"></a>3.分代垃圾回收</h2><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>Minor GC（新生代垃圾回收）是指针对新生代内存区域进行的垃圾回收，新生代内存区域通常是指年轻代和幸存者代。</li><li>Full GC（老年代垃圾回收）是指针对整个堆内存进行的垃圾回收。堆内存通常是指整个Java虚拟机中的内存区域，包括新生代和老年代。</li></ul><h5 id="2-作用-3"><a href="#2-作用-3" class="headerlink" title="2.作用"></a>2.作用</h5><p><img src="/./img/8.5.png"></p><ul><li><p>对象首先分配在伊甸园区域</p><p>当一个大对象内存大于伊甸园的内存时，就直接进入老年代</p><p>大对象内存也大于老年代的内存时，就会进行full gc</p></li><li><p>新生代空间不足时，<strong>触发minor gc</strong>，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to</p></li><li><p>minor gc 会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15 (4bit)</p></li><li><p>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么<strong>触发full gc</strong>，STW的时间更长</p></li></ul><p>3.相关jvm参数</p><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或-XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn或(-XX:NewSize=size +-XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-xX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-xx:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h4 id="4-1-串行回收器"><a href="#4-1-串行回收器" class="headerlink" title="4.1.串行回收器"></a>4.1.串行回收器</h4><h5 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h5><h5 id="2-堆内存较小，适合个人电脑"><a href="#2-堆内存较小，适合个人电脑" class="headerlink" title="2.堆内存较小，适合个人电脑"></a>2.堆内存较小，适合个人电脑</h5><p><strong>serial、Serial old收集器</strong>（Hotspot中Client模式下默认的新生代垃圾收集器）</p><p><strong>算法：复制算法、串行回收和”Stop The World”机制的方式执行内存回收</strong></p><p>​<strong>除新生代之外，Serial还提供用于老年代垃圾回收的Serial Old收集器。Serial Old同样采用了串行回收和”Stop The World”，只不过内存回收算法使用的是标记-压缩算法</strong></p><p><img src="/./img/a1.png"></p><h4 id="4-2-并行回收器"><a href="#4-2-并行回收器" class="headerlink" title="4.2.并行回收器"></a>4.2.并行回收器</h4><h5 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu"><a href="#2-堆内存较大，多核cpu" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-单位时间内，stw时间最短"><a href="#3-单位时间内，stw时间最短" class="headerlink" title="3.单位时间内，stw时间最短"></a>3.单位时间内，stw时间最短</h5><p><strong>Parallel收集器</strong>(jdk8默认使用)、ParNew、Parallel scavenge、Parallel old</p><p><strong>算法：复制算法、并行回收、”Stop The World”</strong></p><p>​<strong>Parallel在JDK1.6提供了用于执行老年代的Parallel Old，用来代替Serial Old<br>​Parallel Old采用了标记-压缩算法，但同样是基于并行回收、”Stop The World”</strong></p><p><strong>目标：是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾回收器</strong><br>           <strong>自适应调节策略也是Parallel Scavenge和ParNew的区别</strong></p><p>高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：执行<strong>批量处理、订单处理、工资支付、科学计算</strong>的应用程序</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>-XX:+UseParallelGC~-XX:+UseParalleloldGc</p><p><img src="/./img/b1.png"></p><h4 id="4-3-并发回收器"><a href="#4-3-并发回收器" class="headerlink" title="4.3.并发回收器"></a>4.3.并发回收器</h4><h5 id="1-多线程-1"><a href="#1-多线程-1" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu-1"><a href="#2-堆内存较大，多核cpu-1" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-尽可能让单次的stw时间最短"><a href="#3-尽可能让单次的stw时间最短" class="headerlink" title="3.尽可能让单次的stw时间最短"></a>3.尽可能让单次的stw时间最短</h5><h5 id="4-3-1-CMS收集器"><a href="#4-3-1-CMS收集器" class="headerlink" title="4.3.1.CMS收集器"></a>4.3.1.CMS收集器</h5><p><strong>算法：CMS采用标记-清除算法，也会有STW</strong></p><p><strong>目的：尽可能缩短垃圾回收时用户线程的停顿时间。停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验</strong></p><p>过程：</p><ol><li>初始标记阶段(Initial-Mark)：所有的工作线程会因为STW而出现短暂的停顿，这个阶段的主要任务仅仅只是标记除GC Roots能直接关联到的对象。一旦标记完成后就会恢复之前的应用线程。由于直接关联对象比较小，所以这里速度非常快</li><li>并发标记(Concurrent-Mark)：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但是不需要停顿用户线程，可以与垃圾回收线程并发运行</li><li>重新标记(Remark)：由于在并发标记阶段中，程序的工作线程会和垃圾回收线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除(Concurrent-Sweep)：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发的</li></ol><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>-XX:+UseConcMarkSweepGC~ -XX :+UseParNewGC ~ Serialold</p><p><img src="/./img/c1.png"></p><h5 id="4-3-2-G1"><a href="#4-3-2-G1" class="headerlink" title="4.3.2.G1"></a>4.3.2.G1</h5><p><img src="/./img/d1.png"></p><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>   G1（Garbage First）收集器是 JDK7 提供的一个新收集器，在 JDK9 中更被指定为官方GC收集器，与CMS收集器相比，最突出的改进是：</p><blockquote><ul><li>基于 “标记-整理” 算法，收集后不会产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ul></blockquote><p> G1 收集器不采用传统的新生代和老年代物理隔离的布局方式，仅在逻辑上划分新生代和老年代，将整个堆内存划分为2048个大小相等的独立内存块Region，每个Region是逻辑连续的一段内存并使用不同的Region来表示新生代和老年代，G1不再要求相同类型的 Region 在物理内存上相邻，而是通过Region的动态分配方式实现逻辑上的连续。</p><p>​        G1收集器通过跟踪Region中的垃圾堆积情况，每次根据设置的垃圾回收时间，回收优先级最高的区域，避免整个新生代或整个老年代的垃圾回收，使得stop the world的时间更短、更可控，同时在有限的时间内可以获得最高的回收效率。</p><p>​        通过区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>G1垃圾回收器的工作过程主要包括以下几个步骤：</p><ol><li><p>初始标记阶段（Initial Mark）：这个阶段是G1垃圾回收器的STW（Stop-The-World）阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的根对象，并标记所有的年轻代对象和部分老年代对象。这个阶段的主要目的是确定哪些对象是存活的，哪些对象可以被回收。</p></li><li><p>并发标记阶段（Concurrent Mark）：这个阶段是G1垃圾回收器的并发标记阶段，即在应用程序运行的同时，对存活对象进行标记。在这个阶段，G1会对所有的老年代对象进行标记。这个阶段的主要目的是标记所有的存活对象，为下一阶段的回收做准备。</p></li><li><p>并发预清理阶段（Concurrent Preclean）：这个阶段是G1垃圾回收器的并发预清理阶段，即在应用程序运行的同时，对标记的对象进行清理。在这个阶段，G1会清理掉一些无用的对象，以便在下一阶段的回收中提高效率。</p></li><li><p>最终标记阶段（Final Mark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的存活对象，以及在并发标记阶段和并发预清理阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>筛选回收阶段（Live Data Counting and Evacuation）：这个阶段是G1垃圾回收器的并发筛选回收阶段，即在应用程序运行的同时，对标记的对象进行筛选和回收。在这个阶段，G1会根据区域的垃圾比例和空间利用率等因素，动态选择回收对象，以最大化回收效率。这个阶段的主要目的是回收垃圾最多的区域，以最大化回收效率。</p></li><li><p>再次标记阶段（Remark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记在筛选回收阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>清理阶段（Cleanup）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会回收所有未被标记的对象，并进行内存整理。这个阶段的主要目的是回收内存空间，为应用程序提供足够的可用内存。</p></li></ol><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)，默认的暂停目标是200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region<br>整体上是标记+整理算法，两个区域之间是复制算法</li><li>缺点，例如在回收大对象时的性能可能不如其他垃圾回收器。</li></ul><h6 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h6><p>-XX : +UseG1GC<br>-XX:G1HeapRegionsize=size|<br>-XX:MaxGCPauseMillis=time</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p><img src="/./img/12.png"></p><p>最小化地使用内存和并行开销，请选serial GC;</p><p>最大化应用程序的吞吐量，请选Parallel GC;</p><p>最小化Gc的中断或停顿时间，请选CMs GC。</p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h2><h5 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h5><p><strong>案例1：Full GC和Minor GC频繁</strong></p><p>​在此情形下，需要先确定应用程序的内存使用情况，例如堆内存大小、对象创建和销毁的频率等。如果堆内存过小，可能会导致垃圾收集的频率增加，从而影响应用程序的性能。可以通过增加堆内存大小来减少垃圾收集的频率。</p><p>​另外，需要分析垃圾收集的日志，查看Full GC和Minor GC的发生频率和原因。如果Full GC和Minor GC的发生频率过高，可能是因为应用程序中存在大量的无用对象或内存泄漏。可以使用一些内存分析工具来识别和优化这些问题，例如查看内存堆转储（heap dump）中的对象信息、分析对象引用关系等。</p><p><strong>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong></p><p>​在此情形下，需要增加CMS收集器的并发线程数，以提高CMS收集器的并发处理能力，减少单次Full GC的暂停时间。可以使用参数”-XX:CMSConcurrentMTEnabled”来启用CMS收集器的多线程并发模式。</p><p>​另外，需要分析Full GC的日志，查看Full GC的原因和持续时间。如果Full GC的持续时间过长，可能是因为CMS收集器的老年代空间不足，导致Full GC无法回收足够的内存空间。可以通过增加老年代的空间大小来解决这个问题。</p><p><strong>案例3：老年代充裕情况下，发生Full GC（1.7）</strong></p><p>​在此情形下，可能是因为应用程序中存在大量的长时间存活的对象，导致老年代空间被占满，无法再分配新的对象。可以通过增加老年代的空间大小来解决这个问题。</p><p>​另外，还可以考虑使用G1收集器来改善垃圾收集的效率和性能。G1收集器可以根据应用程序的实际情况，动态调整垃圾回收的策略和参数，以最小化暂停时间和最大化吞吐量。可以通过使用参数”-XX:+UseG1GC”来启用G1收集器。</p>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的内存结构</title>
      <link href="/2023/08/30/jvm-nei-cun-jie-gou/"/>
      <url>/2023/08/30/jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><ul><li><h5 id="JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"><a href="#JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。" class="headerlink" title="JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"></a>JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。</h5></li></ul><h4 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2.作用"></a>1.2.作用</h4><p><img src="/./img/2.1.png"></p><ol><li><h5 id="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"><a href="#用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。" class="headerlink" title="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"></a>用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。</h5></li><li><h5 id="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"><a href="#实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。" class="headerlink" title="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"></a>实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。</h5></li></ol><h4 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3.特点"></a>1.3.特点</h4><ol><li><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5></li><li><h5 id="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"><a href="#是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区" class="headerlink" title="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"></a>是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区</h5></li><li><h5 id="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"><a href="#执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空" class="headerlink" title="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"></a>执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空</h5></li></ol><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><p><img src="/./img/2.png"></p><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><h5 id="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"><a href="#JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。" class="headerlink" title="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"></a>JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。</h5><p><img src="/./img/2.2.PNG"></p><ul><li><h5 id="每个线程运行是所需要的内存，称为虚拟机栈"><a href="#每个线程运行是所需要的内存，称为虚拟机栈" class="headerlink" title="每个线程运行是所需要的内存，称为虚拟机栈"></a>每个线程运行是所需要的内存，称为虚拟机栈</h5></li><li><h5 id="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"><a href="#每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存" class="headerlink" title="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"></a>每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存</h5></li><li><h5 id="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"><a href="#每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法" class="headerlink" title="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"></a>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</h5><h5 id="问题解析："><a href="#问题解析：" class="headerlink" title="问题解析："></a>问题解析：</h5><p><strong>(1).垃圾回收是否涉及栈内存?</strong></p><p>​垃圾回收（Garbage Collection）一般是针对堆内存（Heap Memory）的，而与栈内存（Stack Memory）没有直接关系。</p><p><strong>(2).栈内存分配越大越好吗?</strong></p><p>​栈内存的大小应该根据具体的需求和系统资源进行合理分配，不是越大越好。</p><p><strong>(3).方法内的局部变量是否线程安全?│</strong></p><h5 id="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"><a href="#–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的" class="headerlink" title="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"></a>–<strong>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</strong></h5><h5 id="–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全"><a href="#–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全" class="headerlink" title="–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全"></a>–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全</h5></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2.栈内存溢出"></a>2.2.栈内存溢出</h4><h5 id="–出现StackOverflowError-异常"><a href="#–出现StackOverflowError-异常" class="headerlink" title="–出现StackOverflowError 异常"></a>–出现StackOverflowError 异常</h5><ul><li><h5 id="栈帧过多导致栈内存溢出-方法调用层次过深"><a href="#栈帧过多导致栈内存溢出-方法调用层次过深" class="headerlink" title="栈帧过多导致栈内存溢出(方法调用层次过深)"></a>栈帧过多导致栈内存溢出(方法调用层次过深)</h5><p><img src="/./img/%E6%A0%881.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="栈帧过大导致栈内存溢出-方法中创建过多的局部变量"><a href="#栈帧过大导致栈内存溢出-方法中创建过多的局部变量" class="headerlink" title="栈帧过大导致栈内存溢出(方法中创建过多的局部变量)"></a>栈帧过大导致栈内存溢出(方法中创建过多的局部变量)</h5><p><img src="/./img/%E6%A0%882.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置虚拟机栈大小-："><a href="#设置虚拟机栈大小-：" class="headerlink" title="设置虚拟机栈大小  ："></a>设置虚拟机栈大小  ：</h5><ol><li>-Xss：用于设置单个线程的栈大小。</li><li>-XX:ThreadStackSize：也可以使用这个参数来设置单个线程的栈大小。</li><li>在启动 Java 应用程序时通过指定这些参数来设置虚拟机栈的大小，例如：java -Xss1m MyClass</li></ol></li></ul><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3.线程运行诊断"></a>2.3.线程运行诊断</h4><ul><li><h5 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h5><p><strong>定位:</strong></p><h6 id="a-用top定位哪个进程对cpu的占用过高"><a href="#a-用top定位哪个进程对cpu的占用过高" class="headerlink" title="a.用top定位哪个进程对cpu的占用过高"></a>a.用top定位哪个进程对cpu的占用过高</h6><h6 id="b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高"><a href="#b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高" class="headerlink" title="b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)"></a>b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)</h6><h6 id="c-jstack-进程id"><a href="#c-jstack-进程id" class="headerlink" title="c.jstack 进程id"></a>c.jstack 进程id</h6><h6 id="可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号"><a href="#可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号" class="headerlink" title="可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号"></a>可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</h6></li><li><h5 id="程序运行很长时间没有结果"><a href="#程序运行很长时间没有结果" class="headerlink" title="程序运行很长时间没有结果"></a>程序运行很长时间没有结果</h5><p><img src="/./img/x.png"></p></li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="/./img/3.png"></p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><h5 id="本地方法栈的主要功能是为执行本地方法时提供栈空间"><a href="#本地方法栈的主要功能是为执行本地方法时提供栈空间" class="headerlink" title="本地方法栈的主要功能是为执行本地方法时提供栈空间"></a>本地方法栈的主要功能是为执行本地方法时提供栈空间</h5><h5 id="本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"><a href="#本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。" class="headerlink" title="本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"></a>本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。</h5><h6 id="JVM-中的本地方法主要有以下两种类型："><a href="#JVM-中的本地方法主要有以下两种类型：" class="headerlink" title="JVM 中的本地方法主要有以下两种类型："></a>JVM 中的本地方法主要有以下两种类型：</h6><ul><li>​-Native 方法：Native 方法是指在 Java 中声明的本地方法，其实现由本地代码编写。</li><li>​-JNI 方法：JNI 方法是指在本地代码中实现的 Java 方法</li></ul><h4 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2.举例"></a>3.2.举例</h4><ul><li><p>java.lang.System：System 类包含一些与系统操作相关的本地方法，例如获取系统属性、读取标准输入输出流等。</p></li><li><p>java.io.FileDescriptor：FileDescriptor 类封装了一个操作系统文件描述符，它的本地方法用于创建、读写和关闭文件。</p></li><li><p>java.net.SocketImpl：SocketImpl 类是一个网络套接字的实现类，它的本地方法用于创建和管理底层的网络连接。</p></li><li><p>java.util.zip.Inflater：Inflater 类是一个压缩解压缩器，它的本地方法用于解压缩数据。</p></li><li><p>java.util.Random：Random 类是一个随机数生成器，它的本地方法用于获取随机数种子和生成随机数。</p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="/./img/4.png"></p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><h5 id="1-Heap-堆"><a href="#1-Heap-堆" class="headerlink" title="1.Heap 堆"></a>1.Heap 堆</h5><h5 id="堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"><a href="#堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。" class="headerlink" title="堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"></a>堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（<strong>通过new关键字创建对象）等数据。</strong></h5><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><ul><li><h5 id="是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器"><a href="#是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器" class="headerlink" title="是线程共享的:  堆中对象要考虑线程安全的问题–> 线程栈和程序计数器"></a>是线程共享的:  堆中对象要考虑线程安全的问题–&gt; 线程栈和程序计数器</h5></li><li><h5 id="有垃圾回收机制"><a href="#有垃圾回收机制" class="headerlink" title="有垃圾回收机制"></a>有垃圾回收机制</h5></li><li><h5 id="动态分配-堆的空间大小是在-JVM-启动时动态分配的"><a href="#动态分配-堆的空间大小是在-JVM-启动时动态分配的" class="headerlink" title="动态分配:  堆的空间大小是在 JVM 启动时动态分配的"></a>动态分配:  堆的空间大小是在 JVM 启动时动态分配的</h5></li><li><h5 id="分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象"><a href="#分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象" class="headerlink" title="分代管理：分为新生代和老年代 –>  新创建的对象,经过多次垃圾回收的对象"></a>分代管理：分为新生代和老年代 –&gt;  新创建的对象,经过多次垃圾回收的对象</h5></li><li><h5 id="物理实现：由操作系统的虚拟内存来实现的"><a href="#物理实现：由操作系统的虚拟内存来实现的" class="headerlink" title="物理实现：由操作系统的虚拟内存来实现的"></a>物理实现：由操作系统的虚拟内存来实现的</h5></li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2.堆内存溢出"></a>4.2.堆内存溢出</h4><h5 id="–出现OutOfMemoryError异常"><a href="#–出现OutOfMemoryError异常" class="headerlink" title="–出现OutOfMemoryError异常"></a>–出现OutOfMemoryError异常</h5><ol><li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序会不断地创建字符串对象并添加到列表中，当字符串的数量太大时，就会导致堆内存溢出错误，抛出 OutOfMemoryError 异常。</p></li><li><h5 id="设置虚拟机堆大小"><a href="#设置虚拟机堆大小" class="headerlink" title="设置虚拟机堆大小"></a>设置虚拟机堆大小</h5><h5 id="Xms：设置-Java-堆的初始大小。"><a href="#Xms：设置-Java-堆的初始大小。" class="headerlink" title="-Xms：设置 Java 堆的初始大小。"></a>-Xms：设置 Java 堆的初始大小。</h5><h5 id="Xmx：设置-Java-堆的最大大小。"><a href="#Xmx：设置-Java-堆的最大大小。" class="headerlink" title="-Xmx：设置 Java 堆的最大大小。"></a>-Xmx：设置 Java 堆的最大大小。</h5></li></ol><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3.堆内存诊断"></a>4.3.堆内存诊断</h4><ul><li><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5></li></ul><ol><li>jps 指令<br>查看当前系统中有哪些java进程</li><li>jmap-heap {pid}  指令<br>查看堆内存占用情况</li><li>jconsole指令  -&gt;工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 指令</li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="/./img/5.png"></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"><a href="#JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。" class="headerlink" title="JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"></a>JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。</h5><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h4><p><img src="/./img/5.1.png"></p><ul><li><h5 id="在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"><a href="#在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。" class="headerlink" title="在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"></a>在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。</h5></li><li><h5 id="在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"><a href="#在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。" class="headerlink" title="在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"></a>在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。</h5></li></ul><h4 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h4><h5 id="出现OutOfMemoryError-Metaspace-异常"><a href="#出现OutOfMemoryError-Metaspace-异常" class="headerlink" title="-出现OutOfMemoryError:Metaspace 异常"></a>-出现OutOfMemoryError:Metaspace 异常</h5><ol><li><p><strong>示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Path</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaspaceOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.example.DynamicClass"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token class-name">String</span> classPath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>**调整元空间的大小   **</p><p><strong>-XX:MaxMetaspaceSize = 8m</strong></p><p><strong>jdk1.6的情况 -XX:MaxPermSize=8m</strong></p></li></ol><h4 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstantPoolExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 常量池中的字符串常量</span>                <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将"Hello, world!"字符串常量放入常量池中</span>        <span class="token comment">// 在编译时将"Hello, world!"字符串常量放入常量池中并将str2指向常量池中的同一个字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>         <span class="token comment">// 在运行时，创建一个新的字符串对象，并将其指向堆中新建的一个对象</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个字符串常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为它们指向不同的对象</span>                <span class="token comment">// 常量池中的数字常量</span>        <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将数字常量100放入常量池中</span>        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 将数字常量100放入常量池中，并将num2指向常量池中的同一个数字常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个数字常量</span>                <span class="token comment">// 常量池中的类引用</span>        <span class="token comment">// 在编译时，将ConstantPoolExample类的引用放入常量池中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">ConstantPoolExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>         <span class="token comment">// 在编译时，将字符串常量"ConstantPoolExample"放入常量池中</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"ConstantPoolExample"</span><span class="token punctuation">;</span> <span class="token comment">// true，它们都指向常量池中的同一个类引用</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</strong>**</li><li><em><em>运行时常量池，常量池是</em>.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</em>*</li></ul><h4 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>StringTable 是 Java 虚拟机（JVM）中的一个<strong>数据结构</strong>(JDK 8 中基于字符串哈希值的分离链接哈希表)，用于存储字符串常量。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>StringTable 的作用是<strong>优化字符串的存储和共享</strong>，从而减少内存的开销。</p><p>在 Java 应用程序中，字符串常量通常占用较大的内存空间，如果每次都创建新的字符串对象，会导致内存占用量增加，从而影响应用程序的性能。为了避免这种情况，Java 使用了 StringTable 来存储字符串常量，并在<strong>需要使用(延迟加载)字符串常量时直接引用 StringTable 中的对象</strong>，从而避免了重复创建字符串对象，减少了内存占用量。</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为字符串常量是共享的</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为字符串对象不是共享的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./img/s.jpg"></p><ul><li>在String s4 = s1+s2 是通过new StringBuilder()…  –&gt;字符串变量 s4 是通过字符串变量 a 和 b 的拼接得到的，它是一个新的字符串对象，与字符串常量 “ab” 不相等，</li><li>String s5 = “a”+”b”  是在StringTable中取的已存在的”ab”   –&gt; 字符串常量 “ab” 和 “a” + “b” 的值相等</li></ul><h5 id="4-特性"><a href="#4-特性" class="headerlink" title="4.特性"></a>4.特性</h5><ol><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是StringBuilder ( 1.8)</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用intern方法，主动将串池中还没有的字符串对象放入串池</p><p><strong>1.8将这个字符串对象尝试放入串池，如果有则并不会放入（还在堆区），如果没有则放入串池(堆区-&gt;常量池），会把串池中的对象返回</strong><br><strong>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份,放入串池,会把串池中的对象返回</strong></p><p>–示例一：   String s = new String(“a”)+new String (“b”)”写在String x = “ab前面</p><p><img src="/./img/51.png"></p><p>1.8中：”ab” 在串池中没有，会将s放入串池(s从堆区-&gt;常量池），得到的结果为：s==x 为true</p><p>1.6中：”ab” 在串池中没有，会将s拷贝一份再放入串池(s还在堆区），得到的结果为：s==x 为false</p><p>–示例二：如果将String x = “ab”写在String s = new String(“a”)+new String (“b”)前面</p><p>如果有则并不会放入–&gt;都不会进入串池 s==x  都为 false</p></li></ol><h5 id="5-位置"><a href="#5-位置" class="headerlink" title="5.位置"></a>5.位置</h5><p><img src="/./img/61.png"></p><ul><li><p>JDK 7 及之前的版本中，String Table 是一个固定大小的哈希表存储在永久代中，因此在运行时无法动态扩容</p></li><li><p>JDK 8 引入了一种叫做 <strong>Compact Strings</strong> 的技术，可以将字符串常量存储在堆中</p><p>Compact Strings 技术的实现方式是将较短的字符串常量（长度小于等于 16）存储为字节数组，而不是存储为 char 数组。</p></li></ul><h5 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6.垃圾回收"></a>6.垃圾回收</h5><p><img src="/./img/62.png"></p><h5 id="7-调优"><a href="#7-调优" class="headerlink" title="7.调优"></a>7.调优</h5><ul><li>可通过参数 <code>-XX:StringTableSize</code> 来设置 StringTable 的桶大小</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableBenchmark</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NUM_STRINGS</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">BUCKET_SIZES</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1009</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">65536</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">:</span> <span class="token constant">BUCKET_SIZES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Testing with bucket size "</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">runBenchmark</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 构造大量的字符串常量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">NUM_STRINGS</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"string"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 调整 StringTable 的桶大小</span>        <span class="token class-name">StringTable</span><span class="token punctuation">.</span><span class="token function">adjustSize</span><span class="token punctuation">(</span>bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印 StringTable 的统计信息</span>        <span class="token class-name">StringTableStats</span><span class="token punctuation">.</span><span class="token function">printStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印程序运行时间</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Time taken: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">1009</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">1009</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">6.579</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">17</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">1267</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">8192</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">8192</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">1.219</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">6</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">891</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">65536</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">65536</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">0.153</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">1</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">849</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以考虑将字符串对象入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"><a href="#JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存" class="headerlink" title="JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"></a>JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存</h5><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h4><p><strong>JVM直接内存可以通过Java NIO（New I/O）库中的ByteBuffer类来进行访问和操作，它的主要特点是可以提高I/O操作的效率，减少内存复制和上下文切换的开销。</strong></p><h5 id="–java的io操作-存在缓冲区的复制操作"><a href="#–java的io操作-存在缓冲区的复制操作" class="headerlink" title="–java的io操作(存在缓冲区的复制操作)"></a>–java的io操作(存在缓冲区的复制操作)</h5><p><img src="/./img/6.1.png"></p><h5 id="–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024"><a href="#–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024" class="headerlink" title="–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);"></a>–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);</h5><p>这个方法会在<strong>堆内存</strong>中分配一个DirectByteBuffer对象，并在<strong>操作系统</strong>中分配一块原生内存，用来存储ByteBuffer对象中的数据。</p><p><img src="/./img/6.2.png"></p><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h4><h5 id="直接内存的释放："><a href="#直接内存的释放：" class="headerlink" title="直接内存的释放："></a>直接内存的释放：</h5><h5 id="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"><a href="#Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。" class="headerlink" title="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"></a>Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。</h5><ol><li>调用DirectByteBuffer类的clear()方法</li><li>freeMemory(long address)：释放指定地址的内存块。</li></ol><p><img src="/./img/6.3.png"></p><h5 id="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"><a href="#由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存" class="headerlink" title="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"></a>由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存</h5><p><strong>–ByteBuffer.allocateDirect(1024*1024)中对Unsafe的调用;</strong></p><p><img src="/./img/6.4.png"></p><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner(虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemor来释放直接内存</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><h4 id="1-部分："><a href="#1-部分：" class="headerlink" title="1.部分："></a>1.部分：</h4><ol><li><h5 id="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"><a href="#堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。" class="headerlink" title="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"></a>堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。</h5></li><li><h5 id="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"><a href="#栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。" class="headerlink" title="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"></a>栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。</h5></li><li><h5 id="方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"><a href="#方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。" class="headerlink" title="方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"></a>方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。</h5></li><li><h5 id="本地方法栈（Native-Stack）：用于存储Native方法的现场数据。"><a href="#本地方法栈（Native-Stack）：用于存储Native方法的现场数据。" class="headerlink" title="本地方法栈（Native Stack）：用于存储Native方法的现场数据。"></a>本地方法栈（Native Stack）：用于存储Native方法的现场数据。</h5></li><li><h5 id="PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。"></a>PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h4><ol><li><h5 id="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"><a href="#堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。" class="headerlink" title="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"></a>堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。</h5></li><li><h5 id="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"><a href="#栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。" class="headerlink" title="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"></a>栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。</h5></li><li><h5 id="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"><a href="#方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。" class="headerlink" title="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"></a>方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。</h5></li><li><h5 id="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"></a>PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="3-区别："><a href="#3-区别：" class="headerlink" title="3.区别："></a>3.区别：</h4><ol><li><h5 id="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"><a href="#栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。" class="headerlink" title="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"></a>栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。</h5></li><li><h5 id="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"><a href="#方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。" class="headerlink" title="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"></a>方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。</h5></li><li><h5 id="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"><a href="#PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。" class="headerlink" title="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"></a>PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本概念</title>
      <link href="/2023/08/30/jvm-ji-ben-gai-nian/"/>
      <url>/2023/08/30/jvm-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="一、什么是-JVM？"><a href="#一、什么是-JVM？" class="headerlink" title="一、什么是 JVM？"></a>一、什么是 JVM？</h2><h4 id="JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。"><a href="#JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。" class="headerlink" title="JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。"></a>JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。</h4><h2 id="二、JVM-的组成"><a href="#二、JVM-的组成" class="headerlink" title="二、JVM 的组成"></a>二、JVM 的组成</h2><p><img src="/./img/jvm1.png"></p><ol><li><h4 id="类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。</h4></li><li><h4 id="运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分："><a href="#运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分：" class="headerlink" title="运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分："></a>运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分：</h4><ul><li><h5 id="方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。"><a href="#方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。" class="headerlink" title="方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。"></a>方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。</h5></li><li><h5 id="堆（Heap）：存储对象实例。"><a href="#堆（Heap）：存储对象实例。" class="headerlink" title="堆（Heap）：存储对象实例。"></a>堆（Heap）：存储对象实例。</h5></li><li><h5 id="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"><a href="#栈（Stack）：存储局部变量、操作数栈、方法返回值等。" class="headerlink" title="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"></a>栈（Stack）：存储局部变量、操作数栈、方法返回值等。</h5></li><li><h5 id="本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。"><a href="#本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。" class="headerlink" title="本地方法栈（Native Method Stack）：存储 JNI 调用信息。"></a>本地方法栈（Native Method Stack）：存储 JNI 调用信息。</h5></li><li><h5 id="PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。"><a href="#PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。" class="headerlink" title="PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。"></a>PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。</h5></li></ul></li><li><h4 id="执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。"><a href="#执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。" class="headerlink" title="执行引擎（Execution Engine）：负责将字节码解释成机器码执行。"></a>执行引擎（Execution Engine）：负责将字节码解释成机器码执行。</h4></li><li><h4 id="本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。"><a href="#本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。" class="headerlink" title="本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。"></a>本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。</h4></li><li><h4 id="JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。"><a href="#JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。" class="headerlink" title="JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。"></a>JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。</h4></li></ol><h2 id="三、JVM-的工作原理"><a href="#三、JVM-的工作原理" class="headerlink" title="三、JVM 的工作原理"></a>三、JVM 的工作原理</h2><h4 id="JVM-的工作原理如下："><a href="#JVM-的工作原理如下：" class="headerlink" title="JVM 的工作原理如下："></a>JVM 的工作原理如下：</h4><p><img src="/./img/jvm2.png"></p><ol><li><h5 id="类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。</h5></li><li><h5 id="执行引擎将字节码解释成机器码执行。"><a href="#执行引擎将字节码解释成机器码执行。" class="headerlink" title="执行引擎将字节码解释成机器码执行。"></a>执行引擎将字节码解释成机器码执行。</h5></li><li><h5 id="在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"><a href="#在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。" class="headerlink" title="在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"></a>在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。</h5></li><li><h5 id="执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"><a href="#执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。" class="headerlink" title="执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"></a>执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。</h5></li><li><h5 id="执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"><a href="#执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。" class="headerlink" title="执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"></a>执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。</h5></li></ol><h2 id="四、JVM-的优化"><a href="#四、JVM-的优化" class="headerlink" title="四、JVM 的优化"></a>四、JVM 的优化</h2><h4 id="1-内存分配优化"><a href="#1-内存分配优化" class="headerlink" title="1.内存分配优化"></a>1.内存分配优化</h4><p>​可以通过调整堆大小、使用对象池等方式优化内存的分配和回收。</p><h4 id="2-垃圾回收优化"><a href="#2-垃圾回收优化" class="headerlink" title="2.垃圾回收优化"></a>2.垃圾回收优化</h4><pre><code> 可以通过选择不同的垃圾回收算法、调整垃圾回收参数等方式优化垃圾回收效率。</code></pre><h4 id="3-即时编译优化"><a href="#3-即时编译优化" class="headerlink" title="3.即时编译优化"></a>3.即时编译优化</h4><p>​可以通过调整 JIT 编译器的参数、选择不同的编译策略等方式优化即时编译效率。</p><h4 id="4-多线程优化"><a href="#4-多线程优化" class="headerlink" title="4.多线程优化"></a>4.多线程优化</h4><p>​可以通过合理地使用多线程技术，提高程序的并发性能。</p><h2 id="五、JVM-的调优工具"><a href="#五、JVM-的调优工具" class="headerlink" title="五、JVM 的调优工具"></a>五、JVM 的调优工具</h2><h4 id="1-jstat"><a href="#1-jstat" class="headerlink" title="1.jstat"></a>1.jstat</h4><p>​用于监控 JVM 运行时数据区的状态。</p><h4 id="2-jmap"><a href="#2-jmap" class="headerlink" title="2.jmap"></a>2.jmap</h4><p>​用于生成堆转储文件，分析堆内存使用情况。</p><h4 id="3-jconsole"><a href="#3-jconsole" class="headerlink" title="3.jconsole"></a>3.jconsole</h4><p>​用于监控 JVM 的运行状态，包括内存、线程、GC 等信息。</p><h4 id="4-VisualVM"><a href="#4-VisualVM" class="headerlink" title="4.VisualVM"></a>4.VisualVM</h4><p>​用于监控和分析 JVM 应用程序的性能，包括内存、线程、GC 等信息。</p><h4 id="5-jprofiler"><a href="#5-jprofiler" class="headerlink" title="5.jprofiler"></a>5.jprofiler</h4><p>​用于分析 JVM 应用程序的性能瓶颈，包括方法调用时间、线程状态、内存分配等信息。</p><h6 id="总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。"><a href="#总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。" class="headerlink" title="总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。"></a>总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。</h6><h2 id="六、JVM、JRE、JDK、JavaSE-和-JavaEE"><a href="#六、JVM、JRE、JDK、JavaSE-和-JavaEE" class="headerlink" title="六、JVM、JRE、JDK、JavaSE 和 JavaEE"></a>六、JVM、JRE、JDK、JavaSE 和 JavaEE</h2><p><img src="/./img/jvm_jre_jdk.png"></p><h4 id="1-JVM（Java-Virtual-Machine）"><a href="#1-JVM（Java-Virtual-Machine）" class="headerlink" title="1.JVM（Java Virtual Machine）"></a>1.JVM（Java Virtual Machine）</h4><h5 id="Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。"><a href="#Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。" class="headerlink" title="Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。"></a>Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。</h5><h4 id="2-JRE（Java-Runtime-Environment）"><a href="#2-JRE（Java-Runtime-Environment）" class="headerlink" title="2.JRE（Java Runtime Environment）"></a>2.JRE（Java Runtime Environment）</h4><h5 id="Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。"><a href="#Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。" class="headerlink" title="Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。"></a>Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。</h5><h4 id="3-JDK（Java-Development-Kit）"><a href="#3-JDK（Java-Development-Kit）" class="headerlink" title="3.JDK（Java Development Kit）"></a>3.JDK（Java Development Kit）</h4><h5 id="Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。"><a href="#Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。" class="headerlink" title="Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。"></a>Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。</h5><h4 id="4-JavaSE（Java-Platform-Standard-Edition）"><a href="#4-JavaSE（Java-Platform-Standard-Edition）" class="headerlink" title="4.JavaSE（Java Platform, Standard Edition）"></a>4.JavaSE（Java Platform, Standard Edition）</h4><h5 id="Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。"><a href="#Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。" class="headerlink" title="Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。"></a>Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。</h5><h4 id="5-JavaEE（Java-Platform-Enterprise-Edition）"><a href="#5-JavaEE（Java-Platform-Enterprise-Edition）" class="headerlink" title="5.JavaEE（Java Platform, Enterprise Edition）"></a>5.JavaEE（Java Platform, Enterprise Edition）</h4><h5 id="Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。"><a href="#Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。" class="headerlink" title="Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。"></a>Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。</h5><h6 id="总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。"><a href="#总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。" class="headerlink" title="总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。"></a>总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。</h6><h3 id="七、常见的-JVM（Java-Virtual-Machine）"><a href="#七、常见的-JVM（Java-Virtual-Machine）" class="headerlink" title="七、常见的 JVM（Java Virtual Machine）"></a>七、常见的 JVM（Java Virtual Machine）</h3><p><img src="/./img/jvm%E5%AE%9E%E7%8E%B0.png"></p><ol><li><h4 id="Oracle-JDK（Java-Development-Kit）："><a href="#Oracle-JDK（Java-Development-Kit）：" class="headerlink" title="Oracle JDK（Java Development Kit）："></a>Oracle JDK（Java Development Kit）：</h4><h5 id="是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="OpenJDK："><a href="#OpenJDK：" class="headerlink" title="OpenJDK："></a>OpenJDK：</h4><h5 id="是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="IBM-JDK："><a href="#IBM-JDK：" class="headerlink" title="IBM JDK："></a>IBM JDK：</h4><h5 id="是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="Azul-Zulu-JDK："><a href="#Azul-Zulu-JDK：" class="headerlink" title="Azul Zulu JDK："></a>Azul Zulu JDK：</h4><h5 id="是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。"><a href="#是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。" class="headerlink" title="是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。"></a>是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。</h5></li><li><h4 id="Amazon-Corretto-JDK："><a href="#Amazon-Corretto-JDK：" class="headerlink" title="Amazon Corretto JDK："></a>Amazon Corretto JDK：</h4><h5 id="是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。"><a href="#是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。" class="headerlink" title="是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。"></a>是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。</h5></li><li><h4 id="AdoptOpenJDK："><a href="#AdoptOpenJDK：" class="headerlink" title="AdoptOpenJDK："></a>AdoptOpenJDK：</h4><h5 id="是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"><a href="#是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。" class="headerlink" title="是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"></a>是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。</h5></li></ol><h6 id="这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。"><a href="#这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。" class="headerlink" title="这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。"></a>这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。</h6>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/30/hello-world/"/>
      <url>/2023/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
