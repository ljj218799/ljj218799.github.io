<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring的设计模式</title>
      <link href="/2023/09/03/spring-de-she-ji-mo-shi/"/>
      <url>/2023/09/03/spring-de-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的设计模式"><a href="#Spring的设计模式" class="headerlink" title="Spring的设计模式"></a>Spring的设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。这样可以<strong>节省资源并保证对象的唯一性</strong>。</p><p>单例模式的好处在于对一些重量级的对象，省略了重复创建对象花费的时间，<strong>减少了系统的开销</strong>，第二点是使用单例可以减少new操作的次数，<strong>减少了GC线程回收内存的压力</strong>。</p><h4 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2.源码分析"></a>1.2.源码分析</h4><p><strong>Spring容器</strong>：Spring容器本身也是一个单例，它在应用程序生命周期内只存在一个实例。</p><p><strong>Bean默认的作用域</strong>:  在Spring中的Bean默认的作用域就是<strong>singleton单例</strong>的。</p><p>对于单例bean的创建方式，主要看DefaultSingletonBeanRegistry 的 getSingleton() 方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleAliasRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">SingletonBeanRegistry</span> <span class="token punctuation">{</span>    <span class="token comment">/** 保存单例Objects的缓存集合ConcurrentHashMap，key：beanName --&gt; value：bean实例 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Bean name must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//检查缓存中是否有实例，如果缓存中有实例，直接返回</span>            <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//省略...</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//通过singletonFactory获取单例</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    newSingleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">//省略...</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newSingleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//返回实例</span>            <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> singletonObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以看出，是通过ConcurrentHashMap的方式，如果在Map中存在则直接返回，如果不存在则创建，并且put进Map集合中，并且整段逻辑是使用同步代码块包住的，所以是线程安全的。</p><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><p>代理模式是一种结构型设计模式，它通过创建一个<strong>代理对象来控制对实际对象的访问</strong>，并在访问前后执行一些附加操作。代理模式可以实现横切关注点的解耦，如事务管理、日志记录等。</p><h4 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2.源码分析"></a>2.2.源码分析</h4><p>Spring  <strong>AOP</strong>实现的关键在于动态代理</p><p>AOP是Spring的一个核心特性(<strong>面向切面编程</strong>)，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，提高系统的可维护性。</p><p>代理对象实现了接口: Spring AOP会使用Java动态代理<strong>JDK Proxy</strong>创建代理对象 完成对象的代理操作 </p><p>代理对象没有实现接口: Spring AOP会使用<strong>Cglib Proxy</strong>生成一个被代理对象的子类作为代理类完成对象代理操作</p><p><img src="/././imgc/33.png"></p><p>我们看DefaultAopProxyFactory的createAopProxy()方法，Spring通过此方法创建动态代理类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否需要进行代理的优化、是否代理目标类而不是接口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token comment">// 以及是否没有用户提供的代理接口</span>            <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 检查目标类是否存在</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span> <span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 检查目标类是否是接口类型或者已经是代理类</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 返回JDK动态代理对象</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 返回CGLIB代理对象</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 返回JDK动态代理对象</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3.工厂模式"></a>3.工厂模式</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><p>工厂模式是一种创建对象的设计模式，它将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象。通过工厂模式，可以实现<strong>解耦</strong>和灵活性，使得客户端代码与具体的对象创建逻辑分离。</p><h4 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2.源码分析"></a>3.2.源码分析</h4><p>Spring中IOC就是控制反转，将对象的控制权转移给Spring，并由Spring创建实例和管理各个实例之间的依赖关系，其中，对象的创建就是通过BeanFactory 和 ApplicationContext 完成的。</p><p><strong>1.BeanFactory</strong> </p><p>BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能(Bean的定义、加载、实例化，依赖注入和生命周期管理)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring中的Bean工厂是一个工厂模式的典型应用。Bean工厂负责创建和管理Bean实例，它将对象的实例化过程封装在工厂类中，通过配置文件或注解来描述Bean的创建逻辑。Bean工厂根据配置信息动态创建对象，并在需要时将对象提供给应用程序。</p><p><strong>2.ApplicationContext</strong> </p><p>ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还扩展了其他更完整功能，对于Bean创建，ApplicationContext在容器启动时，一次性创建了所有的Bean。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">EnvironmentCapable</span><span class="token punctuation">,</span> <span class="token class-name">ListableBeanFactory</span><span class="token punctuation">,</span> <span class="token class-name">HierarchicalBeanFactory</span><span class="token punctuation">,</span><span class="token class-name">MessageSource</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationEventPublisher</span><span class="token punctuation">,</span> <span class="token class-name">ResourcePatternResolver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> <span class="token function">getApplicationName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> <span class="token function">getStartupDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">ApplicationContext</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">AutowireCapableBeanFactory</span> <span class="token function">getAutowireCapableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用上下文是一个高级工厂，它不仅负责创建和管理Bean实例，还提供了其他的应用级服务，如国际化、事件传播、资源管理等。应用上下文可以根据配置信息创建和组装Bean，并提供对它们的访问。</p><h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><p>模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，在父类中定义了算法的结构，而将一些步骤的<strong>具体实现延迟到子类</strong>中。这样可以确保算法的一致性，并允许子类根据需要进行特定实现。</p><h4 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2.源码分析"></a>4.2.源码分析</h4><ul><li><strong>Spring</strong>中以<strong>Template</strong>结尾的类,比如<strong>jdbcTemplate</strong>等,都是使用了模板方法模式。</li></ul><p><img src="/././imgc/32.png"></p><ul><li>Spring中的事务管理器就运用模板模式的设计，首先看PlatformTransactionManager类。这是最底层的接口，定义提交和回滚的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">{</span>    <span class="token class-name">TransactionStatus</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TransactionDefinition</span> definition<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着看AbstractPlatformTransactionManager类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span> <span class="token punctuation">{</span>    <span class="token comment">//省略...</span>    <span class="token class-name">DefaultTransactionStatus</span> defStatus <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span><span class="token punctuation">)</span> status<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defStatus<span class="token punctuation">.</span><span class="token function">isLocalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用processRollback()</span>        <span class="token function">processRollback</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shouldCommitOnGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> defStatus<span class="token punctuation">.</span><span class="token function">isGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用processRollback()</span>        <span class="token function">processRollback</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//调用processCommit()</span>    <span class="token function">processCommit</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//这个方法定义了骨架，里面会调用一个doRollback()的模板方法</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">,</span> <span class="token keyword">boolean</span> unexpected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//调用doRollback()模板方法</span>        <span class="token function">doRollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略了很多代码...</span><span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span> <span class="token punctuation">{</span>    <span class="token comment">//省略...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用doCommit()模板方法</span>        <span class="token function">doCommit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFailEarlyOnGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        unexpectedRollback <span class="token operator">=</span> status<span class="token punctuation">.</span><span class="token function">isGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略了很多代码...</span><span class="token punctuation">}</span> <span class="token comment">//模板方法doRollback()，把重要的步骤延迟到子类去实现</span><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span> <span class="token comment">//模板方法doCommit()，把重要的步骤延迟到子类去实现</span><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把骨架中重要的doRollback()延迟到子类。一般来说，Spring默认是使用的事务管理器的实现类是DataSourceTransactionManager。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//通过继承AbstractPlatformTransactionManager抽象类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceTransactionManager</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractPlatformTransactionManager</span><span class="token keyword">implements</span> <span class="token class-name">ResourceTransactionManager</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>    <span class="token comment">//重写doCommit()方法，实现具体commit的逻辑</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">DataSourceTransactionObject</span> txObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DataSourceTransactionObject</span><span class="token punctuation">)</span> status<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> con <span class="token operator">=</span> txObject<span class="token punctuation">.</span><span class="token function">getConnectionHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Committing JDBC transaction on Connection ["</span> <span class="token operator">+</span> con <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            con<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TransactionSystemException</span><span class="token punctuation">(</span><span class="token string">"Could not commit JDBC transaction"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment">//重写doRollback()方法，实现具体的rollback的逻辑</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">DataSourceTransactionObject</span> txObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DataSourceTransactionObject</span><span class="token punctuation">)</span> status<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Connection</span> con <span class="token operator">=</span> txObject<span class="token punctuation">.</span><span class="token function">getConnectionHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Rolling back JDBC transaction on Connection ["</span> <span class="token operator">+</span> con <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      con<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TransactionSystemException</span><span class="token punctuation">(</span><span class="token string">"Could not roll back JDBC transaction"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-策略模式"><a href="#5-策略模式" class="headerlink" title="5.策略模式"></a>5.策略模式</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1.定义"></a>5.1.定义</h4><p>策略模式是一种行为型设计模式，它定义了一系列的算法，并将<strong>每个算法封装在独立的策略类</strong>中，使得它们可以<strong>相互替换</strong>。通过策略模式，可以在运行时选择不同的策略实现，从而实现灵活的配置和扩展。</p><h4 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2.源码分析"></a>5.2.源码分析</h4><p><strong>AOP切面（Aspect）</strong>：在Spring的AOP（面向切面编程）中，策略模式常常用于定义和应用不同的切面策略。通过定义切面接口和不同的切面实现类，可以根据需要选择不同的切面策略，并将其应用于特定的目标方法中。</p><p><strong>Spring的Resource类</strong>：在Spring的Resource类，针对不同的资源，Spring定义了不同的Resource类的实现类，以此实现不同的访问方式，如下图：</p><p><img src="/././imgc/31.png"></p><ul><li><strong>UrlResource</strong>：访问网络资源的实现类。</li><li><strong>ServletContextResource</strong>：访问相对于 ServletContext 路径里的资源的实现类。</li><li><strong>ByteArrayResource</strong>：访问字节数组资源的实现类。</li><li><strong>PathResource</strong>：访问文件路径资源的实现类。</li><li><strong>ClassPathResource</strong>：访问类加载路径里资源的实现类。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/resource"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">resource</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"type"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> type<span class="token punctuation">,</span>                       <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"arg"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token class-name">Resource</span> resource<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"classpath"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//classpath下的资源</span>        resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//本地文件系统的资源</span>        resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PathResource</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略...</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"fail"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> resource<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//省略...</span>            <span class="token keyword">return</span> <span class="token string">"type:"</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">",arg:"</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>策略模式的思想：通过外部条件使用不同的算法解决问题（每个实现类的getInputStream()方法都不一样）</p><p>ClassPathResource的源码，是通过类加载器加载资源：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassPathResource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFileResolvingResource</span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> path<span class="token punctuation">;</span> <span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">;</span> <span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">InputStream</span> is<span class="token punctuation">;</span>        <span class="token comment">//通过类加载器加载类路径下的资源</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clazz<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>classLoader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>classLoader<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果输入流is为null，则报错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" cannot be opened because it does not exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//返回InputStream</span>        <span class="token keyword">return</span> is<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看UrlResource的源码，获取InputStream的实现又是另一种策略。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UrlResource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFileResolvingResource</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URI</span> uri<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URL</span> url<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URL</span> cleanedUrl<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token comment">//获取连接</span><span class="token class-name">URLConnection</span> con <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ResourceUtils</span><span class="token punctuation">.</span><span class="token function">useCachesIfNecessary</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">//获取输入流，并返回</span><span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Close the HTTP connection (if applicable).</span><span class="token keyword">if</span> <span class="token punctuation">(</span>con <span class="token keyword">instanceof</span> <span class="token class-name">HttpURLConnection</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HttpURLConnection</span><span class="token punctuation">)</span> con<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">throw</span> ex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6.观察者模式"></a>6.观察者模式</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1.定义"></a>6.1.定义</h4><p>观察者模式是一种行为型设计模式，它定义了<strong>一种一对多的依赖关系</strong>，当一个对象的状态发生变化时，它的<strong>所有依赖对象都会收到通知并自动更新</strong>。观察者模式实现了松耦合和对象间的解耦。</p><h4 id="6-2-源码分析"><a href="#6-2-源码分析" class="headerlink" title="6.2.源码分析"></a>6.2.源码分析</h4><p>Spring框架通过<strong>ApplicationEvent</strong>，<strong>ApplicationListener</strong>和<strong>ApplicationEventPublisher</strong>实现了观察者模式。</p><p>对应Spring事件驱动模型包含三种角色: <strong>事件Event角色</strong>， <strong>事件监听者Listener角色</strong>，<strong>事件发布者Publisher角色</strong></p><ol><li><p>事件Event角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7099057708183571937L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">Clock</span> clock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationEvent，这是一个抽象类，抽象类下有四个实现类代表四种事件。</p><ul><li><strong>ContextStartedEvent</strong>：ApplicationContext启动后触发的事件。</li><li><strong>ContextStoppedEvent</strong>：ApplicationContext停止后触发的事件。</li><li><strong>ContextRefreshedEvent</strong>：ApplicationContext初始化或刷新完成后触发的事件。</li><li><strong>ContextClosedEvent</strong>：ApplicationContext关闭后触发的事件。</li></ul></li><li><p>事件监听者Listener角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">E</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PayloadApplicationEvent</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">forPayload</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> consumer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            consumer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>事件发布者Publisher角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventPublisher</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>演示一下:</p><p>首先继承抽象类ApplicationEvent定义一个事件角色PayApplicationEvent。（<strong>写出相应的构造函数</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">PayApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着定义一个PayApplicationEvent事件的监听者PayListener。（<strong>重写onApplicationEvent() 方法</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PayApplicationEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">PayApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"监听到PayApplicationEvent事件，消息为："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们使用ApplicationContext发布事件（<strong>重写publishEvent() 方法发布消息</strong>）</p><p>注：ApplicationEventPublisher接口中的<strong>publishEvent()</strong> 发布事件方法,在AbstractApplicationContext中实现 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringmvcApplication</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringmvcApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PayApplicationEvent</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">,</span><span class="token string">"成功支付100元！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7.适配器模式"></a>7.适配器模式</h3><h4 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1.定义"></a>7.1.定义</h4><p>是一种结构型设计模式，用于<strong>将一个类的接口转换成客户端所期望的另一个接口</strong>。它允许不兼容的接口能够一起工作，将原本不相关的类通过适配器进行<strong>协调和交互</strong>。</p><h4 id="7-2-源码分析"><a href="#7-2-源码分析" class="headerlink" title="7.2.源码分析"></a>7.2.源码分析</h4><p><strong>Spring AOP中的适配器模式：</strong></p><ul><li><p>Spring AOP中的增强和通知Advice使用了适配器模式,接口是AdvisorAdapter</p></li><li><p>常用的Advice类型包括: BeforeAdvice: 前置通知. 目标方法调用前增强 AfterAdvice: 后置通知. 目标方法调用后增强 AfterReturningAdvice: 目标方法执行结束之后 ,return之前</p></li><li><p>每个通知Advice都有对应的拦截器: BeforeAdvice - MethodBeforeAdviceInterceptor AfterAdvice - MethodAfterAdviceInterceptor AfterReturningAdvice - MethodAfterReturningAdviceInterceptor</p></li><li><p>Spring中预定义的通知要通过对应的适配器,适配成为MethodInterceptor接口类型的对象</p></li></ul><p><strong>Spring MVC中的适配器模式：</strong></p><ul><li><p>Spring MVC中 ,DispatchServlet根据请求信息调用HanlderMapping, 解析请求对应的Handler, 解析到对应的Handler后,开始由HandlerAdapter适配器进行处理</p></li><li><p>HandlerAdapter作为期望接口,具体的适配器实现类对具体目标类进行适配 .controller作为需要适配的类</p></li><li><p>通过使用适配器AdapterHandler可以对Spring MVC中众多类型的Controller通过不同的方法对请求进行处理</p></li></ul><p><strong>Spring MVC的适配器模式模拟代码</strong></p><ul><li>controller接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">HttpController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doHttpHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"http..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">SimpleController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSimplerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"simple..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnnotationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"annotation..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HandlerAdapter接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 多种适配器类</span><span class="token keyword">class</span> <span class="token class-name">SimpleHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SimpleController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSimplerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">SimpleController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">HttpHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HttpController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doHttpHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">HttpController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AnnotationController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnnotationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">AnnotationController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DispatchServlet类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispatchServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">&gt;</span></span> handlerAdapters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">DispatchServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AnnotationHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 此处模拟SpringMVC从request取handler的对象，</span>        <span class="token comment">// 适配器可以获取到希望的Controller</span>        <span class="token class-name">HttpController</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 得到对应适配器</span>        <span class="token class-name">HandlerAdapter</span> adapter <span class="token operator">=</span> <span class="token function">getHandler</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 通过适配器执行对应的controller对应方法</span>        adapter<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">HandlerAdapter</span> <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token class-name">Controller</span> controller<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//遍历：根据得到的controller(handler), 返回对应适配器</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HandlerAdapter</span> adapter <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handlerAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>adapter<span class="token punctuation">.</span><span class="token function">supports</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> adapter<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">DispatchServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// http...表示HttpController的处理方法被成功调用。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该示例展示了适配器模式的应用。通过适配器模式，不同类型的Controller可以通过不同的适配器对应到相同的处理方法，实现了统一的处理流程。</p><p>这种设计可以提供灵活性和可扩展性，使得系统可以在不修改现有代码的情况下添加新的Controller类型。</p><h3 id="8-责任链模式"><a href="#8-责任链模式" class="headerlink" title="8.责任链模式"></a>8.责任链模式</h3><h4 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1.定义"></a>8.1.定义</h4><p>责任链模式是一种行为型设计模式，它允许<strong>多个对象按照顺序处理请求</strong>，每个对象都可以选择处理请求或将其传递给下一个对象。</p><p>责任链模式为请求对象创建一个接收者处理链，通常接收者中会存在<strong>下一个接收者的引用</strong>，如果当前接收者无法处理当前请求时，则将请求对象传递到下一个接收者进行处理，从而实现责任链，直到可以处理请求对象为止。</p><h4 id="8-2-源码分析"><a href="#8-2-源码分析" class="headerlink" title="8.2.源码分析"></a>8.2.源码分析</h4><p><strong>Spring Security中的过滤器链（Filter Chain）</strong>：Spring Security使用责任链模式来处理Web请求的安全性。每个过滤器都有特定的功能，如身份验证、授权、会话管理等。这些过滤器按照特定的顺序组成过滤器链，每个过滤器在处理请求时可以选择继续处理或将请求传递给下一个过滤器。</p><p><strong>Spring MVC中的拦截器链（Interceptor Chain）</strong>：Spring MVC使用责任链模式来处理Web请求的拦截和预处理。拦截器按照配置的顺序组成拦截器链，每个拦截器可以在请求处理前后执行特定的操作，如日志记录、权限检查等。每个拦截器可以选择继续处理请求或将请求传递给下一个拦截器。</p><p><strong>Spring中的异常处理链（Exception Handling Chain）</strong>：Spring框架提供了异常处理机制，支持通过配置多个异常处理器来处理不同类型的异常。这些异常处理器按照配置的顺序组成异常处理链，每个处理器可以选择处理异常或将异常传递给下一个处理器。</p><p><strong>SpringSecurity</strong>是基于Spring实现的权限认证与校验的框架，它通过将请求内容交给过滤器链进行处理，通过框架提供的默认filter以及我们定义的filter来对请求进行处理，从而实现web权限的校验,其中的<strong>FilterChainProxy</strong>实际上实现了web中Filter过滤器，也是采用了责任链模式来实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clearContext<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token constant">FILTER_APPLIED</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RequestRejectedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doFilterInternal</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>filters <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//...</span>firewallRequest<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> firewallResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//...</span><span class="token class-name">VirtualFilterChain</span> virtualFilterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualFilterChain</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> filters<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行虚拟调用链virtualFilterChain的doFilter方法</span>virtualFilterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> firewallResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//VirtualFilterChain是FilterChainProxy中一个静态内部类</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">VirtualFilterChain</span> <span class="token keyword">implements</span> <span class="token class-name">FilterChain</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FilterChain</span> originalChain<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">&gt;</span></span> additionalFilters<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FirewalledRequest</span> firewalledRequest<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> currentPosition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">VirtualFilterChain</span><span class="token punctuation">(</span><span class="token class-name">FirewalledRequest</span> firewalledRequest<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">,</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">&gt;</span></span> additionalFilters<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>originalChain <span class="token operator">=</span> chain<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>additionalFilters <span class="token operator">=</span> additionalFilters<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> additionalFilters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>firewalledRequest <span class="token operator">=</span> firewalledRequest<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>                <span class="token comment">// 判断当前位置是否已经到达过滤器链的末尾</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 如果是末尾，直接调用原始的FilterChain的doFilter方法，将请求传递给下一个过滤器或目标Servlet进行处理</span><span class="token keyword">this</span><span class="token punctuation">.</span>firewalledRequest<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>originalChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition<span class="token operator">++</span><span class="token punctuation">;</span><span class="token class-name">Filter</span> nextFilter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>additionalFilters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...</span><span class="token comment">//此处为责任链模式的实现，将请求对象交给一下一个处理方法进行处理</span>nextFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码展示了责任链模式的一种实现方式。通过构建一个责任链，每个过滤器节点都有机会处理请求，并决定是否将请求传递给下一个过滤器</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 基本概念</title>
      <link href="/2023/09/03/spring-ji-ben-gai-nian/"/>
      <url>/2023/09/03/spring-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-基本概念"><a href="#Spring-基本概念" class="headerlink" title="Spring 基本概念"></a>Spring 基本概念</h2><h3 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h3><p><a href="https://spring.io/">https://spring.io/</a></p><p><img src="/././imgc/20.png"></p><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对 </p><p>构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程 模型促进良好的编程习惯</p><h3 id="2-为什么使用Spring框架"><a href="#2-为什么使用Spring框架" class="headerlink" title="2.为什么使用Spring框架"></a>2.为什么使用Spring框架</h3><ol><li><p><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。 </p></li><li><p><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找 </p><p>依赖的对象们。 </p></li><li><p><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 </p></li><li><p><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。 </p></li><li><p><strong>MVC</strong>框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 </p></li><li><p><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务 </p><p>（JTA）。 </p></li><li><p><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛 </p><p>出的）转化为一致的unchecked 异常。</p></li></ol><h4 id="2-1-Spring-IOC（控制反转）"><a href="#2-1-Spring-IOC（控制反转）" class="headerlink" title="2.1.Spring IOC（控制反转）"></a>2.1.Spring IOC（控制反转）</h4><p>Spring IOC，全称控制反转（Inversion of Control）,在传统的 Java 程序开发中，我们只能通过 new 关键字来创建对象， 这种导致程序中对象的依赖关系比较复杂，耦合度较高。 </p><p>而 IOC 的主要作用是实现了对象的管理，也就是我们把设计好的对象交给了 IOC 容器控制， 然后在需要用到目标对象的时候，直接从容器中去获取。</p><p>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入</p><p>描述IOC的常用注解：</p><ul><li><strong>@Component</strong>：可以用于注册所有bean</li><li><strong>@Repository</strong>：主要用于注册dao层的bean</li><li><strong>@Controller</strong>：主要用于注册控制层的bean</li><li><strong>@Service</strong>：主要用于注册服务层的bean</li></ul><h4 id="2-2-Spring-DI-依赖注入"><a href="#2-2-Spring-DI-依赖注入" class="headerlink" title="2.2.Spring DI   (依赖注入)"></a>2.2.Spring DI   (依赖注入)</h4><p>  有了 IOC 容器来管理 Bean 以后，相当于把对象的创建和查找依赖对象的控制权交给了容器，这种设计理念 使得对象与对象之间是一种松耦合状态，极大提升了程序的灵活性以及功能的复用性。 </p><p>然后，DI 表示依赖注入，也就是对于 IOC 容器中管理的 Bean，如果 Bean 之间存在依 赖关系，那么 IOC 容器需要 自动实现依赖对象的实例注入。</p><p>描述依赖关系主要有两种：</p><ul><li><strong>@Resource</strong>：java的注解，默认以<strong>byName</strong>的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用**@Qualifier**注解（spring注解）指定某个具体名称的bean</li><li><strong>@Autowired</strong>：spring注解，默认是以<strong>byType</strong>的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byName的方式去查找</li><li><strong>@Value</strong>: 用于注入属性值，可以从配置文件或其他来源读取值，并将其注入到标注了@Value的字段中。</li></ul><h3 id="3-Spring-Bean"><a href="#3-Spring-Bean" class="headerlink" title="3.Spring Bean"></a>3.Spring Bean</h3><h4 id="3-1-Spring-Bean的定义"><a href="#3-1-Spring-Bean的定义" class="headerlink" title="3.1.Spring Bean的定义"></a>3.1.Spring Bean的定义</h4><p>在 Spring 中，构成应用程序主干并由 <strong>Spring IoC 容器</strong>管理的对象称为 Bean。</p><p>Bean 是一个由 Spring IoC 容器实例化、组装和管理的对象</p><h4 id="3-2-Spring-中-Bean-从哪里来的"><a href="#3-2-Spring-中-Bean-从哪里来的" class="headerlink" title="3.2.Spring 中 Bean 从哪里来的"></a>3.2.<strong>Spring 中 Bean 从哪里来的</strong></h4><p>在 Spring 容器中，除了很多 Spring 内置的 Bean 以外，其他的 Bean 都是我们自己通 过 Spring 配置来声明的，然后，由 Spring 容器统一加载。</p><p>我们在 Spring 声明配置中 通常会配置以下内容，如：<strong>class（全类名）、id（也就是 Bean 的唯一标识）、 scope（作用域）以及 lazy-init（是否延时加载）</strong>等。之后，Spring 容器根据配置内容使用 对应的策略来创建 Bean 的实例。</p><h4 id="3-3-Spring-Bean-存在线程安全问题？"><a href="#3-3-Spring-Bean-存在线程安全问题？" class="headerlink" title="3.3.Spring  Bean 存在线程安全问题？"></a>3.3.<strong>Spring  Bean 存在线程安全问题？</strong></h4><p>回答这个问题之前我们得了解一下 <strong>Spring Bean 的作用域</strong>。</p><p>在 Spring 定义的作用域中，其中有 <strong>prototype（ 多例 Bean ）和 singleton （ 单例 Bean）</strong>。</p><ul><li>prototype 的 Bean，是在每次 getBean 的时候都会创建一个新的对象。</li><li>singleton 的Bean，在 Spring 容器中只会存在一个全局共享的实例。</li></ul><p><strong>因此，多例 Bean 是不存在线程安全问题的。</strong> </p><hr><p>而单例 Bean 就可能会存在线程安全问题。但是单例 Bean 又分为<strong>无状态 Bean 和有状态 Bean</strong>。</p><ul><li>无状态 Bean在多线程操作中只会对 Bean 的成员变量进行查询操作，<strong>不会修改成员变量的值</strong>。</li><li>有状态 Bean在多线程操作中如果需要<strong>对 Bean 中的成员变量进行数据更新操作</strong>。</li></ul><p>因此，无状态的单例 Bean 是不存在线程安全问题的。</p><p>所以，最终我们得出结论，在 Spring 中，只有<strong>有状态的单例 Bean</strong> 才会存在线程安全 </p><p>问题。</p><h4 id="3-4-如何处理-Spring-Bean-的线程安全问题？"><a href="#3-4-如何处理-Spring-Bean-的线程安全问题？" class="headerlink" title="3.4.如何处理 Spring Bean 的线程安全问题？"></a>3.4.<strong>如何处理 Spring Bean 的线程安全问题？</strong></h4><p>处理有状态单例 Bean 的线程安全问题有以下三种方法： </p><ol><li><p><strong>使用原型模式的Bean</strong>：将 Bean 的作用域由 “singleton” 单例 改为 “prototype” 多例。 </p></li><li><p><strong>单例模式的Bean设计为无状态</strong>：在 Bean 对象中避免定义可变的成员变量，当然，这样做不太现实。 </p></li><li><p><strong>使用Spring提供的注解和配置支持</strong>：Spring框架提供了一些注解和配置支持来处理线程安全问题。例如：</p><p>使用**@Scope(“request”)<strong>注解将Bean的作用域限定为每个请求，这样每个线程都会有一个独立的Bean实例。使用</strong>@Async**注解将方法标记为异步执行，Spring会为每个方法调用创建一个新的线程。</p></li><li><p><strong>在类中定义 ThreadLocal 的成员变量，并将需要的可变成员变量保存在 ThreadLocal 中</strong>：ThreadLocal 本身就具备线程隔离的特性，这就相当于为每个线 程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线 程安全问题</p></li></ol><h3 id="4-Spring-Bean-生命周期"><a href="#4-Spring-Bean-生命周期" class="headerlink" title="4.Spring Bean 生命周期"></a>4.<strong>Spring Bean 生命周期</strong></h3><h4 id="4-1-创建前准备阶段"><a href="#4-1-创建前准备阶段" class="headerlink" title="4.1.创建前准备阶段"></a>4.1.创建前准备阶段</h4><p><img src="/././imgc/22.png"></p><p>这个阶段主要的作用是，Bean 在开始加载之前，需要从上下文和相关配置中解析并查找 Bean 有关的扩展实现</p><p>比如像<code>init-method</code>-容器在初始化 bean 时调用的方法、<code>destory-method</code>，容器在 </p><p>销毁 bean 时调用的方法。 </p><p>以及，BeanFactoryPostProcessor 这类的 bean 加载过程中的前置和后置处理。</p><h4 id="4-2-创建实例阶段"><a href="#4-2-创建实例阶段" class="headerlink" title="4.2.创建实例阶段"></a>4.2.创建实例阶段</h4><p><img src="/././imgc/23.png"></p><p>这个阶段主要是通过反射来创建Bean的实际对象，并且扫描和解析Bean的声明的一些属性。‍</p><h4 id="4-3-依赖注入阶段"><a href="#4-3-依赖注入阶段" class="headerlink" title="4.3.依赖注入阶段"></a>4.3.依赖注入阶段</h4><p><img src="/././imgc/24.png"></p><p>如果被实例化的 Bean 存在依赖其他 Bean 对象的情况，则需要对这些依赖 bean 进行对象注入。比如常见的**@Autowired、setter 注入**等依赖注入的配置形式。 </p><p>同时，在这个阶段会触发一些扩展的调用，比如常见的扩展类：</p><ul><li>BeanPostProcessors (用来实现 bean 初始化前后的扩展回调) </li><li>InitializingBean（这个类有一个 afterPropertiesSet()，这个在工作中也比较常见）</li><li>BeanFactoryAware 等等。</li></ul><h4 id="4-4-容器缓存阶段"><a href="#4-4-容器缓存阶段" class="headerlink" title="4.4.容器缓存阶段"></a>4.4.容器缓存阶段</h4><p><img src="/././imgc/25.png"></p><p>容器缓存阶段主要是把 bean 保存到容器以及 Spring 的缓存中，到了这个阶段，Bean就可以被开发者使用了。 </p><p>这个阶段涉及到的操作，常见的有，<code>init-method</code>这个属性配置的方法， 会在这个阶段调用。 </p><p>以及像 BeanPostProcessors 方法中的后置处理器方法如： </p><p>postProcessAfterInitialization，也会在这个阶段触发。</p><h4 id="4-5-销毁实例阶段"><a href="#4-5-销毁实例阶段" class="headerlink" title="4.5.销毁实例阶段"></a>4.5.销毁实例阶段</h4><p><img src="/././imgc/26.png"></p><p>当 Spring 应用上下文关闭时，该上下文中的所有 bean 都会被销毁。 </p><p>如果存在 Bean 实现了 DisposableBean 接口，或者配置了<code>destory-method</code>属性，会 </p><p>在这个阶段被调用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件属性内容</title>
      <link href="/2023/09/01/linux-wen-jian-shu-xing-nei-rong/"/>
      <url>/2023/09/01/linux-wen-jian-shu-xing-nei-rong/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-文件属性内容"><a href="#Linux-文件属性内容" class="headerlink" title="Linux 文件属性内容"></a>Linux 文件属性内容</h2><h4 id="1-文件属性"><a href="#1-文件属性" class="headerlink" title="1.文件属性"></a>1.文件属性</h4><h5 id="1-文件属性查看"><a href="#1-文件属性查看" class="headerlink" title="1.文件属性查看"></a>1.文件属性查看</h5><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组</p><p>如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用 ls -l查看文件权限</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls -l</span>total <span class="token number">20</span>drwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:29 java_homedrwx------ <span class="token number">2</span> redis redis <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:45 redisdrwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:05 test1drwx--x--x <span class="token number">2</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:14 test2drwx------ <span class="token number">2</span> www   www   <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">14</span>:08 www<span class="token comment">#解析test2的第一列   drwx--x--x </span><span class="token comment">#第一个字符表示文件类型：</span>d 表示目录   （- 表示普通文件，l 表示符号链接等<span class="token punctuation">..</span>.）rwx--x--x    （rwx：读，写，执行；--x：执行；--x：执行<span class="token comment">#其他列</span><span class="token number">1</span>. 第二列是与文件或目录相关联的硬链接数。<span class="token number">2</span>. 第三列是文件或目录的所有者用户名。<span class="token number">3</span>. 第四列是文件或目录的所属组名。<span class="token number">4</span>. 第五列是文件或目录的大小（以字节为单位）。<span class="token number">5</span>. 第六列是最后修改时间。<span class="token number">6</span>. 第七列是文件或目录的名称。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-文件属性修改"><a href="#2-文件属性修改" class="headerlink" title="2.文件属性修改"></a>2.文件属性修改</h5><p>1.chgrp：更改文件属组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chgrp</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p>2.chown：更改文件属主，也可以同时更改文件属组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>–R<span class="token punctuation">]</span> 属主名 文件名<span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 属主名：属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3.chmod：更改文件9个属性</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> xyz 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#示例</span><span class="token function">chmod</span> <span class="token number">770</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>770这三位数分别代表所有者、所属组的用户、其他用户；<br>数字 7 转换为二进制是 111，即读（r）、写（w）和执行（x）<br>数字 4 转换为二进制是 111，即读（r）、写（w）和执行（x）<br>数字 1 转换为二进制是 000，无权限</p><h4 id="2-文件内容"><a href="#2-文件内容" class="headerlink" title="2.文件内容"></a>2.文件内容</h4><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h5 id="1-cat-由第一行开始显示文件内容"><a href="#1-cat-由第一行开始显示文件内容" class="headerlink" title="1.cat (由第一行开始显示文件内容)"></a>1.cat (由第一行开始显示文件内容)</h5><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhcp<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto<span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet<span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-tac-从最后一行开始显示"><a href="#2-tac-从最后一行开始显示" class="headerlink" title="2.tac(从最后一行开始显示)"></a>2.tac(从最后一行开始显示)</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet<span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-nl-显示行号"><a href="#3-nl-显示行号" class="headerlink" title="3.nl  显示行号"></a>3.nl  显示行号</h5><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span>     <span class="token number">1</span><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhcp     <span class="token number">2</span><span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0     <span class="token number">3</span><span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes     <span class="token number">4</span><span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto     <span class="token number">5</span><span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet     <span class="token number">6</span><span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Vim使用</title>
      <link href="/2023/09/01/linux-vim-mo-shi/"/>
      <url>/2023/09/01/linux-vim-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-Vim使用"><a href="#Linux-Vim使用" class="headerlink" title="Linux Vim使用"></a>Linux Vim使用</h2><h4 id="1-vim简介"><a href="#1-vim简介" class="headerlink" title="1.vim简介"></a>1.vim简介</h4><ul><li>Vim是从 vi 发展出来的一个文本编辑器</li><li>代码补完、编译及错误跳转等方便编程的功能特别丰富</li></ul><p><img src="/././imgc/2.png"></p><h4 id="2-模式"><a href="#2-模式" class="headerlink" title="2.模式"></a>2.模式</h4><p>vim 共分为三种模式，分别是<strong>命令模式</strong>，<strong>输入模式</strong>和<strong>底线命令模式</strong></p><h5 id="1-命令模式："><a href="#1-命令模式：" class="headerlink" title="1.命令模式："></a><strong>1.命令模式：</strong></h5><p>使用 vi/vim，便进入了命令模式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>a.txt  java_home  redis  www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># vi a.txt </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们此时按下i，并不会输入一个字符，i被当作了一个命令j进入输入模式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                                                                                                    ~                                                                                                        ~                                                                                                        -- INSERT --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><h5 id="2-输入模式："><a href="#2-输入模式：" class="headerlink" title="2.输入模式："></a><strong>2.输入模式：</strong></h5><p>在命令模式下按下i就进入了输入模式。输入helloword</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helloword                                                                                                      ~                                                                                                        ~                                                                                                        -- INSERT --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h5 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3.底线命令模式"></a><strong>3.底线命令模式</strong></h5><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>ESC退出输入模式，:就进入了底线命令模式wq保存并退出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helloword                          ~                                                                                                        ~                                                                                                        :wq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>查看a.txt</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cat a.txt </span>helloword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/././imgc/3.png"></p><h4 id="3-其他指令"><a href="#3-其他指令" class="headerlink" title="3.其他指令"></a>3.其他指令</h4><h5 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式"></a>1.命令模式</h5><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页</td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页</td></tr><tr><td>0 或功能键[Home]</td><td>移动到这一行的最前面字符处</td></tr><tr><td>$ 或功能键[End]</td><td>移动到这一行的最后面字符处</td></tr><tr><td>gg</td><td>移动到这个档案的第一行</td></tr><tr><td>G</td><td>移动到这个档案的最后一行</td></tr><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串</td></tr><tr><td>dd，yy</td><td>删除，复制游标所在的那一整行</td></tr><tr><td>u，[Ctrl]+r</td><td>复原，重做前一个动作</td></tr></tbody></table><h5 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2.输入模式"></a>2.输入模式</h5><table><thead><tr><th><strong>i, I</strong></th><th>i 为『从光标处输入』， I 为『所在行的第一个非空格符处开始输入』</th></tr></thead><tbody><tr><td>a,A</td><td>a 为『光标的下一个字符处开始输入』， A 为『从光标的最后一个字符处开始输入』</td></tr><tr><td>o,O</td><td>o 为『光标下一行处输入新的一行』；O 为光标上一行输入新的一行</td></tr><tr><td>r,R</td><td>r 只会取代光标那一个字符一次；R会一直取代，直到按下 ESC 为止</td></tr><tr><td>[Esc]</td><td>退出编辑模式，回到一般模式中</td></tr></tbody></table><h5 id="3-底线命令模式-1"><a href="#3-底线命令模式-1" class="headerlink" title="3.底线命令模式"></a><strong>3.底线命令模式</strong></h5><table><thead><tr><th>:w</th><th>将编辑的数据写入硬盘档案中</th></tr></thead><tbody><tr><td>:w!</td><td>若文件属性为『只读』时，强制写入该档案。</td></tr><tr><td>:q</td><td>离开 vi</td></tr><tr><td>:wq</td><td>储存后离开,若为 :wq! 则为强制储存后离开</td></tr><tr><td>ZZ</td><td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>取消行号</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/09/01/linux-chang-jian-zhi-ling/"/>
      <url>/2023/09/01/linux-chang-jian-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1-linux-常用命令"><a href="#1-linux-常用命令" class="headerlink" title="1.linux 常用命令"></a>1.linux 常用命令</h2><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法。</p><h4 id="1-目录的常用命令"><a href="#1-目录的常用命令" class="headerlink" title="1.目录的常用命令"></a>1.目录的常用命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls: 列出目录cd：切换目录pwd：显示目前的目录mkdir：创建一个新的目录rmdir：删除一个空的目录cp: 复制文件或目录rm: 移除文件或目录mv: 移动文件与目录，或修改文件与目录的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-ls选项："><a href="#1-ls选项：" class="headerlink" title="1.ls选项："></a>1.ls选项：</h5><p>选项与参数</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><pre class="line-numbers language-none"><code class="language-none">[root@www ~]# ls -al ~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-cd选项："><a href="#2-cd选项：" class="headerlink" title="2.cd选项："></a>2.cd选项：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token comment"># 回到根目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd / </span><span class="token comment"># 回到上一级</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd .. </span><span class="token comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd ~</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin   dev  home  lib64     media  opt    proc  run   srv  tmp  varboot  etc  lib lost+found  mnt    patch  root  sbin  sys  usr  www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-pwd-选项："><a href="#3-pwd-选项：" class="headerlink" title="3.pwd 选项："></a>3.pwd 选项：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 单纯显示出目前的工作目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd ~</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># pwd</span>/root<span class="token comment"># 如果是链接，要显示真实地址，可以使用 -P参数</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ bin<span class="token punctuation">]</span><span class="token comment"># pwd -P</span>/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-mkdir-（创建新目录）"><a href="#4-mkdir-（创建新目录）" class="headerlink" title="4.mkdir （创建新目录）"></a>4.mkdir （创建新目录）</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-mp<span class="token punctuation">]</span> 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#进入home 创建一个 test 文件夹</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  <span class="token builtin class-name">test</span>www<span class="token comment">#如需 创建多级目录 加这个 -p 的选项</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir -p  test1/test2/test3</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  test1  www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd test1</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test1<span class="token punctuation">]</span><span class="token comment"># ls</span>test2<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test1<span class="token punctuation">]</span><span class="token comment"># cd test2</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test2<span class="token punctuation">]</span><span class="token comment"># ls</span>test3<span class="token comment">#如需指定目录的权限 加-m 表示</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir -m 711 test2</span><span class="token comment">#711表示目录的权限，具体含义如下：</span><span class="token number">711</span>这三位数分别代表所有者、所属组的用户、其他用户；数字 <span class="token number">7</span> 转换为二进制是 <span class="token number">111</span>，即读（r）、写（w）和执行（x）数字 <span class="token number">4</span> 转换为二进制是 011，即只有写和执行权限数字 <span class="token number">1</span> 转换为二进制是 001，即只有执行权限<span class="token comment">#使用 ls -l查看文件权限</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls -l</span>total <span class="token number">20</span>drwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:29 java_homedrwx------ <span class="token number">2</span> redis redis <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:45 redisdrwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:05 test1drwx--x--x <span class="token number">2</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:14 test2drwx------ <span class="token number">2</span> www   www   <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">14</span>:08 www<span class="token comment">#解析test2的第一列   drwx--x--x </span><span class="token comment">#第一个字符表示文件类型：</span>d 表示目录   （- 表示普通文件，l 表示符号链接等<span class="token punctuation">..</span>.）rwx--x--x    （rwx：读，写，执行；--x：执行；--x：执行）与创建是所设置的一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-rmdir-删除空的目录"><a href="#5-rmdir-删除空的目录" class="headerlink" title="5.rmdir ( 删除空的目录 )"></a>5.rmdir ( 删除空的目录 )</h5><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rmdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#删除刚刚创建test2目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rmdir test2 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-p ：连同上一级『空的』目录也一起删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rmdir -p test1/test2/test3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="注意：这个-rmdir-仅能删除空的目录，你可以使用-rm-命令来删除非空目录"><a href="#注意：这个-rmdir-仅能删除空的目录，你可以使用-rm-命令来删除非空目录" class="headerlink" title="注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录"></a><strong>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录</strong></h6><h5 id="6-cp-复制文件或目录"><a href="#6-cp-复制文件或目录" class="headerlink" title="6.cp ( 复制文件或目录 )"></a>6.cp ( 复制文件或目录 )</h5><p>语法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 来源档<span class="token punctuation">(</span>source<span class="token punctuation">)</span> 目标档<span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 找一个有文件的目录，我这里找到 root目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd /root</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token comment"># 复制 root目录下的install.sh 到 home目录下</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp /root/install.sh /home</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token comment"># 再次复制，加上-i参数，增加覆盖询问？</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp -i /root/install.sh /home</span>cp: overwrite ‘/home/install.sh’? y <span class="token comment"># n不覆盖，y为覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-rm-移除文件或目录"><a href="#7-rm-移除文件或目录" class="headerlink" title="7.rm ( 移除文件或目录 )"></a>7.rm ( 移除文件或目录 )</h5><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>-fir<span class="token punctuation">]</span> 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rm -i install.sh</span>rm: remove regular <span class="token function">file</span> ‘install.sh’? y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="8-mv-移动文件与目录，或修改名称"><a href="#8-mv-移动文件与目录，或修改名称" class="headerlink" title="8.mv  ( 移动文件与目录，或修改名称 )"></a>8.mv  ( 移动文件与目录，或修改名称 )</h5><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#复制一个文件到当前目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp /root/install.sh /home</span><span class="token comment"># 创建一个文件夹 test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir test</span><span class="token comment"># 将复制过来的文件移动到我们创建的目录，并查看</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mv install.sh test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  <span class="token builtin class-name">test</span>www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token comment"># 将文件夹重命名，然后再次查看！</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test<span class="token punctuation">]</span><span class="token comment"># cd ..</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mv test mvtest</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  mvtest  redis  www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux概述</title>
      <link href="/2023/09/01/linux-gai-shu/"/>
      <url>/2023/09/01/linux-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Linux简介"><a href="#1-Linux简介" class="headerlink" title="1.Linux简介"></a>1.Linux简介</h2><ol><li><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p></li><li><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p></li><li><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统</p><p>在服务器端，在开发领域linux倒是越来越受欢迎，linux在开源社区的地位依然岿然不动。</p><p>尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p></li></ol><h2 id="2-Linux发行版"><a href="#2-Linux发行版" class="headerlink" title="2.Linux发行版"></a>2.Linux发行版</h2><p><img src="/././imgc/1.png"></p><p>目前市面上较知名的发行版有：<strong>Ubuntu</strong>、RedHat、<strong>CentOS</strong>、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><h2 id="3-linux-环境搭建"><a href="#3-linux-环境搭建" class="headerlink" title="3.linux 环境搭建"></a>3.linux 环境搭建</h2><h4 id="1-虚拟机安装"><a href="#1-虚拟机安装" class="headerlink" title="1.虚拟机安装"></a>1.虚拟机安装</h4><p>1、可以通过镜像进行安装</p><p>2、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！</p><h4 id="2-购买云服务器（推荐）"><a href="#2-购买云服务器（推荐）" class="headerlink" title="2.购买云服务器（推荐）"></a>2.购买云服务器（推荐）</h4><p>虚拟机安装后占用空间，也会有些卡顿,选择购买一台自己的服务器，这样的话更加接近真实线上工作.</p><p>1.阿里云购买服务器：<a href="https://www.aliyun.com/">https://www.aliyun.com</a></p><p>2.购买完毕后，获取服务器的ip地址</p><p>3.下载远程连接工具（Xshell,FinalShell等），进行远程连接使用</p><p>4.进行文件下载会比较慢，推荐安装Xftp 配合Xshell（可视化且方便传输）</p><p><a href="https://www.xshell.com/zh/free-for-home-school/">家庭/学校免费 - NetSarang Website (xshell.com)</a>(可授权免费安装)</p><h2 id="4-走近Linux系统"><a href="#4-走近Linux系统" class="headerlink" title="4.走近Linux系统"></a>4.走近Linux系统</h2><h4 id="1-开机"><a href="#1-开机" class="headerlink" title="1.开机"></a>1.开机</h4><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）.</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><h4 id="2-关机"><a href="#2-关机" class="headerlink" title="2.关机"></a>2.关机</h4><p>关机指令为：shutdown .</p><p>拓展操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sync</span> <span class="token comment"># 将数据由内存同步到硬盘中。</span><span class="token function">shutdown</span> <span class="token comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><span class="token function">shutdown</span> –h <span class="token number">10</span> <span class="token comment"># 这个命令告诉大家，计算机将在10分钟后关机</span><span class="token function">shutdown</span> –h now <span class="token comment"># 立马关机</span><span class="token function">shutdown</span> –h <span class="token number">20</span>:25 <span class="token comment"># 系统会在今天20:25关机</span><span class="token function">shutdown</span> –h +10 <span class="token comment"># 十分钟后关机</span><span class="token function">shutdown</span> –r now <span class="token comment"># 系统立马重启</span><span class="token function">shutdown</span> –r +10 <span class="token comment"># 系统十分钟后重启</span><span class="token function">reboot</span> <span class="token comment"># 就是重启，等同于 shutdown –r now</span><span class="token function">halt</span> <span class="token comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h4><p>登录系统后，在当前命令窗口下输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="/2023/08/30/c-mian-xiang-dui-xiang/"/>
      <url>/2023/08/30/c-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><p>public 共有成员<br>谁都可以访问(使用/调用)<br>protected保护成员<br>只有自己和子类可以访问<br>private 私有成员<br>只有自己（类内部）可以访问<br>成员访问<br>访问限定符仅作用于类，因此同一个类的不同对象，可以相互访问非共有部分。<br>类和结构体区别<br>在C++中，类和结构没有本质区别，唯一不同在于<br>类的默认访问控制属性为private<br>结构的默认访问控制属性为public<br>封装<br>对不同成员的控制访问属性加以区分，体现了C++作为面向对象语言的封装特性</p><h3 id="在栈中创建对象"><a href="#在栈中创建对象" class="headerlink" title="在栈中创建对象"></a>在栈中创建对象</h3><p>在栈中创建一个对象<br>格式: 类名 对象名<br>People people;<br>在栈中创建多个对象<br>类名 对象数组名[元素个数]</p><h3 id="在堆中创建对象"><a href="#在堆中创建对象" class="headerlink" title="在堆中创建对象"></a>在堆中创建对象</h3><p>在堆中创建单个对象</p><p>类名 *指针名 = new 类名<br>People *sirius = new People;<br>在堆中创建多个对象<br>类名 *对象数组指针名 = new 类名[元素个数]<br><img src="/././imgc/1686015643781.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class dog{public:    void eat()    {        cout &lt;&lt; "吃饭";    }    void run()    {        cout &lt;&lt; "跑步";    }    void sleep()    {        cout &lt;&lt; "睡觉";    }private:    string name, kind, color;    int age;};int main(){    // 堆区创建对象    cout &lt;&lt; "我是堆区的对象" &lt;&lt; endl;    dog *dui = new dog();    dui-&gt;eat();    dui-&gt;run();    dui-&gt;sleep();    cout &lt;&lt; endl;    // 栈区创建对象    dog zhan;    cout &lt;&lt; "我是栈区的对象" &lt;&lt; endl;    zhan.eat();    zhan.run();    zhan.sleep();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是堆区的对象<br>吃饭跑步睡觉<br>我是栈区的对象<br>吃饭跑步睡觉</p><p><img src="/././imgc/1686015729660.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{  private:    int sno,        grade;};int main(){    // 指针数组的方式创建对象    student *p[4];    for (int i = 0; i &lt; 4; i++)    {        p[i] = new student; // 让数组中的每一个指针指向一个对象    }    cout &lt;&lt; sizeof(p) &lt;&lt; endl;    // 一次性创建4个对象    student *q = new student[4];    cout &lt;&lt; sizeof(q);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>32<br>8</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p>构造函数为什么要放在public<br>在外部实例化对象时自动调用构造函数，如果是其他访问方式，没办法调用构造函数，也就不能实例化对象</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><h3 id="参数初始化表"><a href="#参数初始化表" class="headerlink" title="参数初始化表"></a>参数初始化表</h3><p>注意，参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。<br>如果用户没有定义，编译器会自动生成一个默认的析构函数。这个析构函数的函数体是空的，也没有形参，也不执行任何操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{public:    student(int a, int b) : sno(a), grade(b)    {        cout &lt;&lt; "我是构造有参数" &lt;&lt; endl;    };    student()    {        cout &lt;&lt; "我是构造无参数" &lt;&lt; endl;    };    ~student() // 不能被重载    {        cout &lt;&lt; "我是析构" &lt;&lt; endl;    }private:    int sno,        grade;};int main(){    student *p = new student(3, 4);    student *q = new student[4];    delete p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造有参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是析构</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p><h3 id="类中const成员"><a href="#类中const成员" class="headerlink" title="类中const成员"></a>类中const成员</h3><ol><li>const成员变量<br>必须使用初始化参数列表，初始化后不能修改</li><li>const成员函数<br>const成员函数不能修改基本成员变量。不能调用非const成员函数</li><li>const对象<br>对象中的数据成员不允许被改变。<br>常对象只能调用常成员函数</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    const int a;//常数据成员    int b;    void fun() const//常成员函数    {        cout &lt;&lt; "我是常成员函数";    }     Test(int c) : a(c) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;a &lt;&lt; this-&gt;b &lt;&lt; endl; }};int main(){    const Test p1(2);//常对象    p1.fun();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造函数20<br>我是常成员函数</p><h3 id="拷贝构造函数（复制构造函数）"><a href="#拷贝构造函数（复制构造函数）" class="headerlink" title="拷贝构造函数（复制构造函数）"></a>拷贝构造函数（复制构造函数）</h3><p><img src="/././imgc/1686376068957.png"></p><p>同构造函数一样，如果用户不提供拷贝构造函数，编译器提供默认拷贝构造函数。<br><strong>注意：因为拷贝构造函数属于构造函数，有的编译器会在用户提供构造函数的时候也不再提供拷贝构造。</strong></p><h4 id="浅拷贝（复制地址）"><a href="#浅拷贝（复制地址）" class="headerlink" title="浅拷贝（复制地址）"></a>浅拷贝（复制地址）</h4><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，<strong>当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。</strong></p><p><img src="/././imgc/1686397072070.png"></p><h4 id="深拷贝（复制内存）"><a href="#深拷贝（复制内存）" class="headerlink" title="深拷贝（复制内存）"></a>深拷贝（复制内存）</h4><p>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的。<strong>拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</strong></p><p><img src="/././imgc/1686397184821.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    int a;    char *name;    Test(int c, char *name) : a(c), name(name) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;name &lt;&lt; endl; }    Test(const Test &amp;TestA) { cout &lt;&lt; "我是拷贝构造函数" &lt;&lt; TestA.name &lt;&lt; endl; }    ~Test() { cout &lt;&lt; "我是析构" &lt;&lt; endl; }};int main(){    Test *p1 = new Test(2, "张三");    Test *p2 = new Test(*p1); // 拷贝构造函数Test(const Test &amp;);    delete p1;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>我是构造函数张三<br>我是拷贝构造函数张三<br>我是析构</p><h3 id="类static成员"><a href="#类static成员" class="headerlink" title="类static成员"></a>类static成员</h3><ul><li>静态成员在类的所有对象中是公有的</li><li>内存是程序运行时分配</li><li>使用前必须初始化且只能初始化一次</li><li>初始化不能在类定义中，通过作用域限定符初始化</li><li>优点<br>static成员的名字是在类的作用域中，因此可以<strong>避免与其它类成员或全局对象名字冲突。</strong><br>可以实施封装，<strong>static成员可以是私有的，而全局对象不可以。</strong><br>阅读程序容易看出static成员与某个类相关联，这种<strong>可见性可以清晰地反映程序员的意图</strong></li></ul><p>类型 类名 :: 变量名=值；</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><ul><li>不再属于对象，不需要通过对象访问</li><li><strong>static成员函数没有this指针</strong>，所以静态成员函数不可以访问非静态成员。只能访问静态成员（静态成员和静态变量）</li><li>非静态成员函数可以访问静态成员</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span>class Test<span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Test<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> Test<span class="token operator">::</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单例模式-待"><a href="#单例模式-待" class="headerlink" title="单例模式(待)"></a>单例模式(待)</h3><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，<strong>但是友元函数并不是成员函数。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    friend void fun(const Test &amp;a);    Test(int a) : b(a) {}private:    int b;};void fun(const Test &amp;a){    cout &lt;&lt; a.b &lt;&lt; "我是友元函数" &lt;&lt; endl;}int main(){    Test a(2);    fun(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2我是友元函数</p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p><p><strong>只有友元可以访问，其他依然不能访问</strong>。若类B是类A的友元。则只有类B的成员函数可以访问类A中的隐藏信息</p><p><strong>友元是单向的，不具有交换性</strong>。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p><p><strong>友元关系不具有传递性</strong>。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言进阶篇</title>
      <link href="/2023/08/30/c-yu-yan-jin-jie-pian/"/>
      <url>/2023/08/30/c-yu-yan-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言进阶篇"><a href="#C语言进阶篇" class="headerlink" title="C语言进阶篇"></a>C语言进阶篇</h1><p>本文是对</p><p>文章进行的学习总结</p><h2 id="结构体的介绍"><a href="#结构体的介绍" class="headerlink" title="结构体的介绍"></a>结构体的介绍</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><h4 id="第一种直接struct-加结构体名定义"><a href="#第一种直接struct-加结构体名定义" class="headerlink" title="第一种直接struct 加结构体名定义"></a>第一种直接struct 加结构体名定义</h4><p>struct  结构体名</p><p>{ </p><p>类型 属性名；</p><p>类型 属性名；</p><p>….</p><p>类型 属性名；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token comment">//student为结构体名</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//结构的属性</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">;</span><span class="token comment">//a为结构体变量一种定义变量的方式1</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//struct student a;//这也是一种定义变量的方式2</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为10a。</p><h4 id="第二种利用typedef-struct-结构体名定义结构体"><a href="#第二种利用typedef-struct-结构体名定义结构体" class="headerlink" title="第二种利用typedef struct 结构体名定义结构体"></a>第二种利用typedef struct 结构体名定义结构体</h4><p>typedef struct 结构体名{</p><p>类型 属性名；</p><p>类型 属性名；</p><p>…</p><p>类型 属性名；</p><p>}m;<em>//struct student 是数据类型，typedef 数据类型 p，p就是（struct student）只是重新修改了而已</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> m<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    m a<span class="token punctuation">;</span><span class="token comment">//定义结构体变量名a</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a。</p><h4 id="第三种嵌套定义结构体"><a href="#第三种嵌套定义结构体" class="headerlink" title="第三种嵌套定义结构体"></a>第三种嵌套定义结构体</h4><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>属性名：属性值；</p><p>}</p><p>属性名：属性值；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">teacher</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> b<span class="token punctuation">;</span>     <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a</p><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>定义格式和一般定义结构差不多，只是变量名为数组。每一个数组都有结构体的属性。但属性值要分别定义。以下用循环定义每一个结构体数组的属性值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结构为</p><p>10a</p><p>10a。</p><h4 id="计算结构体所占用的内存"><a href="#计算结构体所占用的内存" class="headerlink" title="计算结构体所占用的内存"></a>计算结构体所占用的内存</h4><p>结构体的内存存储讲究对齐法则。<strong>所有属性所占的内存向占最大内存的那个属性对齐</strong>，例如计算以下结构体所占内存，char类型占1个字节，而int类型占4个字节，所以char类型向int类型对齐，则以下结构体所占内存为8。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为8。</p><p><img src="/././imgc/1685427766651.png"></p><p>以上为student结构体在内存的情况，0-3为整型类型num的存储空间，4-7为char类型sex的存储空间。</p><h2 id="共用体的简单介绍"><a href="#共用体的简单介绍" class="headerlink" title="共用体的简单介绍"></a>共用体的简单介绍</h2><p>上述结构体所占内存可见非常废内存，char类型占用1个字节就占一个字节，为什么占用4个字节，所以共用体就比较节约内存了。<strong>共用体内存看所占内存最大的那个类型。其他类型共用它的内存。</strong></p><p>共用体的定义和结构体的定义差不多，结构体定义所用的关键字为struct，共用体的定义所用关键字为union。所以以下仅对共用体所占内存进行描述。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">union</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> uni<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>uni <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>uni<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的结果为</p><p>a</p><p>a</p><p>1。</p><p><img src="/././imgc/1685428496266.png" alt="1685428496266"></p><p>以上为共用体的占用内存情况，uni和sex，因为uni和sex都仅占一个内存，所以赋值进行的覆盖，先赋值b，如何赋值a，但共用一个内存，所以a覆盖了b。</p><h2 id="枚举的介绍"><a href="#枚举的介绍" class="headerlink" title="枚举的介绍"></a>枚举的介绍</h2><p>之前介绍了结构体和共用体，结构体的关键字为struct，共用体的关键字为union，而枚举定义的关键字为enum。枚举类型简化了#define定义多个值的操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">,</span>    c<span class="token punctuation">,</span>    d<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//week为枚举名，p为枚举变量</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为0123。可以认为枚举中的变量值从0开始赋值。</p><h4 id="枚举的简单应用"><a href="#枚举的简单应用" class="headerlink" title="枚举的简单应用"></a>枚举的简单应用</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token comment">//枚举名</span><span class="token punctuation">{</span>    first<span class="token punctuation">,</span>    two<span class="token punctuation">,</span>    three<span class="token punctuation">,</span>    four<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//枚举的变量名p</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span>k<span class="token punctuation">;</span><span class="token comment">//对枚举变量进行赋值的变量也要是枚举类型，所以这里要进行强制类型转换</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">case</span> first<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> two<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> three<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> four<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为first。可以认为枚举变量中存储了</p><h4 id="枚举所占空间"><a href="#枚举所占空间" class="headerlink" title="枚举所占空间"></a>枚举所占空间</h4><p>C++标准文档中是这样说明的：“<strong>枚举类型的尺寸是以能够容纳最大枚举子的值的整数的尺寸</strong>”，同时标准中也说名了：“<strong>枚举类型中的枚举子的值必须要能够用一个int类型表述</strong>”。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论怎么添加枚举中的成员，输出的结果都为4个字节即一个整型类型的大小</p><h2 id="指针变量的介绍"><a href="#指针变量的介绍" class="headerlink" title="指针变量的介绍"></a>指针变量的介绍</h2><p>变量有int类型 char类型 doubke类型等等,指针变量也有同样的类型,不过指针的值是一个变量的地址,,<strong>实际上的是指针指向的是变量的地址</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> <span class="token comment">// 定义了一个整型类型的指针</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>             <span class="token comment">// 指针变量a指向整型变量b的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a指向变量的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印a指向的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打印变量b的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为</p><p>8<br>6487572<br>6487576<br>6487572</p><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>  <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// a为结构体变量,p为结构体指针,p指向a的地址</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10a</p><p>10a</p><h4 id="void类型的指针"><a href="#void类型的指针" class="headerlink" title="void类型的指针"></a>void类型的指针</h4><p>C语言中的void类型，代表任意类型，而不是空的意思，而是说它的类型是未知的，是还没指定的。<br>void * 是void类型的指针。void类型的指针的含义是：这是一个指针变量，该指针指向一个<br>void类型的数。void类型的数就是说这个数有可能是int，也有可能是float，也有可能是个结构体，哪种类型都有可能，只是我当前不知道。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>                    <span class="token comment">// p指向这个地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是int类型的，所以要强制转换成对应类型的指针</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是char类型的，所以要强制转换成对应类型的指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>a</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><strong>函数指针是实质上就是一个指针，不过他指向的是一个函数的地址。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义了一个函数指针</span>    p <span class="token operator">=</span> sum<span class="token punctuation">;</span><span class="token comment">//函数指针指向sum函数</span>    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span>     <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>9<br>9</p><h4 id="指针函数（和函数指针区别）"><a href="#指针函数（和函数指针区别）" class="headerlink" title="指针函数（和函数指针区别）"></a>指针函数（和函数指针区别）</h4><p>说到函数指针就不得不提到指针函数了，<strong>指针函数实质上是一个函数不过返回的是一个指针</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 定义一个指针用来接收返回的地址</span>    p <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指针p接收指针函数的返回的指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>max<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span> <span class="token comment">// 返回一个指针，这个指针指向的是最大值的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>数组指针同理，<strong>本质上也是一个指针不过指向的是一个数组</strong>，直接上代码感觉下面的代码已经很详细了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个二维数组的指针，注意要[3]为该数组指针的边界值</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>      <span class="token comment">// 二维数组指针指向b数组</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义了一个一维数组的指针</span>    q <span class="token operator">=</span> a<span class="token punctuation">;</span>      <span class="token comment">// 一维数组指针指向a数组</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意如果没有给出数组指针p的[3]这个边界值*(p+1)会报错说没有给出指针的边界值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>2<br>5</p><h4 id="指针数组（和数组指针区别）"><a href="#指针数组（和数组指针区别）" class="headerlink" title="指针数组（和数组指针区别）"></a>指针数组（和数组指针区别）</h4><p>同理，<strong>指针数组是一个是数组不过里面存放的是指针。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个指针数组</span>    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 数组里面的元素指向一个地址</span>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出指向地址的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2</p><p>3</p><p>4</p><h4 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>        <span class="token comment">// 指向这个指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// p1的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a的值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>000000000062FE08<br>000000000062FE14<br>000000000062FE14<br>5</p><h2 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h2><p>理解为一种思想，用结构体指针来实现的，结构体中的成员包括数据和结构体指针，结构体中的结构体指针指向的是下个结构体的地址，即用结构体中的结构体指针来链接各个结构体，整体称谓链表，那么有了链表就需要一个头指针来输出他，可以理解链表是多米诺骨牌，牌已经摆好了，只用推一下这个链表就展现到你眼前了，而这个推一下的动作就是头指针，</p><p><img src="/././imgc/1685508777711.png" alt="1685508777711"></p><h3 id="第一种静态链表的介绍与实现"><a href="#第一种静态链表的介绍与实现" class="headerlink" title="第一种静态链表的介绍与实现"></a>第一种静态链表的介绍与实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 创建一个节点</span><span class="token punctuation">}</span> p<span class="token punctuation">;</span>                      <span class="token comment">// 重新定义了struct student这个类型</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 给结构体变量赋值</span>    b<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>     <span class="token comment">// 头指针保存a的地址</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment">// a的节点保存结构体变量b的地址</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>   <span class="token comment">// b的节点保存结构体变量c的地址</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>   <span class="token comment">// c的节点保存结构体变量d的地址</span>    d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 给最后一个节点写个内容 用于判断节点是否已经遍历完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 头指针如果没有保存最后一个节点的内容 就一直遍历</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d  "</span><span class="token punctuation">,</span> head<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历score</span>        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>           <span class="token comment">// 把结构体中的next指针赋值给head结构体指针，则head指针指向的是下一个节点的地址。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10  20  30  40 </p><h3 id="第二种动态链表的介绍与实现"><a href="#第二种动态链表的介绍与实现" class="headerlink" title="第二种动态链表的介绍与实现"></a>第二种动态链表的介绍与实现</h3><p>静态链表是提前知道了有几个结构体变量，而实际上我们并不知道我们需要10个或者100个结构体变量来满足我们的需求，所以我们就需要一个动态的链表，我们需要多少它就给多少。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 定义结构体指用来指向下一个结构体的地址</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token comment">// 定义结构体指针函数用来动态定义链表并返回链表的头指针</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>                       <span class="token comment">// head指针指向链表的头指针，new指针指向新创建的结构体地址，last指针指向链表最后一个结构体</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先给头指针分配内存空间，不分配默认为4个字节</span>    last <span class="token operator">=</span> head<span class="token punctuation">;</span>                                             <span class="token comment">// 尾指针指向链表的最后一个结构体的地址</span>    head<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        q<span class="token operator">++</span><span class="token punctuation">;</span>        new <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给新添加的结点分配内存空间</span>        new<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>        last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span> <span class="token comment">// 链表与新创建的结构体链接起来</span>        last <span class="token operator">=</span> new<span class="token punctuation">;</span>       <span class="token comment">// 尾指针指向链表的最后一个结构体地址</span>    <span class="token punctuation">}</span>    last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 尾指针的值为空代表链表结束</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>       <span class="token comment">// 返回链表的头节点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 用来接收链表的头节点</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// 循环遍历链表并输出值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入5</p><p>输出的结果为01234</p><p>注意上述malloc分配的地址空间是连续的，比如为int *p整型指针分配8个字节，则8个字节的内存空间是连续的，并且可以用 *(p+0)和 *(p+1)来分别为其赋值。</p><h2 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break<strong>用于打断循环，也就是执行到break，直接跳出循环，</strong>可以打断for，switch，while，do..while。break可以跳出for，但是如果用一个以上的for，则是打断离它最近的for。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue<strong>用于跳出本次循环，不是退出循环，而是只跳出本次的循环</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>1.修饰全局变量，如果static修饰了全局变量，那只能在本工程使用，其他工程就不能调用了，</p><p>2.修饰局部变量，它是存储在静态存储区的，用static修饰过后，就是函数执行结束，值依然在，如果static未被赋值，默认值就是 0；</p><p>3.static修饰函数，函数也只能在本工程使用，其他工程不可调用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 修饰局部变量</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>12<br>11</p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token comment">// 注用extern修饰的变量要提前赋值且不能在为其赋值了，不然会报错。</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>0<br>1</p><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。</p><p>例如 typedef int a;表示的是为int取别名a，之后定int类型的变量可以 a  b；来定义一个整型变量b</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>1.对变量声明只读特性，保护变量值以防被修改</p><p>2.节省空间，避免不必要的内存分配。const修饰的变量在程序运行过程中只有一份拷贝</p><h3 id="define-无参"><a href="#define-无参" class="headerlink" title="#define 无参"></a>#define 无参</h3><p>#define 既不是定义，也不是声明，所以是不分配内存的，#define说白了就是替换的意思。</p><p>#define 宏名 字符串</p><h3 id="define-有参"><a href="#define-有参" class="headerlink" title="#define 有参"></a>#define 有参</h3><p>带参就是跟函数一样可以代替一些操作。</p><p>#define N(y) ((y)*(y))</p><h3 id="if"><a href="#if" class="headerlink" title="#if"></a>#if</h3><p>#if N </p><p>…</p><p>#else</p><p>…</p><p>如果N为真执行#if和#else之间的语句，否则执行#else之后的语句</p><h3 id="写过的题目"><a href="#写过的题目" class="headerlink" title="写过的题目"></a>写过的题目</h3><h4 id="一-链表的反转"><a href="#一-链表的反转" class="headerlink" title="一.链表的反转"></a>一.链表的反转</h4><p><img src="/././imgc/1685792379205.png" alt="1685792379205"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span><span class="token function">ReverseList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>pHead<span class="token punctuation">)</span><span class="token comment">//反转的指针函数</span><span class="token punctuation">{</span>    <span class="token comment">// write code here</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pHead <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pHead<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            q <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>            pHead <span class="token operator">=</span> pHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//遍历完之后要把头结点指向p</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ReverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用了两个指针，q和p分别指向头结点的前两个结点，可以说头节点带着q和p去找链表的结点，p改变结点的指向，</p><p>q保存了被指向的结点。</p><p>输出结果为321</p><h4 id="二-链表的合并"><a href="#二-链表的合并" class="headerlink" title="二.链表的合并"></a>二.链表的合并</h4><p><img src="/././imgc/1685875845805.png" alt="1685875845805"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//前面两个条件剔除了空链表的情况</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>val<span class="token operator">&lt;</span>list2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list1<span class="token operator">-&gt;</span>next<span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//让最小的节点指向下一次遍历返回的结果</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span><span class="token comment">//返回较小的节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>     <span class="token punctuation">{</span>        list2<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用到了递归算法，每次把两个链表较小的那个结点放入栈 的最低端，一直到其中一个链表遍历完，如何释放，得到链表的头结点点。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本篇</title>
      <link href="/2023/08/30/c-ji-chu-pian/"/>
      <url>/2023/08/30/c-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<p>C++学习（进阶加基础）</p><p>本文笔记链接</p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>C++有自己的头文件，例如iostream 没有.h<br>也可以用C的头文件 例如stdio.h 有.h<br>或者将C文件C++化 例如<a href="https://so.csdn.net/so/search?q=cstdio&amp;spm=1001.2101.3001.7020">cstdio</a> 前面加c没有.h</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>1.划分逻辑单元。避免名字冲突，</p><p>2.同名的命名空间可以合并，有时候一个名字空间太冗余或者其他原因需要分开实现在不同地方，</p><p>3.声明和定义分开，在命名空间中声明的函数，定义时要加：：作用域限定符。</p><p>4.命名空间可以嵌套，调用时则用a：：b：：要调用的对象。</p><p>5.using namespace 名字空间名<br>使用后该名字空间对于当前作用域可见，可以不再使用作用域限定符，一旦使用，不可再隐藏。<br>std名字空间全局可见。std标准库定义名字空间。</p><h3 id="：：作用域限定符"><a href="#：：作用域限定符" class="headerlink" title="：：作用域限定符"></a>：：作用域限定符</h3><p>表示：：后面的内容属于：：前面。翻译成中文就是 的<br>如果：：前面没有内容表示全局</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;namespace a{    char name = 'a';    void eat()    {        cout &lt;&lt; "吃饭" &lt;&lt; endl;    }}namespace b{    char name = 'a';    void eat()    {        cout &lt;&lt; "喝水" &lt;&lt; endl;    }}int main(){    a::eat();    b::eat();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>吃饭<br>喝水</p><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><ul><li>true表示真 单字节整数1</li><li>false表示假 单字节整数0</li></ul><p>boolalpha bool类型使用字符输出<br>noboolalpha bool关闭字符输出，数值输出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    bool b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> boolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"字符输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> noboolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"数值输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> <span class="token string">"内存大小"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>字符输出true<br>数值输出1<br>内存大小1</p><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><ul><li>用函数已被编译好的二进制代码，替换对该函数的调用指令。提高效率，避免函数调用开销。</li><li><strong>使用inline关键字期望该函数被优化为内联，是否内联由编译器决定</strong>。</li><li>内联会使可执行文件内存变大，只有频繁调用的简单函数适合内联。复杂函数和递归函数都不适合内联。</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一作用域中，函数名相同，参数表不同的函数。重载和返回值和参数名没有关系。</p><blockquote><p>函数作用域不是定义决定的，是声明决定的。</p></blockquote><blockquote><p>重载是编译器通过换名实现，<br>在linux下 用gcc -c 获取.o 使用nm .o文件查看<br>在windows下查看obj文件，或者不定义函数，只声明和使用<br>通过extern “C”可以要求C++编译器按照C方式处理函数接口</p></blockquote><h4 id="缺省参数和哑元"><a href="#缺省参数和哑元" class="headerlink" title="缺省参数和哑元"></a>缺省参数和哑元</h4><p>为函数指定缺省值，调用时若未指定实参，则对应的形参取缺省值</p><h4 id="缺省参数的特点"><a href="#缺省参数的特点" class="headerlink" title="缺省参数的特点"></a>缺省参数的特点</h4><ol><li>最好在函数声明中指定。可以利用声明改缺省值。</li><li>禁止在声明和定义同时指定缺省参数。可能不一致，编译器禁止</li><li>缺省参数只能在最后，即你某个参数指定为缺省参数，后面所有参数都要有缺省值</li><li>不要因为是用缺省参数导致重载歧义</li></ol><p>只指定类型而不指定名称的函数参数，叫做哑元。<br>使用哑元1.兼容之前版本。二.形成函数重载</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）是c++对c语言的重要扩充。<br>引用就是某一变量（内存）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：<br>类型 &amp;引用变量名 = 已定义过的变量名。</p><p>&amp;符号：跟在类型后是引用，没有类型是取地址<br>*符号：跟在类型后是指针，没有类型是解引用</p><h4 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点"></a>引用的特点</h4><ul><li>一个变量可取多个别名。</li><li>引用必须初始化，不能为空。</li><li>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量</li></ul><h4 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h4><p>引用变量和被引用的变量虽然是同一个变量，但是可以被不同修饰符修饰</p><h4 id="引用做参数"><a href="#引用做参数" class="headerlink" title="引用做参数"></a>引用做参数</h4><ul><li>节省空间+提高效率</li><li>值传递，形参生成局部临时变量接收实参的值。</li><li>引用传递，形参是实参的别名</li><li>指针传递，传入实参的地址，指针通过地址访问修改值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void fun1(int a){    a += 1;}void fun2(int &amp;a){    a += 1;}void fun3(int *a){    *a += 1;}int main(){    int a = 10;    fun1(a);    cout &lt;&lt; a &lt;&lt; endl;    fun2(a);    cout &lt;&lt; a &lt;&lt; endl;    fun3(&amp;a);    cout &lt;&lt; a &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10<br>11<br>12</p><h4 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h4><p>当引用做函数的返回值时: 函数可以放在赋值语句的左边(可以当左值)</p><p>实现了动态引用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int &amp;fun1(int &amp;a){    return a;}int main(){    int b;    int c = 3;    int d = 4;    fun1(b) = c;    cout &lt;&lt; b &lt;&lt; endl;    fun1(b) = d;    cout &lt;&lt; b &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>3<br>4</p><h3 id="动态分配-内存池"><a href="#动态分配-内存池" class="headerlink" title="动态分配+内存池"></a>动态分配+内存池</h3><h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>C语言使用malloc来动态分配内存空间，free释放内存空间，C++使用new和delete来创建和释放内存空间</p><p>在分配内存的同时初始化 int *p=new int(100);表示 *p的值为100；数组方式new的需要以数组方式delete</p><p>int *p = new int[2]{4, 2};  delete [ ]p;</p><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>预先分配好，放到进程空间的内存块，用户申请与释放内存其实都是在进程内进行,遇到小对象时就是基于内存池的。只有当内存池空间不够时，才会再从系统找一块很大的内存</p><h3 id="引用和指针的区别和联系"><a href="#引用和指针的区别和联系" class="headerlink" title="引用和指针的区别和联系"></a>引用和指针的区别和联系</h3><p>两者都是地址的概念<br>指针指向一块内存，其内容为所指内存的地址；<br>引用是某块儿内存的别名。</p><p>1.指针是一个实体，而引用仅是个别名；<br>2.引用使用时无需解引用(*)，指针需要解引用；<br>3.引用只能在定义时被初始化一次，之后不可变；指针可变；<br>4.引用没有 const，指针有 const；const修饰的指针不可变；<br>5.引用不能为空，指针可以为空；<br>6.“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；<br>7.指针和引用的自增(++)运算意义不一样；<br>8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><h3 id="new-和delete实现二维数组的动态申请内存"><a href="#new-和delete实现二维数组的动态申请内存" class="headerlink" title="new 和delete实现二维数组的动态申请内存"></a>new 和delete实现二维数组的动态申请内存</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int **arr = NULL;int **fun(int a, int b) // 动态分配数组函数{    int i;    arr = new int *[a]; // 创建指向一维数组的指针数组    for (int i = 0; i &lt; b; i++)    {        arr[i] = new int[b]; // 为每一个指针数组的值进行赋值    }    arr[0][0] = 5;    return arr;}int main(){    int **q; // 用来接收函数返回的二维数组的头地址    int a, b;    cin &gt;&gt; a &gt;&gt; b; // 输入行列    q = fun(a, b);    cout &lt;&lt; **q &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入</p><p>2</p><p>2</p><p>输出结果为</p><p>5</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2023/08/30/jvm-la-ji-hui-shou/"/>
      <url>/2023/08/30/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h4 id="1-1-引用计数器"><a href="#1-1-引用计数器" class="headerlink" title="1.1.引用计数器"></a>1.1.引用计数器</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>垃圾回收引用计数法（Reference Counting Garbage Collection）是一种常用的垃圾回收算法，它的基本思想是对每个对象记录它的引用计数，当引用计数为0时，就可以将这个对象回收掉。</li></ul><h5 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h5><ul><li>为每个对象维护一个引用计数器，记录当前有多少个指针引用了这个对象。</li><li>当有一个指针指向了这个对象时，引用计数器加1；当有一个指针不再引用这个对象时，引用计数器减1。</li><li>当引用计数器为0时，说明这个对象已经没有任何指针引用它了，可以将这个对象回收掉。</li></ul><h5 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><p><strong>优点</strong></p><p>​可以实现快速的内存回收，因为它不需要遍历整个堆内存，只需要回收引用计数为0的对象即可。</p><p><strong>缺点</strong></p><p>​实现比较复杂，需要为每个对象维护引用计数器，而且容易出现循环引用的问题，导致内存泄漏。</p><p><img src="/./img/6.5.png"></p><p>​<strong>循环引用指的是两个或多个对象之间相互引用，形成了一个闭环，如果这些对象的引用计数都不为0，那么它们将永远无法被回收，从而导致内存泄漏。</strong></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2.可达性分析算法"></a>1.2.可达性分析算法</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>​可达性分析算法（Reachability Analysis Algorithm）是现代垃圾回收算法中最常用的一种。它的基本思想是从一组根对象开始，通过<strong>遍历对象之间的引用关系</strong>，找到所有可以被访问到的对象，并将这些对象标记为存<strong>活对象</strong>。所有未被标记的对象则可以被视为<strong>垃圾对象</strong>，可以被回收</p><h5 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h5><ol><li><p>从一组根对象(gc_roots)开始，例如Java虚拟机中的堆栈、静态变量等。</p></li><li><p>遍历所有根对象能够访问到的对象，将这些对象标记为存活对象。</p></li><li><p>遍历所有已标记的存活对象，找到它们所引用的对象，将这些对象也标记为存活对象。</p></li><li><p>重复步骤3，直到所有可达对象都被标记为存活对象。</p></li><li><p>将未被标记的对象作为垃圾对象，进行回收。</p><p><strong>根对象(gc_roots)的查看（MAT工具）</strong></p><p><img src="/./img/6.6.png"></p></li></ol><h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3.四种引用"></a>1.3.四种引用</h4><p><img src="/./img/6.7.png"></p><h5 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h5><ul><li>强引用是最常见的引用类型</li><li>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li><li>通过<strong>new关键字创建一个对象</strong>，该对象具有强引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h5><ul><li>软引用是一种相对强引用弱化了一些的引用类型。</li><li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时</strong>会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li><li>常用于<strong>缓存对象，例如，图片缓存、数据缓存</strong>等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h5><ul><li>弱引用比软引用还要弱化一些。</li><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li><li>常用于<strong>ThreadLocal、WeakHashMap</strong>等</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h5><ul><li><p>虚引用是最弱化的引用类型。</p></li><li><p>如果一个对象只具有虚引用，那么无法通过虚引用获取到该对象，也无法通过虚引用对该对象进行任何操作。</p></li><li><p>虚引用主要用于在对象被回收时收到一个系统通知，例如，当一个对象被回收时，可以在虚引用的引用队列中收到通知。</p></li><li><p>必须配合引用队列使用，主要配合 <strong>ByteBuffer</strong>使用，被引用对象回收时，会将虚引用入队，由<strong>Reference Handler</strong>线程调用虚引用相关方法释放直接内存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="5-终结器引用"><a href="#5-终结器引用" class="headerlink" title="5.终结器引用"></a>5.终结器引用</h5><ul><li>终结器引用是一种特殊的引用类型，用于在对象被回收之前执行特定的清理操作。</li><li>无需手动编码，但其内部配合引用队列使用</li><li>终结器引用入队（被引用对象暂时没有被回收)，再由<strong>Finalizer线程</strong>通过终结器引用找到被引用对象并调用它的<strong>finalize方法</strong>，第二次GC时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1.标记清除"></a>2.1.标记清除</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记清除（Mark and Sweep）是一种垃圾回收算法，用于自动内存管理。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法分为两个阶段：标记和清除。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在清除阶段，垃圾回收器清除未被标记的对象，释放它们占用的内存。</li></ul><p><img src="/./img/7.1.png"></p><h5 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点：可以处理循环引用的情况，即当两个或多个对象相互引用时，它们之间的引用关系会被正确地识别和处理。</li><li>缺点：清除内存的过程可能会导致内存碎片化。</li></ul><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2.标记整理"></a>2.2.标记整理</h4><h5 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记整理（Mark and Compact）是标记清除算法的改进版本，在标记和清除阶段之后，还会对内存进行<strong>整理</strong>，以解决标记清除算法可能导致的内存碎片化问题。</p><h5 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h5><p>算法也分为两个阶段：标记和整理。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在整理阶段，垃圾回收器将所有标记为“存活”的对象移动到内存的一端，将未被标记的对象移动到内存的另一端，然后将这些未被标记的内存区域释放掉，以形成一块<strong>连续的内存空间</strong>。</li></ul><p><img src="/./img/7.2.png"></p><h5 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以解决标记清除算法可能导致的内存碎片化问题，从而减少了内存分配失败的概率。</li><li>缺点在于它需要在程序暂停时执行垃圾回收操作，可能会影响程序的性能。</li></ul><h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3.复制"></a>2.3.复制</h4><h5 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h5><p>复制（Copying）是将内存分为两个区域，每次只使用其中的一半。当当前区域的内存使用率达到一定阈值时，垃圾回收器会扫描当前区域中的存活对象，将它们复制到另一个空闲区域中，然后将当前区域清空，以便下一轮内存分配使用。</p><h5 id="2-作用-2"><a href="#2-作用-2" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法的主要步骤如下：</p><ol><li><p>将内存分为两个大小相等的区域，分别称为“From Space”和“To Space”。初始时，所有对象存放在From Space中。当From Space中的内存使用率达到一定阈值时，垃圾回收器开始扫描From Space中的存活对象。</p><p><img src="/./img/8.1.png"></p></li><li><p>垃圾回收器将这些存活对象复制到To Space中，并按照它们在From Space中的顺序排列。</p><p><img src="/./img/8.2.png"></p></li><li><p>垃圾回收器清空From Space，使其成为空闲空间。<img src="/./img/8.3.png"></p></li><li><p>交换From Space和To Space的角色，使To Space成为新的From Space，From Space成为空闲空间。</p><p><img src="/./img/8.4.png"></p></li></ol><h5 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以避免内存碎片化问题，因为每次复制存活对象时，都会将它们按顺序排列在新的空间中，从而形成一块连续的内存空间。另外，复制算法不需要执行标记和清除或标记和整理等额外的操作，因此执行起来比较高效。</li><li>缺点在于它需要使用双倍的内存空间来执行复制操作，这可能会导致<strong>内存使用率较低</strong>。此外，复制算法不能有效地处理长时间存活的对象，因为这些对象需要被反复复制，导致垃圾回收的效率降低。因此，复制算法通常用于<strong>处理生命周期短的对象</strong>，例如临时变量和函数调用栈中的对象。</li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3.分代垃圾回收"></a>3.分代垃圾回收</h2><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>Minor GC（新生代垃圾回收）是指针对新生代内存区域进行的垃圾回收，新生代内存区域通常是指年轻代和幸存者代。</li><li>Full GC（老年代垃圾回收）是指针对整个堆内存进行的垃圾回收。堆内存通常是指整个Java虚拟机中的内存区域，包括新生代和老年代。</li></ul><h5 id="2-作用-3"><a href="#2-作用-3" class="headerlink" title="2.作用"></a>2.作用</h5><p><img src="/./img/8.5.png"></p><ul><li><p>对象首先分配在伊甸园区域</p><p>当一个大对象内存大于伊甸园的内存时，就直接进入老年代</p><p>大对象内存也大于老年代的内存时，就会进行full gc</p></li><li><p>新生代空间不足时，<strong>触发minor gc</strong>，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to</p></li><li><p>minor gc 会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15 (4bit)</p></li><li><p>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么<strong>触发full gc</strong>，STW的时间更长</p></li></ul><p>3.相关jvm参数</p><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或-XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn或(-XX:NewSize=size +-XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-xX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-xx:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h4 id="4-1-串行回收器"><a href="#4-1-串行回收器" class="headerlink" title="4.1.串行回收器"></a>4.1.串行回收器</h4><h5 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h5><h5 id="2-堆内存较小，适合个人电脑"><a href="#2-堆内存较小，适合个人电脑" class="headerlink" title="2.堆内存较小，适合个人电脑"></a>2.堆内存较小，适合个人电脑</h5><p><strong>serial、Serial old收集器</strong>（Hotspot中Client模式下默认的新生代垃圾收集器）</p><p><strong>算法：复制算法、串行回收和”Stop The World”机制的方式执行内存回收</strong></p><p>​<strong>除新生代之外，Serial还提供用于老年代垃圾回收的Serial Old收集器。Serial Old同样采用了串行回收和”Stop The World”，只不过内存回收算法使用的是标记-压缩算法</strong></p><p><img src="/./img/a1.png"></p><h4 id="4-2-并行回收器"><a href="#4-2-并行回收器" class="headerlink" title="4.2.并行回收器"></a>4.2.并行回收器</h4><h5 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu"><a href="#2-堆内存较大，多核cpu" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-单位时间内，stw时间最短"><a href="#3-单位时间内，stw时间最短" class="headerlink" title="3.单位时间内，stw时间最短"></a>3.单位时间内，stw时间最短</h5><p><strong>Parallel收集器</strong>(jdk8默认使用)、ParNew、Parallel scavenge、Parallel old</p><p><strong>算法：复制算法、并行回收、”Stop The World”</strong></p><p>​<strong>Parallel在JDK1.6提供了用于执行老年代的Parallel Old，用来代替Serial Old<br>​Parallel Old采用了标记-压缩算法，但同样是基于并行回收、”Stop The World”</strong></p><p><strong>目标：是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾回收器</strong><br>           <strong>自适应调节策略也是Parallel Scavenge和ParNew的区别</strong></p><p>高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：执行<strong>批量处理、订单处理、工资支付、科学计算</strong>的应用程序</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>-XX:+UseParallelGC~-XX:+UseParalleloldGc</p><p><img src="/./img/b1.png"></p><h4 id="4-3-并发回收器"><a href="#4-3-并发回收器" class="headerlink" title="4.3.并发回收器"></a>4.3.并发回收器</h4><h5 id="1-多线程-1"><a href="#1-多线程-1" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu-1"><a href="#2-堆内存较大，多核cpu-1" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-尽可能让单次的stw时间最短"><a href="#3-尽可能让单次的stw时间最短" class="headerlink" title="3.尽可能让单次的stw时间最短"></a>3.尽可能让单次的stw时间最短</h5><h5 id="4-3-1-CMS收集器"><a href="#4-3-1-CMS收集器" class="headerlink" title="4.3.1.CMS收集器"></a>4.3.1.CMS收集器</h5><p><strong>算法：CMS采用标记-清除算法，也会有STW</strong></p><p><strong>目的：尽可能缩短垃圾回收时用户线程的停顿时间。停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验</strong></p><p>过程：</p><ol><li>初始标记阶段(Initial-Mark)：所有的工作线程会因为STW而出现短暂的停顿，这个阶段的主要任务仅仅只是标记除GC Roots能直接关联到的对象。一旦标记完成后就会恢复之前的应用线程。由于直接关联对象比较小，所以这里速度非常快</li><li>并发标记(Concurrent-Mark)：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但是不需要停顿用户线程，可以与垃圾回收线程并发运行</li><li>重新标记(Remark)：由于在并发标记阶段中，程序的工作线程会和垃圾回收线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除(Concurrent-Sweep)：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发的</li></ol><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>-XX:+UseConcMarkSweepGC~ -XX :+UseParNewGC ~ Serialold</p><p><img src="/./img/c1.png"></p><h5 id="4-3-2-G1"><a href="#4-3-2-G1" class="headerlink" title="4.3.2.G1"></a>4.3.2.G1</h5><p><img src="/./img/d1.png"></p><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>   G1（Garbage First）收集器是 JDK7 提供的一个新收集器，在 JDK9 中更被指定为官方GC收集器，与CMS收集器相比，最突出的改进是：</p><blockquote><ul><li>基于 “标记-整理” 算法，收集后不会产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ul></blockquote><p> G1 收集器不采用传统的新生代和老年代物理隔离的布局方式，仅在逻辑上划分新生代和老年代，将整个堆内存划分为2048个大小相等的独立内存块Region，每个Region是逻辑连续的一段内存并使用不同的Region来表示新生代和老年代，G1不再要求相同类型的 Region 在物理内存上相邻，而是通过Region的动态分配方式实现逻辑上的连续。</p><p>​        G1收集器通过跟踪Region中的垃圾堆积情况，每次根据设置的垃圾回收时间，回收优先级最高的区域，避免整个新生代或整个老年代的垃圾回收，使得stop the world的时间更短、更可控，同时在有限的时间内可以获得最高的回收效率。</p><p>​        通过区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>G1垃圾回收器的工作过程主要包括以下几个步骤：</p><ol><li><p>初始标记阶段（Initial Mark）：这个阶段是G1垃圾回收器的STW（Stop-The-World）阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的根对象，并标记所有的年轻代对象和部分老年代对象。这个阶段的主要目的是确定哪些对象是存活的，哪些对象可以被回收。</p></li><li><p>并发标记阶段（Concurrent Mark）：这个阶段是G1垃圾回收器的并发标记阶段，即在应用程序运行的同时，对存活对象进行标记。在这个阶段，G1会对所有的老年代对象进行标记。这个阶段的主要目的是标记所有的存活对象，为下一阶段的回收做准备。</p></li><li><p>并发预清理阶段（Concurrent Preclean）：这个阶段是G1垃圾回收器的并发预清理阶段，即在应用程序运行的同时，对标记的对象进行清理。在这个阶段，G1会清理掉一些无用的对象，以便在下一阶段的回收中提高效率。</p></li><li><p>最终标记阶段（Final Mark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的存活对象，以及在并发标记阶段和并发预清理阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>筛选回收阶段（Live Data Counting and Evacuation）：这个阶段是G1垃圾回收器的并发筛选回收阶段，即在应用程序运行的同时，对标记的对象进行筛选和回收。在这个阶段，G1会根据区域的垃圾比例和空间利用率等因素，动态选择回收对象，以最大化回收效率。这个阶段的主要目的是回收垃圾最多的区域，以最大化回收效率。</p></li><li><p>再次标记阶段（Remark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记在筛选回收阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>清理阶段（Cleanup）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会回收所有未被标记的对象，并进行内存整理。这个阶段的主要目的是回收内存空间，为应用程序提供足够的可用内存。</p></li></ol><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)，默认的暂停目标是200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region<br>整体上是标记+整理算法，两个区域之间是复制算法</li><li>缺点，例如在回收大对象时的性能可能不如其他垃圾回收器。</li></ul><h6 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h6><p>-XX : +UseG1GC<br>-XX:G1HeapRegionsize=size|<br>-XX:MaxGCPauseMillis=time</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p><img src="/./img/12.png"></p><p>最小化地使用内存和并行开销，请选serial GC;</p><p>最大化应用程序的吞吐量，请选Parallel GC;</p><p>最小化Gc的中断或停顿时间，请选CMs GC。</p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h2><h5 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h5><p><strong>案例1：Full GC和Minor GC频繁</strong></p><p>​在此情形下，需要先确定应用程序的内存使用情况，例如堆内存大小、对象创建和销毁的频率等。如果堆内存过小，可能会导致垃圾收集的频率增加，从而影响应用程序的性能。可以通过增加堆内存大小来减少垃圾收集的频率。</p><p>​另外，需要分析垃圾收集的日志，查看Full GC和Minor GC的发生频率和原因。如果Full GC和Minor GC的发生频率过高，可能是因为应用程序中存在大量的无用对象或内存泄漏。可以使用一些内存分析工具来识别和优化这些问题，例如查看内存堆转储（heap dump）中的对象信息、分析对象引用关系等。</p><p><strong>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong></p><p>​在此情形下，需要增加CMS收集器的并发线程数，以提高CMS收集器的并发处理能力，减少单次Full GC的暂停时间。可以使用参数”-XX:CMSConcurrentMTEnabled”来启用CMS收集器的多线程并发模式。</p><p>​另外，需要分析Full GC的日志，查看Full GC的原因和持续时间。如果Full GC的持续时间过长，可能是因为CMS收集器的老年代空间不足，导致Full GC无法回收足够的内存空间。可以通过增加老年代的空间大小来解决这个问题。</p><p><strong>案例3：老年代充裕情况下，发生Full GC（1.7）</strong></p><p>​在此情形下，可能是因为应用程序中存在大量的长时间存活的对象，导致老年代空间被占满，无法再分配新的对象。可以通过增加老年代的空间大小来解决这个问题。</p><p>​另外，还可以考虑使用G1收集器来改善垃圾收集的效率和性能。G1收集器可以根据应用程序的实际情况，动态调整垃圾回收的策略和参数，以最小化暂停时间和最大化吞吐量。可以通过使用参数”-XX:+UseG1GC”来启用G1收集器。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的内存结构</title>
      <link href="/2023/08/30/jvm-nei-cun-jie-gou/"/>
      <url>/2023/08/30/jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><ul><li><h5 id="JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"><a href="#JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。" class="headerlink" title="JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"></a>JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。</h5></li></ul><h4 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2.作用"></a>1.2.作用</h4><p><img src="/./img/2.1.png"></p><ol><li><h5 id="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"><a href="#用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。" class="headerlink" title="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"></a>用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。</h5></li><li><h5 id="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"><a href="#实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。" class="headerlink" title="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"></a>实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。</h5></li></ol><h4 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3.特点"></a>1.3.特点</h4><ol><li><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5></li><li><h5 id="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"><a href="#是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区" class="headerlink" title="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"></a>是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区</h5></li><li><h5 id="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"><a href="#执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空" class="headerlink" title="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"></a>执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空</h5></li></ol><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><p><img src="/./img/2.png"></p><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><h5 id="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"><a href="#JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。" class="headerlink" title="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"></a>JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。</h5><p><img src="/./img/2.2.PNG"></p><ul><li><h5 id="每个线程运行是所需要的内存，称为虚拟机栈"><a href="#每个线程运行是所需要的内存，称为虚拟机栈" class="headerlink" title="每个线程运行是所需要的内存，称为虚拟机栈"></a>每个线程运行是所需要的内存，称为虚拟机栈</h5></li><li><h5 id="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"><a href="#每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存" class="headerlink" title="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"></a>每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存</h5></li><li><h5 id="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"><a href="#每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法" class="headerlink" title="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"></a>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</h5><h5 id="问题解析："><a href="#问题解析：" class="headerlink" title="问题解析："></a>问题解析：</h5><p><strong>(1).垃圾回收是否涉及栈内存?</strong></p><p>​垃圾回收（Garbage Collection）一般是针对堆内存（Heap Memory）的，而与栈内存（Stack Memory）没有直接关系。</p><p><strong>(2).栈内存分配越大越好吗?</strong></p><p>​栈内存的大小应该根据具体的需求和系统资源进行合理分配，不是越大越好。</p><p><strong>(3).方法内的局部变量是否线程安全?│</strong></p><h5 id="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"><a href="#–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的" class="headerlink" title="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"></a>–<strong>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</strong></h5><h5 id="–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全"><a href="#–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全" class="headerlink" title="–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全"></a>–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全</h5></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2.栈内存溢出"></a>2.2.栈内存溢出</h4><h5 id="–出现StackOverflowError-异常"><a href="#–出现StackOverflowError-异常" class="headerlink" title="–出现StackOverflowError 异常"></a>–出现StackOverflowError 异常</h5><ul><li><h5 id="栈帧过多导致栈内存溢出-方法调用层次过深"><a href="#栈帧过多导致栈内存溢出-方法调用层次过深" class="headerlink" title="栈帧过多导致栈内存溢出(方法调用层次过深)"></a>栈帧过多导致栈内存溢出(方法调用层次过深)</h5><p><img src="/./img/%E6%A0%881.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="栈帧过大导致栈内存溢出-方法中创建过多的局部变量"><a href="#栈帧过大导致栈内存溢出-方法中创建过多的局部变量" class="headerlink" title="栈帧过大导致栈内存溢出(方法中创建过多的局部变量)"></a>栈帧过大导致栈内存溢出(方法中创建过多的局部变量)</h5><p><img src="/./img/%E6%A0%882.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置虚拟机栈大小-："><a href="#设置虚拟机栈大小-：" class="headerlink" title="设置虚拟机栈大小  ："></a>设置虚拟机栈大小  ：</h5><ol><li>-Xss：用于设置单个线程的栈大小。</li><li>-XX:ThreadStackSize：也可以使用这个参数来设置单个线程的栈大小。</li><li>在启动 Java 应用程序时通过指定这些参数来设置虚拟机栈的大小，例如：java -Xss1m MyClass</li></ol></li></ul><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3.线程运行诊断"></a>2.3.线程运行诊断</h4><ul><li><h5 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h5><p><strong>定位:</strong></p><h6 id="a-用top定位哪个进程对cpu的占用过高"><a href="#a-用top定位哪个进程对cpu的占用过高" class="headerlink" title="a.用top定位哪个进程对cpu的占用过高"></a>a.用top定位哪个进程对cpu的占用过高</h6><h6 id="b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高"><a href="#b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高" class="headerlink" title="b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)"></a>b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)</h6><h6 id="c-jstack-进程id"><a href="#c-jstack-进程id" class="headerlink" title="c.jstack 进程id"></a>c.jstack 进程id</h6><h6 id="可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号"><a href="#可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号" class="headerlink" title="可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号"></a>可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</h6></li><li><h5 id="程序运行很长时间没有结果"><a href="#程序运行很长时间没有结果" class="headerlink" title="程序运行很长时间没有结果"></a>程序运行很长时间没有结果</h5><p><img src="/./img/x.png"></p></li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="/./img/3.png"></p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><h5 id="本地方法栈的主要功能是为执行本地方法时提供栈空间"><a href="#本地方法栈的主要功能是为执行本地方法时提供栈空间" class="headerlink" title="本地方法栈的主要功能是为执行本地方法时提供栈空间"></a>本地方法栈的主要功能是为执行本地方法时提供栈空间</h5><h5 id="本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"><a href="#本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。" class="headerlink" title="本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"></a>本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。</h5><h6 id="JVM-中的本地方法主要有以下两种类型："><a href="#JVM-中的本地方法主要有以下两种类型：" class="headerlink" title="JVM 中的本地方法主要有以下两种类型："></a>JVM 中的本地方法主要有以下两种类型：</h6><ul><li>​-Native 方法：Native 方法是指在 Java 中声明的本地方法，其实现由本地代码编写。</li><li>​-JNI 方法：JNI 方法是指在本地代码中实现的 Java 方法</li></ul><h4 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2.举例"></a>3.2.举例</h4><ul><li><p>java.lang.System：System 类包含一些与系统操作相关的本地方法，例如获取系统属性、读取标准输入输出流等。</p></li><li><p>java.io.FileDescriptor：FileDescriptor 类封装了一个操作系统文件描述符，它的本地方法用于创建、读写和关闭文件。</p></li><li><p>java.net.SocketImpl：SocketImpl 类是一个网络套接字的实现类，它的本地方法用于创建和管理底层的网络连接。</p></li><li><p>java.util.zip.Inflater：Inflater 类是一个压缩解压缩器，它的本地方法用于解压缩数据。</p></li><li><p>java.util.Random：Random 类是一个随机数生成器，它的本地方法用于获取随机数种子和生成随机数。</p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="/./img/4.png"></p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><h5 id="1-Heap-堆"><a href="#1-Heap-堆" class="headerlink" title="1.Heap 堆"></a>1.Heap 堆</h5><h5 id="堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"><a href="#堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。" class="headerlink" title="堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"></a>堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（<strong>通过new关键字创建对象）等数据。</strong></h5><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><ul><li><h5 id="是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器"><a href="#是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器" class="headerlink" title="是线程共享的:  堆中对象要考虑线程安全的问题–> 线程栈和程序计数器"></a>是线程共享的:  堆中对象要考虑线程安全的问题–&gt; 线程栈和程序计数器</h5></li><li><h5 id="有垃圾回收机制"><a href="#有垃圾回收机制" class="headerlink" title="有垃圾回收机制"></a>有垃圾回收机制</h5></li><li><h5 id="动态分配-堆的空间大小是在-JVM-启动时动态分配的"><a href="#动态分配-堆的空间大小是在-JVM-启动时动态分配的" class="headerlink" title="动态分配:  堆的空间大小是在 JVM 启动时动态分配的"></a>动态分配:  堆的空间大小是在 JVM 启动时动态分配的</h5></li><li><h5 id="分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象"><a href="#分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象" class="headerlink" title="分代管理：分为新生代和老年代 –>  新创建的对象,经过多次垃圾回收的对象"></a>分代管理：分为新生代和老年代 –&gt;  新创建的对象,经过多次垃圾回收的对象</h5></li><li><h5 id="物理实现：由操作系统的虚拟内存来实现的"><a href="#物理实现：由操作系统的虚拟内存来实现的" class="headerlink" title="物理实现：由操作系统的虚拟内存来实现的"></a>物理实现：由操作系统的虚拟内存来实现的</h5></li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2.堆内存溢出"></a>4.2.堆内存溢出</h4><h5 id="–出现OutOfMemoryError异常"><a href="#–出现OutOfMemoryError异常" class="headerlink" title="–出现OutOfMemoryError异常"></a>–出现OutOfMemoryError异常</h5><ol><li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序会不断地创建字符串对象并添加到列表中，当字符串的数量太大时，就会导致堆内存溢出错误，抛出 OutOfMemoryError 异常。</p></li><li><h5 id="设置虚拟机堆大小"><a href="#设置虚拟机堆大小" class="headerlink" title="设置虚拟机堆大小"></a>设置虚拟机堆大小</h5><h5 id="Xms：设置-Java-堆的初始大小。"><a href="#Xms：设置-Java-堆的初始大小。" class="headerlink" title="-Xms：设置 Java 堆的初始大小。"></a>-Xms：设置 Java 堆的初始大小。</h5><h5 id="Xmx：设置-Java-堆的最大大小。"><a href="#Xmx：设置-Java-堆的最大大小。" class="headerlink" title="-Xmx：设置 Java 堆的最大大小。"></a>-Xmx：设置 Java 堆的最大大小。</h5></li></ol><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3.堆内存诊断"></a>4.3.堆内存诊断</h4><ul><li><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5></li></ul><ol><li>jps 指令<br>查看当前系统中有哪些java进程</li><li>jmap-heap {pid}  指令<br>查看堆内存占用情况</li><li>jconsole指令  -&gt;工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 指令</li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="/./img/5.png"></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"><a href="#JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。" class="headerlink" title="JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"></a>JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。</h5><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h4><p><img src="/./img/5.1.png"></p><ul><li><h5 id="在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"><a href="#在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。" class="headerlink" title="在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"></a>在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。</h5></li><li><h5 id="在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"><a href="#在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。" class="headerlink" title="在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"></a>在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。</h5></li></ul><h4 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h4><h5 id="出现OutOfMemoryError-Metaspace-异常"><a href="#出现OutOfMemoryError-Metaspace-异常" class="headerlink" title="-出现OutOfMemoryError:Metaspace 异常"></a>-出现OutOfMemoryError:Metaspace 异常</h5><ol><li><p><strong>示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Path</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaspaceOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.example.DynamicClass"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token class-name">String</span> classPath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>**调整元空间的大小   **</p><p><strong>-XX:MaxMetaspaceSize = 8m</strong></p><p><strong>jdk1.6的情况 -XX:MaxPermSize=8m</strong></p></li></ol><h4 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstantPoolExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 常量池中的字符串常量</span>                <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将"Hello, world!"字符串常量放入常量池中</span>        <span class="token comment">// 在编译时将"Hello, world!"字符串常量放入常量池中并将str2指向常量池中的同一个字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>         <span class="token comment">// 在运行时，创建一个新的字符串对象，并将其指向堆中新建的一个对象</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个字符串常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为它们指向不同的对象</span>                <span class="token comment">// 常量池中的数字常量</span>        <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将数字常量100放入常量池中</span>        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 将数字常量100放入常量池中，并将num2指向常量池中的同一个数字常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个数字常量</span>                <span class="token comment">// 常量池中的类引用</span>        <span class="token comment">// 在编译时，将ConstantPoolExample类的引用放入常量池中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">ConstantPoolExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>         <span class="token comment">// 在编译时，将字符串常量"ConstantPoolExample"放入常量池中</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"ConstantPoolExample"</span><span class="token punctuation">;</span> <span class="token comment">// true，它们都指向常量池中的同一个类引用</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</strong>**</li><li><em><em>运行时常量池，常量池是</em>.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</em>*</li></ul><h4 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>StringTable 是 Java 虚拟机（JVM）中的一个<strong>数据结构</strong>(JDK 8 中基于字符串哈希值的分离链接哈希表)，用于存储字符串常量。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>StringTable 的作用是<strong>优化字符串的存储和共享</strong>，从而减少内存的开销。</p><p>在 Java 应用程序中，字符串常量通常占用较大的内存空间，如果每次都创建新的字符串对象，会导致内存占用量增加，从而影响应用程序的性能。为了避免这种情况，Java 使用了 StringTable 来存储字符串常量，并在<strong>需要使用(延迟加载)字符串常量时直接引用 StringTable 中的对象</strong>，从而避免了重复创建字符串对象，减少了内存占用量。</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为字符串常量是共享的</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为字符串对象不是共享的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./img/s.jpg"></p><ul><li>在String s4 = s1+s2 是通过new StringBuilder()…  –&gt;字符串变量 s4 是通过字符串变量 a 和 b 的拼接得到的，它是一个新的字符串对象，与字符串常量 “ab” 不相等，</li><li>String s5 = “a”+”b”  是在StringTable中取的已存在的”ab”   –&gt; 字符串常量 “ab” 和 “a” + “b” 的值相等</li></ul><h5 id="4-特性"><a href="#4-特性" class="headerlink" title="4.特性"></a>4.特性</h5><ol><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是StringBuilder ( 1.8)</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用intern方法，主动将串池中还没有的字符串对象放入串池</p><p><strong>1.8将这个字符串对象尝试放入串池，如果有则并不会放入（还在堆区），如果没有则放入串池(堆区-&gt;常量池），会把串池中的对象返回</strong><br><strong>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份,放入串池,会把串池中的对象返回</strong></p><p>–示例一：   String s = new String(“a”)+new String (“b”)”写在String x = “ab前面</p><p><img src="/./img/51.png"></p><p>1.8中：”ab” 在串池中没有，会将s放入串池(s从堆区-&gt;常量池），得到的结果为：s==x 为true</p><p>1.6中：”ab” 在串池中没有，会将s拷贝一份再放入串池(s还在堆区），得到的结果为：s==x 为false</p><p>–示例二：如果将String x = “ab”写在String s = new String(“a”)+new String (“b”)前面</p><p>如果有则并不会放入–&gt;都不会进入串池 s==x  都为 false</p></li></ol><h5 id="5-位置"><a href="#5-位置" class="headerlink" title="5.位置"></a>5.位置</h5><p><img src="/./img/61.png"></p><ul><li><p>JDK 7 及之前的版本中，String Table 是一个固定大小的哈希表存储在永久代中，因此在运行时无法动态扩容</p></li><li><p>JDK 8 引入了一种叫做 <strong>Compact Strings</strong> 的技术，可以将字符串常量存储在堆中</p><p>Compact Strings 技术的实现方式是将较短的字符串常量（长度小于等于 16）存储为字节数组，而不是存储为 char 数组。</p></li></ul><h5 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6.垃圾回收"></a>6.垃圾回收</h5><p><img src="/./img/62.png"></p><h5 id="7-调优"><a href="#7-调优" class="headerlink" title="7.调优"></a>7.调优</h5><ul><li>可通过参数 <code>-XX:StringTableSize</code> 来设置 StringTable 的桶大小</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableBenchmark</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NUM_STRINGS</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">BUCKET_SIZES</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1009</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">65536</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">:</span> <span class="token constant">BUCKET_SIZES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Testing with bucket size "</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">runBenchmark</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 构造大量的字符串常量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">NUM_STRINGS</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"string"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 调整 StringTable 的桶大小</span>        <span class="token class-name">StringTable</span><span class="token punctuation">.</span><span class="token function">adjustSize</span><span class="token punctuation">(</span>bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印 StringTable 的统计信息</span>        <span class="token class-name">StringTableStats</span><span class="token punctuation">.</span><span class="token function">printStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印程序运行时间</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Time taken: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">1009</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">1009</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">6.579</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">17</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">1267</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">8192</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">8192</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">1.219</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">6</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">891</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">65536</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">65536</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">0.153</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">1</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">849</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以考虑将字符串对象入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"><a href="#JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存" class="headerlink" title="JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"></a>JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存</h5><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h4><p><strong>JVM直接内存可以通过Java NIO（New I/O）库中的ByteBuffer类来进行访问和操作，它的主要特点是可以提高I/O操作的效率，减少内存复制和上下文切换的开销。</strong></p><h5 id="–java的io操作-存在缓冲区的复制操作"><a href="#–java的io操作-存在缓冲区的复制操作" class="headerlink" title="–java的io操作(存在缓冲区的复制操作)"></a>–java的io操作(存在缓冲区的复制操作)</h5><p><img src="/./img/6.1.png"></p><h5 id="–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024"><a href="#–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024" class="headerlink" title="–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);"></a>–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);</h5><p>这个方法会在<strong>堆内存</strong>中分配一个DirectByteBuffer对象，并在<strong>操作系统</strong>中分配一块原生内存，用来存储ByteBuffer对象中的数据。</p><p><img src="/./img/6.2.png"></p><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h4><h5 id="直接内存的释放："><a href="#直接内存的释放：" class="headerlink" title="直接内存的释放："></a>直接内存的释放：</h5><h5 id="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"><a href="#Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。" class="headerlink" title="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"></a>Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。</h5><ol><li>调用DirectByteBuffer类的clear()方法</li><li>freeMemory(long address)：释放指定地址的内存块。</li></ol><p><img src="/./img/6.3.png"></p><h5 id="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"><a href="#由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存" class="headerlink" title="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"></a>由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存</h5><p><strong>–ByteBuffer.allocateDirect(1024*1024)中对Unsafe的调用;</strong></p><p><img src="/./img/6.4.png"></p><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner(虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemor来释放直接内存</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><h4 id="1-部分："><a href="#1-部分：" class="headerlink" title="1.部分："></a>1.部分：</h4><ol><li><h5 id="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"><a href="#堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。" class="headerlink" title="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"></a>堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。</h5></li><li><h5 id="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"><a href="#栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。" class="headerlink" title="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"></a>栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。</h5></li><li><h5 id="方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"><a href="#方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。" class="headerlink" title="方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"></a>方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。</h5></li><li><h5 id="本地方法栈（Native-Stack）：用于存储Native方法的现场数据。"><a href="#本地方法栈（Native-Stack）：用于存储Native方法的现场数据。" class="headerlink" title="本地方法栈（Native Stack）：用于存储Native方法的现场数据。"></a>本地方法栈（Native Stack）：用于存储Native方法的现场数据。</h5></li><li><h5 id="PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。"></a>PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h4><ol><li><h5 id="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"><a href="#堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。" class="headerlink" title="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"></a>堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。</h5></li><li><h5 id="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"><a href="#栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。" class="headerlink" title="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"></a>栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。</h5></li><li><h5 id="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"><a href="#方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。" class="headerlink" title="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"></a>方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。</h5></li><li><h5 id="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"></a>PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="3-区别："><a href="#3-区别：" class="headerlink" title="3.区别："></a>3.区别：</h4><ol><li><h5 id="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"><a href="#栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。" class="headerlink" title="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"></a>栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。</h5></li><li><h5 id="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"><a href="#方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。" class="headerlink" title="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"></a>方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。</h5></li><li><h5 id="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"><a href="#PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。" class="headerlink" title="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"></a>PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本概念</title>
      <link href="/2023/08/30/jvm-ji-ben-gai-nian/"/>
      <url>/2023/08/30/jvm-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="一、什么是-JVM？"><a href="#一、什么是-JVM？" class="headerlink" title="一、什么是 JVM？"></a>一、什么是 JVM？</h2><h4 id="JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。"><a href="#JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。" class="headerlink" title="JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。"></a>JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。</h4><h2 id="二、JVM-的组成"><a href="#二、JVM-的组成" class="headerlink" title="二、JVM 的组成"></a>二、JVM 的组成</h2><p><img src="/./img/jvm1.png"></p><ol><li><h4 id="类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。</h4></li><li><h4 id="运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分："><a href="#运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分：" class="headerlink" title="运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分："></a>运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分：</h4><ul><li><h5 id="方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。"><a href="#方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。" class="headerlink" title="方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。"></a>方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。</h5></li><li><h5 id="堆（Heap）：存储对象实例。"><a href="#堆（Heap）：存储对象实例。" class="headerlink" title="堆（Heap）：存储对象实例。"></a>堆（Heap）：存储对象实例。</h5></li><li><h5 id="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"><a href="#栈（Stack）：存储局部变量、操作数栈、方法返回值等。" class="headerlink" title="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"></a>栈（Stack）：存储局部变量、操作数栈、方法返回值等。</h5></li><li><h5 id="本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。"><a href="#本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。" class="headerlink" title="本地方法栈（Native Method Stack）：存储 JNI 调用信息。"></a>本地方法栈（Native Method Stack）：存储 JNI 调用信息。</h5></li><li><h5 id="PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。"><a href="#PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。" class="headerlink" title="PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。"></a>PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。</h5></li></ul></li><li><h4 id="执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。"><a href="#执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。" class="headerlink" title="执行引擎（Execution Engine）：负责将字节码解释成机器码执行。"></a>执行引擎（Execution Engine）：负责将字节码解释成机器码执行。</h4></li><li><h4 id="本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。"><a href="#本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。" class="headerlink" title="本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。"></a>本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。</h4></li><li><h4 id="JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。"><a href="#JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。" class="headerlink" title="JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。"></a>JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。</h4></li></ol><h2 id="三、JVM-的工作原理"><a href="#三、JVM-的工作原理" class="headerlink" title="三、JVM 的工作原理"></a>三、JVM 的工作原理</h2><h4 id="JVM-的工作原理如下："><a href="#JVM-的工作原理如下：" class="headerlink" title="JVM 的工作原理如下："></a>JVM 的工作原理如下：</h4><p><img src="/./img/jvm2.png"></p><ol><li><h5 id="类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。</h5></li><li><h5 id="执行引擎将字节码解释成机器码执行。"><a href="#执行引擎将字节码解释成机器码执行。" class="headerlink" title="执行引擎将字节码解释成机器码执行。"></a>执行引擎将字节码解释成机器码执行。</h5></li><li><h5 id="在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"><a href="#在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。" class="headerlink" title="在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"></a>在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。</h5></li><li><h5 id="执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"><a href="#执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。" class="headerlink" title="执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"></a>执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。</h5></li><li><h5 id="执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"><a href="#执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。" class="headerlink" title="执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"></a>执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。</h5></li></ol><h2 id="四、JVM-的优化"><a href="#四、JVM-的优化" class="headerlink" title="四、JVM 的优化"></a>四、JVM 的优化</h2><h4 id="1-内存分配优化"><a href="#1-内存分配优化" class="headerlink" title="1.内存分配优化"></a>1.内存分配优化</h4><p>​可以通过调整堆大小、使用对象池等方式优化内存的分配和回收。</p><h4 id="2-垃圾回收优化"><a href="#2-垃圾回收优化" class="headerlink" title="2.垃圾回收优化"></a>2.垃圾回收优化</h4><pre><code> 可以通过选择不同的垃圾回收算法、调整垃圾回收参数等方式优化垃圾回收效率。</code></pre><h4 id="3-即时编译优化"><a href="#3-即时编译优化" class="headerlink" title="3.即时编译优化"></a>3.即时编译优化</h4><p>​可以通过调整 JIT 编译器的参数、选择不同的编译策略等方式优化即时编译效率。</p><h4 id="4-多线程优化"><a href="#4-多线程优化" class="headerlink" title="4.多线程优化"></a>4.多线程优化</h4><p>​可以通过合理地使用多线程技术，提高程序的并发性能。</p><h2 id="五、JVM-的调优工具"><a href="#五、JVM-的调优工具" class="headerlink" title="五、JVM 的调优工具"></a>五、JVM 的调优工具</h2><h4 id="1-jstat"><a href="#1-jstat" class="headerlink" title="1.jstat"></a>1.jstat</h4><p>​用于监控 JVM 运行时数据区的状态。</p><h4 id="2-jmap"><a href="#2-jmap" class="headerlink" title="2.jmap"></a>2.jmap</h4><p>​用于生成堆转储文件，分析堆内存使用情况。</p><h4 id="3-jconsole"><a href="#3-jconsole" class="headerlink" title="3.jconsole"></a>3.jconsole</h4><p>​用于监控 JVM 的运行状态，包括内存、线程、GC 等信息。</p><h4 id="4-VisualVM"><a href="#4-VisualVM" class="headerlink" title="4.VisualVM"></a>4.VisualVM</h4><p>​用于监控和分析 JVM 应用程序的性能，包括内存、线程、GC 等信息。</p><h4 id="5-jprofiler"><a href="#5-jprofiler" class="headerlink" title="5.jprofiler"></a>5.jprofiler</h4><p>​用于分析 JVM 应用程序的性能瓶颈，包括方法调用时间、线程状态、内存分配等信息。</p><h6 id="总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。"><a href="#总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。" class="headerlink" title="总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。"></a>总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。</h6><h2 id="六、JVM、JRE、JDK、JavaSE-和-JavaEE"><a href="#六、JVM、JRE、JDK、JavaSE-和-JavaEE" class="headerlink" title="六、JVM、JRE、JDK、JavaSE 和 JavaEE"></a>六、JVM、JRE、JDK、JavaSE 和 JavaEE</h2><p><img src="/./img/jvm_jre_jdk.png"></p><h4 id="1-JVM（Java-Virtual-Machine）"><a href="#1-JVM（Java-Virtual-Machine）" class="headerlink" title="1.JVM（Java Virtual Machine）"></a>1.JVM（Java Virtual Machine）</h4><h5 id="Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。"><a href="#Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。" class="headerlink" title="Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。"></a>Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。</h5><h4 id="2-JRE（Java-Runtime-Environment）"><a href="#2-JRE（Java-Runtime-Environment）" class="headerlink" title="2.JRE（Java Runtime Environment）"></a>2.JRE（Java Runtime Environment）</h4><h5 id="Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。"><a href="#Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。" class="headerlink" title="Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。"></a>Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。</h5><h4 id="3-JDK（Java-Development-Kit）"><a href="#3-JDK（Java-Development-Kit）" class="headerlink" title="3.JDK（Java Development Kit）"></a>3.JDK（Java Development Kit）</h4><h5 id="Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。"><a href="#Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。" class="headerlink" title="Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。"></a>Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。</h5><h4 id="4-JavaSE（Java-Platform-Standard-Edition）"><a href="#4-JavaSE（Java-Platform-Standard-Edition）" class="headerlink" title="4.JavaSE（Java Platform, Standard Edition）"></a>4.JavaSE（Java Platform, Standard Edition）</h4><h5 id="Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。"><a href="#Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。" class="headerlink" title="Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。"></a>Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。</h5><h4 id="5-JavaEE（Java-Platform-Enterprise-Edition）"><a href="#5-JavaEE（Java-Platform-Enterprise-Edition）" class="headerlink" title="5.JavaEE（Java Platform, Enterprise Edition）"></a>5.JavaEE（Java Platform, Enterprise Edition）</h4><h5 id="Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。"><a href="#Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。" class="headerlink" title="Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。"></a>Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。</h5><h6 id="总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。"><a href="#总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。" class="headerlink" title="总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。"></a>总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。</h6><h3 id="七、常见的-JVM（Java-Virtual-Machine）"><a href="#七、常见的-JVM（Java-Virtual-Machine）" class="headerlink" title="七、常见的 JVM（Java Virtual Machine）"></a>七、常见的 JVM（Java Virtual Machine）</h3><p><img src="/./img/jvm%E5%AE%9E%E7%8E%B0.png"></p><ol><li><h4 id="Oracle-JDK（Java-Development-Kit）："><a href="#Oracle-JDK（Java-Development-Kit）：" class="headerlink" title="Oracle JDK（Java Development Kit）："></a>Oracle JDK（Java Development Kit）：</h4><h5 id="是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="OpenJDK："><a href="#OpenJDK：" class="headerlink" title="OpenJDK："></a>OpenJDK：</h4><h5 id="是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="IBM-JDK："><a href="#IBM-JDK：" class="headerlink" title="IBM JDK："></a>IBM JDK：</h4><h5 id="是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="Azul-Zulu-JDK："><a href="#Azul-Zulu-JDK：" class="headerlink" title="Azul Zulu JDK："></a>Azul Zulu JDK：</h4><h5 id="是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。"><a href="#是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。" class="headerlink" title="是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。"></a>是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。</h5></li><li><h4 id="Amazon-Corretto-JDK："><a href="#Amazon-Corretto-JDK：" class="headerlink" title="Amazon Corretto JDK："></a>Amazon Corretto JDK：</h4><h5 id="是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。"><a href="#是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。" class="headerlink" title="是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。"></a>是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。</h5></li><li><h4 id="AdoptOpenJDK："><a href="#AdoptOpenJDK：" class="headerlink" title="AdoptOpenJDK："></a>AdoptOpenJDK：</h4><h5 id="是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"><a href="#是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。" class="headerlink" title="是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"></a>是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。</h5></li></ol><h6 id="这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。"><a href="#这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。" class="headerlink" title="这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。"></a>这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。</h6>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
