<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot 详解</title>
      <link href="/2023/09/14/springboot-xiang-jie/"/>
      <url>/2023/09/14/springboot-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="SpringBoot-详解"><a href="#SpringBoot-详解" class="headerlink" title="SpringBoot 详解"></a>SpringBoot 详解</h2><h3 id="1-SpringBoot简介"><a href="#1-SpringBoot简介" class="headerlink" title="1.SpringBoot简介"></a>1.SpringBoot简介</h3><h4 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h4><p>SpringBoot是目前软件中最主流的框架SpringBoot主要解决了传统spring的重量级<strong>xml配置</strong>Bean，实现了<strong>自动装配</strong>。用来简化spring应用的初始搭建以及开发过程。</p><h4 id="1-2-为什么用SpringBoot"><a href="#1-2-为什么用SpringBoot" class="headerlink" title="1.2.为什么用SpringBoot"></a>1.2.为什么用SpringBoot</h4><p><strong>一、独立运行</strong> </p><p>Spring Boot而且内嵌了各种servlet容器，Tomcat、Jetty等，现在不再需要打成war包部署到容器中，Spring Boot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内。 </p><p><strong>二、简化配置</strong> </p><p>spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置。 </p><p><strong>三、自动配置</strong> </p><p>阿里内部资料Spring Boot能根据当前类路径下的类、jar包来自动配置bean，如添加一个spring-boot-starter-web启动器就能拥有web的功能，无需其他配置。 </p><p><strong>四、无代码生成和XML配置</strong> </p><p>Spring Boot配置过程中无代码生成，也无需XML配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是Spring4.x的核心功能之一。 </p><p><strong>五、应用监控</strong> </p><p>Spring Boot提供一系列端点可以监控服务及应用，做健康检测。 </p><p><strong>Spring boot actuator</strong>是spring启动框架中的重要功能之一。Spring boot监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。监视器模块公开了一组可直接作为HTTP URL访问的REST端点来检查状态。</p><h4 id="1-3-SpringBoot的Starters"><a href="#1-3-SpringBoot的Starters" class="headerlink" title="1.3.SpringBoot的Starters"></a>1.3.SpringBoot的Starters</h4><p>Starters可以理解为启动器，它包含了一系列可以集成到应用里面的依赖包，你可以一站式集成Spring 及其他技术，而不需要到处找示例代码和依赖包。</p><p>它的主要作用有几个。 </p><ol><li><p>Starter 组件以功能为纬度，来<strong>维护对应的 jar 包的版本依赖</strong>，使得开发者可以不需要去关心这些版本冲突这种容易出错的细节。 </p></li><li><p>Starter 组件会把<strong>对应功能的所有 jar 包依赖全部导入进来</strong>，避免了开发者自己去引入依赖带来的麻烦。 </p></li><li><p>Starter 内部<strong>集成了自动装配的机制</strong>，也就说在程序中依赖对应的starter 组件以后， 这个组件自动会集成到 Spring 生态下，并且对于相关 Bean 的管理，也是基于自动装配机制来完成。 </p></li><li><p>依赖 Starter 组件后，这个组件对应的功能所需要<strong>维护的外部化配置</strong>，会自动集成到 Spring Boot 里面，我们只需要在 application.properties 文件里面进行维护就行。</p></li></ol><ul><li>官方维护的 starter 的以 spring-boot-starter 开头的前缀。 </li><li>第三方维护的 starter 是以 spring-boot-starter 结尾的后缀</li></ul><h4 id="1-4-spring-boot-starter-parent"><a href="#1-4-spring-boot-starter-parent" class="headerlink" title="1.4.spring-boot-starter-parent"></a>1.4.spring-boot-starter-parent</h4><p>新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 父工程 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>作用：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.7.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>packaging</span><span class="token punctuation">&gt;</span></span>pom<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>packaging</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>spring-boot-starter-parent继承自 spring-boot-dependencies，这个里边定义了依赖的版本</strong>，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</p><h4 id="1-5-SpringBoot-读取配置文件中参数的方式"><a href="#1-5-SpringBoot-读取配置文件中参数的方式" class="headerlink" title="1.5.SpringBoot 读取配置文件中参数的方式"></a>1.5.SpringBoot 读取配置文件中参数的方式</h4><h5 id="1-Value-读取配置参数"><a href="#1-Value-读取配置参数" class="headerlink" title="1.@Value 读取配置参数"></a>1.@Value 读取配置参数</h5><p><strong>application.properties 配置文件内容：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">my.name</span><span class="token punctuation">=</span><span class="token value attr-value">mydlq</span><span class="token key attr-name">my.age</span><span class="token punctuation">=</span><span class="token value attr-value">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>使用 @Value 读取配置文件</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReadProperties</span> <span class="token punctuation">{</span>    <span class="token comment">//读取配置文件</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${my.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${my.age}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>        <span class="token comment">//读取系统环境参数</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{systemProperties['os.name']}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> systemPropertiesName<span class="token punctuation">;</span>    <span class="token comment">//读取bean对象属性</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        user<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token string">"18"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> user<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{user.name}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> value<span class="token punctuation">;</span>        <span class="token comment">//使用 SpEL 表达式</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"#{ T(java.lang.Math).random() * 100.0 }"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">double</span> random<span class="token punctuation">;</span>    <span class="token comment">//读取资源文件进行一些操作</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"classpath:application.properties"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Resource</span> resourceFile<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">// 如果文件存在，就输出文件名称</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>resourceFile<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>resourceFile<span class="token punctuation">.</span><span class="token function">getFilename</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-ConfigurationProperties-读取配置"><a href="#2-ConfigurationProperties-读取配置" class="headerlink" title="2.@ConfigurationProperties 读取配置"></a>2.@ConfigurationProperties 读取配置</h5><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">my.name</span><span class="token punctuation">=</span><span class="token value attr-value">mydlq</span><span class="token key attr-name">my.list[0]</span><span class="token punctuation">=</span><span class="token value attr-value">a</span><span class="token key attr-name">my.list[1]</span><span class="token punctuation">=</span><span class="token value attr-value">b</span><span class="token key attr-name">my.map.name</span><span class="token punctuation">=</span><span class="token value attr-value">xiao-li</span><span class="token key attr-name">my.map.sex</span><span class="token punctuation">=</span><span class="token value attr-value">man</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"my"</span><span class="token punctuation">)</span>   <span class="token comment">//配置 prefix 来过滤对应前缀</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigurationReadConfig</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>       <span class="token comment">//读取 List 类型参数</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list<span class="token punctuation">;</span>    <span class="token comment">//读取 Map 类型参数</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：使用 @ConfigurationProperties 注解读取配置，则需要配置文件内容中的参数添加统一的前缀，在 @ConfigurationProperties 注解中配置该前缀的值，然后前缀后的属性名要与加 @ConfigurationProperties 注解的类中成员变量名称保持一致。</p><p><strong>使用 @ConfigurationProperties 注解是默认从 application.properties 或者 application.yaml 中读取配置</strong>，将特定的配置放到单独的配置文件中，这时候需要 <strong>@PropertySource 与ConfigurationProperties</strong> 配置使用</p><ul><li>测试文件目录：resources/test.txt</li></ul><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">my.name</span><span class="token punctuation">=</span><span class="token value attr-value">mydlq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ConfigurationProperties</span><span class="token punctuation">(</span>prefix <span class="token operator">=</span> <span class="token string">"my"</span><span class="token punctuation">)</span><span class="token annotation punctuation">@PropertySource</span><span class="token punctuation">(</span>encoding <span class="token operator">=</span> <span class="token string">"UTF-8"</span><span class="token punctuation">,</span> ignoreResourceNotFound <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> value <span class="token operator">=</span> <span class="token string">"classpath:test.txt"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConfigurationReadConfig</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-使用-Environment-对象读取配置"><a href="#3-使用-Environment-对象读取配置" class="headerlink" title="3.使用 Environment 对象读取配置"></a>3.使用 Environment 对象读取配置</h5><p><strong>application.properties 配置文件内容：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">my.name</span><span class="token punctuation">=</span><span class="token value attr-value">mydlq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用 Environment 读取配置：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EnvironmentReadConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">Environment</span> environment<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>name <span class="token operator">=</span> environment<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"my.name"</span><span class="token punctuation">,</span> <span class="token string">"默认值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-使用-PropertiesLoaderUtils-读取配置"><a href="#4-使用-PropertiesLoaderUtils-读取配置" class="headerlink" title="4.使用 PropertiesLoaderUtils 读取配置"></a>4.使用 PropertiesLoaderUtils 读取配置</h5><p><strong>application.properties 配置文件内容：</strong></p><pre class="line-numbers language-properties" data-language="properties"><code class="language-properties"><span class="token key attr-name">my.name</span><span class="token punctuation">=</span><span class="token value attr-value">mydlq</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>使用 Environment 读取配置：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PropertiesReadConfig</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">ClassPathResource</span> resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span><span class="token string">"application.properties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token class-name">PropertiesLoaderUtils</span><span class="token punctuation">.</span><span class="token function">loadProperties</span><span class="token punctuation">(</span>resource<span class="token punctuation">)</span><span class="token punctuation">;</span>            name <span class="token operator">=</span> properties<span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">"my.name"</span><span class="token punctuation">,</span> <span class="token string">"默认值"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-6-SpringBoot-跨域问题"><a href="#1-6-SpringBoot-跨域问题" class="headerlink" title="1.6.SpringBoot 跨域问题"></a>1.6.SpringBoot 跨域问题</h4><p><strong>问题描述：</strong></p><p>跨域指的是浏览器在执行网页中的 JavaScript 代码时，由于<strong>浏览器同源策略的限制</strong></p><p>只能访问<strong>同源（协议、域名、端口号均相同）的资源</strong>，而不能访问其他源（协议、域名、 端口号任意一个不同）的资源.</p><p><img src="/././imgc/70.png"></p><p>比如像这样一种情况就体现了跨域的问题</p><p><img src="/././imgc/71.png"></p><p>常见的解决跨域问题的方法有两种，一种是 jsonp，另一种是 CORS。 </p><p>其中，<strong>CORS 是一种在服务器后端解决跨域的方案</strong></p><p><strong>工作原理:</strong> </p><p>如果一个网站需要访问另一个网站的资源，浏览器会先发送一个 OPTIONS 请求，根据服务器返回的 <strong>Access-Control-Allow-Origin 头信息</strong>，决定是否允许跨域访问。 </p><p>所以，我们只需要在<strong>服务器端配置 Access-Control-Allow-Origin 属性，并配置允许哪些域名支持跨域请求即可。</strong> </p><p>两种配置 Access-Control-Allow-Origin 属性的方式：</p><p>1.Controller类或方法上添加 @CrossOrigin 注解来配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@CrossOrigin</span><span class="token punctuation">(</span>origins <span class="token operator">=</span> <span class="token string">"http://example.com"</span><span class="token punctuation">)</span>   <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/my-endpoint"</span><span class="token punctuation">)</span>   <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">myEndpoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">// 处理请求逻辑</span>       <span class="token keyword">return</span> <span class="token string">"Response"</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>2.使用 WebMvcConfigurer 接口，重写 addCorsMappings 方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span><span class="token class-name">CorsRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{</span>        registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/api/**"</span><span class="token punctuation">)</span> <span class="token comment">// 指定需要进行跨域处理的请求路径</span>            <span class="token punctuation">.</span><span class="token function">allowedOrigins</span><span class="token punctuation">(</span><span class="token string">"http://example.com"</span><span class="token punctuation">)</span> <span class="token comment">// 允许的源</span>            <span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">)</span> <span class="token comment">// 允许的HTTP方法</span>            <span class="token punctuation">.</span><span class="token function">allowedHeaders</span><span class="token punctuation">(</span><span class="token string">"Authorization"</span><span class="token punctuation">,</span> <span class="token string">"Content-Type"</span><span class="token punctuation">)</span> <span class="token comment">// 允许的请求头</span>            <span class="token punctuation">.</span><span class="token function">allowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment">// 是否允许发送凭证信息（如cookies）</span>            <span class="token punctuation">.</span><span class="token function">maxAge</span><span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 预检请求的有效期（秒）</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果您只需要简单地配置跨域请求，并且没有其他复杂的需求，直接在配置文件中配置跨域属性更为方便。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token comment"># 允许所有源</span><span class="token key atrule">spring</span><span class="token punctuation">:</span>  <span class="token key atrule">webflux</span><span class="token punctuation">:</span>    <span class="token key atrule">cors</span><span class="token punctuation">:</span>      <span class="token key atrule">allowed-origins</span><span class="token punctuation">:</span> <span class="token string">"http://example.com"</span>​```<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-SpringBoot-热部署"><a href="#1-5-SpringBoot-热部署" class="headerlink" title="1.5.SpringBoot 热部署"></a>1.5.SpringBoot 热部署</h4><p><strong>概念：</strong></p><p>热部署（Hot Deployment）是指<strong>在应用程序运行时，对应用程序的代码、配置文件或资源进行更改后，无需重启应用程序就能够立即生效</strong>。这样可以加快开发和调试过程，提高开发效率。</p><p>热部署通常用于开发和调试阶段，以便快速验证更改的效果，而在生产环境中，通常会使用稳定的部署方式</p><p><strong>实现方式：</strong></p><p><strong>Spring Loaded：</strong><br>Spring Loaded是一个用于Java开发的热部署工具，特别针对Spring应用程序。</p><p>它可以在开发过程中实现对类的修改的快速重载，而无需重新启动应用程序。Spring Loaded能够监测类文件的更改，并在更改发生时重新加载修改后的类，从而实现类级别的热部署。它支持对Spring框架的核心组件和应用程序代码的重新加载。<br><strong>且从Spring Framework 4.3版本开始，它的功能已经被集成到spring-boot-devtools中。</strong></p><p><strong>spring-boot-devtools：</strong><br>spring-boot-devtools是Spring Boot提供的一个开发者工具模块，旨在提高开发人员的开发效率。它内置了许多功能，包括<strong>热部署、自动重启应用程序、自动刷新浏览器</strong>等。</p><p>使用 spring-boot-devtools 进行开发时，需要进行以下配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 其他依赖 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-devtools<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">&gt;</span></span>runtime<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-SpringBoot自动装配"><a href="#2-SpringBoot自动装配" class="headerlink" title="2.SpringBoot自动装配"></a>2.SpringBoot自动装配</h3><h4 id="2-1-Spring-Boot-自动装配是什么"><a href="#2-1-Spring-Boot-自动装配是什么" class="headerlink" title="2.1.Spring Boot 自动装配是什么"></a>2.1.Spring Boot 自动装配是什么</h4><p>SpringBoot 自动装配主要是<strong>基于注解编程</strong> 和 <strong>约定优于配置</strong>的思想来设计的</p><p>由 Spring 自动把其他组件中的 Bean 装载到 IoC 容器中，不需要开发人员再去配置文件中添加大量的配置。我们只需要在 Spring Boot 的启动类上添加 <strong>@SpringBootApplication</strong> 注解，开启自动装配。</p><p>在 Spring 3.x 以后，这种自动装配的思想就开始支持，我们只要在类上添加 @Enable注解就可以了，只是没有像 Spring Boot 这样全面地去设计。 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token annotation punctuation">@EnableScheduling</span><span class="token comment">// ...</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-2-自动装配原理"><a href="#2-2-自动装配原理" class="headerlink" title="2.2.自动装配原理"></a>2.2.自动装配原理</h4><p><strong>基本流程：</strong></p><p><strong>@EnableAutoConfiguration 注解通过@Import注解导入 ImportSelector 的子类 AutoConfigurationImportSelector 类</strong>，</p><p><strong>该类通过selectImports方法加载读取所有 spring-boot-autoconfigure 依赖下的spring.factories 配置文件的内容并由IOC容器注册为Bean</strong>。</p><h5 id="1-SpringBootApplication源码解析"><a href="#1-SpringBootApplication源码解析" class="headerlink" title="1 @SpringBootApplication源码解析"></a>1 @SpringBootApplication源码解析</h5><p>先看看springboot启动注解@SpringBootApplication</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//...</span><span class="token annotation punctuation">@SpringBootConfiguration</span><span class="token annotation punctuation">@EnableAutoConfiguration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>excludeFilters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">TypeExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span>type <span class="token operator">=</span> <span class="token class-name">FilterType</span><span class="token punctuation">.</span><span class="token constant">CUSTOM</span><span class="token punctuation">,</span> classes <span class="token operator">=</span> <span class="token class-name">AutoConfigurationExcludeFilter</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">SpringBootApplication</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> <span class="token class-name">EnableAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">exclude</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span>annotation <span class="token operator">=</span> <span class="token class-name">EnableAutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">excludeName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">//...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出@SpringBootApplication是由三个注解组成的</p><p><strong>1.@SpringBootConfiguration</strong></p><p><img src="/././imgc/72.png"></p><p>可以看出该注解内部就是@Configuration注解，<strong>用于标记springboot启动类为一个配置类</strong></p><p><strong>2.@ComponentScan</strong></p><p>是spring原生注解，其作用是<strong>扫描启动类所在的包以及子包所有Bean组件并注册到IOC容器中</strong></p><p><strong>3.@EnableAutoConfiguration</strong></p><p><img src="/././imgc/73.png"></p><p>实现<strong>自动装配的核心注解</strong>，可以看到该注解导通过@lmport注解入了<strong>AutoConfigurationlmportSelector</strong>类</p><h5 id="2-EnableAutoConfiguration源码解析"><a href="#2-EnableAutoConfiguration源码解析" class="headerlink" title="2. @EnableAutoConfiguration源码解析"></a>2. @EnableAutoConfiguration源码解析</h5><p>@EnableAutoConfiguration注解才是实现自动装配的核心注解，上面看了他的源码是通过**@Import**注解导入AutoConfigurationImportSelector类。</p><p>我们来看看AutoConfigurationImportSelector源码：</p><p><img src="/././imgc/75.png"></p><p><img src="/././imgc/74.png"></p><p>通过源码可知，<strong>AutoConfigurationImportSelector是ImportSelector的一个实现类</strong></p><p><strong>@Import的作用：</strong></p><p>用来导入配置类或者一些需要前置加载的类.</p><p>@Import可以通过以下方式导入一个bean：</p><ul><li>导入普通类</li><li>导入@Configuration配置类</li><li>导入ImportSelector实现类</li><li>导入ImportBeanDefinitionRegistrar实现类</li></ul><p><strong>其中ImportSelector 实现类的通过重写 selectImports方法返回的一个类全名的数组，spring容器根据这些类全名查找这些类并注册为bean</strong></p><p>AutoConfigurationImportSelector的selectImports：</p><p><img src="/././imgc/76.png"></p><p><strong>所以Import(AutoConfigurationImportSelector.class)就是返回的是要加载的Config配置文件的全包名列表</strong>，通过返回这个全包名列表，我们就能自动装配上这些配置文件下定义的bean对象，从而达到了自动装配的目的</p><p>具体加载流程呢？</p><p>我们发现<strong>autoConfigurationEntry</strong>中保存着我们需要的配置信息，它是通过<strong>getAutoConfigurationEntry</strong>方法获取的，于是我们继续深入，进入getAutoConfigurationEntry方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">AutoConfigurationEntry</span> <span class="token function">getAutoConfigurationEntry</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> annotationMetadata<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEnabled</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token constant">EMPTY_ENTRY</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">AnnotationAttributes</span> attributes <span class="token operator">=</span> <span class="token function">getAttributes</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> configurations <span class="token operator">=</span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span>                                                                  attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>configurations <span class="token operator">=</span> <span class="token function">removeDuplicates</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> exclusions <span class="token operator">=</span> <span class="token function">getExclusions</span><span class="token punctuation">(</span>annotationMetadata<span class="token punctuation">,</span> attributes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">checkExcludedClasses</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>configurations<span class="token punctuation">.</span><span class="token function">removeAll</span><span class="token punctuation">(</span>exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span>configurations <span class="token operator">=</span> <span class="token function">getConfigurationClassFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>configurations<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fireAutoConfigurationImportEvents</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">AutoConfigurationEntry</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span> exclusions<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关键代码：<strong>getCandidateConfigurations(annotationMetadata, attributes)</strong></p><p>获取候选配置信息，进入getCandidateConfigurations方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">getCandidateConfigurations</span><span class="token punctuation">(</span><span class="token class-name">AnnotationMetadata</span> metadata<span class="token punctuation">,</span> <span class="token class-name">AnnotationAttributes</span> attributes<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> configurations <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token function">getSpringFactoriesLoaderFactoryClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                                                    <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ImportCandidates</span><span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token class-name">AutoConfiguration</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span>                               <span class="token function">getBeanClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>configurations<span class="token operator">::</span><span class="token function">add</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notEmpty</span><span class="token punctuation">(</span>configurations<span class="token punctuation">,</span><span class="token string">"No auto configuration classes found in META-INF/spring.factories nor in META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports. If you "</span><span class="token operator">+</span> "are using a custom packaging<span class="token punctuation">,</span> make sure that file is                         correct<span class="token punctuation">.</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> configurations<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Assert断言中，我们发现了玄机No auto configuration classes found in META-INF/spring.factories</p><p>就是说在META-INF/spring.factories文件中没有找到自动配置类Config，你要检查。。。。</p><p>所以可以判断：</p><p><strong>List&lt; String&gt; configurations</strong>所存放的配置是在<strong>META-INF/spring.factories</strong>和<strong>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>所扫描到的配置文件。</p><p>事实如此吗？进入<strong>loadFactoryNames</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token function">loadFactoryNames</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> factoryType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">ClassLoader</span> classLoaderToUse <span class="token operator">=</span> classLoader<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>classLoader <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            classLoaderToUse <span class="token operator">=</span> <span class="token class-name">SpringFactoriesLoader</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">String</span> factoryTypeName <span class="token operator">=</span> factoryType<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token punctuation">)</span><span class="token function">loadSpringFactories</span><span class="token punctuation">(</span>classLoaderToUse<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>factoryTypeName<span class="token punctuation">,</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">emptyList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的<strong>loadSpringFactories</strong>方法</p><p><img src="/././imgc/77.png"></p><p>正是<strong>META-INF/spring.factories</strong></p><p>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports呢？</p><p><strong>在oadFactoryNames方法后还有ImportCandidates.load</strong></p><p>进入load</p><p><img src="/././imgc/78.png"></p><p>此处”<strong>META-INF/spring/%s.imports</strong>“就对应了META-<strong>INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong></p><p>到此，我们知道了</p><p><strong>List&lt; String&gt; configurations</strong>所存放<strong>META-INF/spring.factories</strong>和<strong>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</strong>路径的配置文件。</p><p>最终<strong>AutoConfigurationImportSelector的selectImports</strong>所返回的就是<strong>configurations</strong></p><h4 id="2-3-结论"><a href="#2-3-结论" class="headerlink" title="2.3.结论"></a>2.3.结论</h4><p>SpringBoot自动装配的本质就是通过Spring去读取<strong>META-INF/spring.factories</strong>中保存的配置类文件然后加载bean定义的过程。</p><ul><li><strong>通过 SpringBoot 中的约定优于配置思想，把这个配置类的全路径放在 classpath:/META-INF/spring.factories 文件中。这样 SpringBoot 就可以知道第三方 jar 包里面的配置类的位置，</strong></li><li><strong>SpringBoot 拿到所第三方 jar 包里面声明的配置类以后，再通过 Spring 提供的ImportSelector 接口，实现对这些配置类的动态加载</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 延迟加载</title>
      <link href="/2023/09/10/mybatis-yan-chi-jia-zai/"/>
      <url>/2023/09/10/mybatis-yan-chi-jia-zai/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-延迟加载"><a href="#MyBatis-延迟加载" class="headerlink" title="MyBatis 延迟加载"></a>MyBatis 延迟加载</h2><h3 id="1-什么是延迟加载"><a href="#1-什么是延迟加载" class="headerlink" title="1.什么是延迟加载"></a>1.什么是延迟加载</h3><p>简单的来说就是，<strong>在需要用到数据的时候进行加载，不需要用到数据就不进行加载</strong></p><p>假设数据库中涉及两张表，用户表AND订单表（一对多的关系），假设一个有很多订单，那么在查询用户的时候，需不需要当前用户关联的订单数据查询出来？</p><p>通常来说查询用户信息的时候，肯定是<strong>在需要用到用户订单的时候在查询为好</strong>，尤其是一对多的多表查询，通常都建议采用延迟加载，因为单表查询肯定要比多表关联查询速度要快，<strong>先从单表查询，接着需要时在关联表进行关联查询，会提高数据库性能</strong></p><h3 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2.如何使用"></a>2.如何使用</h3><p>MyBatis默认不启用延迟加载，启用延迟加载则需要我们进行一配置即可。</p><p>配置文件中设置setting属性 设置<strong>全局懒加载</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>       <span class="token comment">&lt;!-- 开启全局延迟加载,默认值是true --&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lazyLoadingEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>       <span class="token comment">&lt;!-- 设置全局积极懒加载,默认值是true --&gt;</span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>aggressiveLazyLoading<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>false<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者在mapper配置文件中配置fetchType标签 设置<strong>局部懒加载</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token operator">&lt;</span>resultMap id<span class="token operator">=</span><span class="token string">"userMap"</span> type<span class="token operator">=</span><span class="token string">"com.mryan.pojo.User"</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>id property<span class="token operator">=</span><span class="token string">"id"</span> column<span class="token operator">=</span><span class="token string">"id"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>id<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>result property<span class="token operator">=</span><span class="token string">"username"</span> column<span class="token operator">=</span><span class="token string">"username"</span><span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>result<span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>fetchType<span class="token operator">=</span><span class="token string">"lazy"</span>  懒加载策略  fetchType<span class="token operator">=</span><span class="token string">"eager"</span>  立即加载策略 <span class="token operator">--</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span>collection property<span class="token operator">=</span><span class="token string">"orderList"</span> ofType<span class="token operator">=</span><span class="token string">"com.mryan.pojo.Order"</span>                select<span class="token operator">=</span><span class="token string">"com.mryan.mapper.IOrderMapper.findOrderByUid"</span> column<span class="token operator">=</span><span class="token string">"id"</span> fetchType<span class="token operator">=</span><span class="token string">"lazy"</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>id property<span class="token operator">=</span><span class="token string">"id"</span> column<span class="token operator">=</span><span class="token string">"uid"</span><span class="token operator">/</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>result property<span class="token operator">=</span><span class="token string">"orderTime"</span> column<span class="token operator">=</span><span class="token string">"ordertime"</span><span class="token operator">/</span><span class="token operator">&gt;</span>        <span class="token operator">&lt;</span>result property<span class="token operator">=</span><span class="token string">"total"</span> column<span class="token operator">=</span><span class="token string">"total"</span><span class="token operator">/</span><span class="token operator">&gt;</span>    <span class="token operator">&lt;</span><span class="token operator">/</span>collection<span class="token operator">&gt;</span><span class="token operator">&lt;</span><span class="token operator">/</span>resultMap<span class="token operator">&gt;</span><span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"findOrderByUid"</span> resultType<span class="token operator">=</span><span class="token string">"com.mryan.pojo.Order"</span><span class="token operator">&gt;</span>select <span class="token operator">*</span>from orderswhere uid <span class="token operator">=</span> #<span class="token punctuation">{</span>uid<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此处指定了用户的订为懒加载</p><p><strong>测试：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>    <span class="token comment">// 用户关联的订单数据</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Order</span><span class="token punctuation">&gt;</span></span> orderList<span class="token punctuation">;</span><span class="token comment">//省略</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Order</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Integer</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> orderTime<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Double</span> total<span class="token punctuation">;</span>    <span class="token comment">// 表明该订单属于哪个用户</span>    <span class="token keyword">private</span> <span class="token class-name">User</span> user<span class="token punctuation">;</span><span class="token comment">//省略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>单元测试，试一下延迟加载是否生效</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TEST_QUERY_LAZY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">{</span>        <span class="token class-name">InputStream</span> inputStream<span class="token operator">=</span><span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"sqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSessionFactory</span> factory<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSession</span> sqlSession<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User</span> user<span class="token operator">=</span>sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">"com.mryan.mapper.IUserMapper.findById"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//延迟加载生效 下方输出语句 不涉及到orders表 于是不会打印orders相关日志</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user："</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//涉及orders表 才会执行相关SQL语句 加载orders执行日志 （延迟加载 什么时候用什么时候查）</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orders："</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getOrderList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/././imgc/65.png"></p><p>可以发现user.getUsername()的时候只触发了查询用户的sql语句，而user.getOrderList()时才触发了查询订单的sql语句,延迟加载生效。</p><h3 id="3-原理解析"><a href="#3-原理解析" class="headerlink" title="3.原理解析"></a>3.原理解析</h3><p>了解一下SQL语句执行的大致流程：</p><p>SQL查询语句的执行是由SqlSession分发交由Executor托管执行，调StatementHandler负责JDBC statement操作，之后下发给ParameterHandler负责对用户传递参数进行转化处理SQL参数，再接着执行SQL语句，最后通过ResultSetHandler对返回结果进行封装处理返回。</p><p><strong>基本原理：</strong></p><p><strong>通过最后的ResultSetHandler对结果封装处理返回的时候，根据调用的getting方法的实例名称，来相对应的加载目标对象，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法</strong>，将启用了延迟加载并且是getting方法，那么执行load加载（就是去执行一次SQL查询方法将结果set到代理对象中）</p><p>比如调 用a.getB().getName()，拦截器invoke()方法发现<strong>a.getB()是null值</strong>，那么就会单独发送事先保存好的查询关联B对象的sql，<strong>把B查询上来，然后调用a.setB(b)<strong>，于是a的对象b属性就有值了，</strong>接着完成a.getB().getName()方法的调用。</strong></p><p><strong>源码剖析：</strong></p><p>在执行完SQL查询语句后处理封装结果集的核心代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 处理 {@link java.sql.ResultSet} 结果集</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleResultSets</span><span class="token punctuation">(</span><span class="token class-name">Statement</span> stmt<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>      <span class="token comment">// 多ResultSet的结果集合，每个 ResultSet 对应一个Object 对象。而实际上，每个Object 是List&lt;Object&gt; 对象。</span>    <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> multipleResults <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> resultSetCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment">// 获得首个ResultSet对象，并封装成ResultSetWrapper对象</span>    <span class="token class-name">ResultSetWrapper</span> rsw <span class="token operator">=</span> <span class="token function">getFirstResultSet</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 获得ResultMap数组</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResultMap</span><span class="token punctuation">&gt;</span></span> resultMaps <span class="token operator">=</span> mappedStatement<span class="token punctuation">.</span><span class="token function">getResultMaps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> resultMapCount <span class="token operator">=</span> resultMaps<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">validateResultMapsCount</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMapCount<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 校验</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>rsw <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> resultMapCount <span class="token operator">&gt;</span> resultSetCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 获得ResultMap对象</span>        <span class="token class-name">ResultMap</span> resultMap <span class="token operator">=</span> resultMaps<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>resultSetCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 处理 ResultSet ，将结果添加到multipleResults中</span>        <span class="token function">handleResultSet</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> multipleResults<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 获得下一个 ResultSet 对象，并封装成 ResultSetWrapper 对象</span>        rsw <span class="token operator">=</span> <span class="token function">getNextResultSet</span><span class="token punctuation">(</span>stmt<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 清理</span>        <span class="token function">cleanUpAfterHandlingResultSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// resultSetCount ++</span>        resultSetCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment">//...</span>        <span class="token keyword">return</span> <span class="token function">collapseSingleResultList</span><span class="token punctuation">(</span>multipleResults<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>关键点：handleResultSet(rsw, resultMap, multipleResults, null)</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 处理 ResultSet ，将结果添加到 multipleResults 中</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">handleResultSet</span><span class="token punctuation">(</span><span class="token class-name">ResultSetWrapper</span> rsw<span class="token punctuation">,</span> <span class="token class-name">ResultMap</span> resultMap<span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> multipleResults<span class="token punctuation">,</span> <span class="token class-name">ResultMapping</span> parentMapping<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment">//...</span>                <span class="token comment">// 如果没有自定义的 resultHandler，则创建默认的 DefaultResultHandler</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>resultHandler <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">DefaultResultHandler</span> defaultResultHandler <span class="token operator">=</span> <span class="token keyword">new</span>                         <span class="token class-name">DefaultResultHandler</span><span class="token punctuation">(</span>objectFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 核心代码！！！ 处理ResultSet返回的每一行Row</span>                    <span class="token function">handleRowValues</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> defaultResultHandler<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span>                                     <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 添加defaultResultHandler的处理的结果，到multipleResults中</span>                    multipleResults<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>defaultResultHandler<span class="token punctuation">.</span><span class="token function">getResultList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment">//核心代码！！！ 处理ResultSet返回的每一行 Row</span>                    <span class="token function">handleRowValues</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span> resultMap<span class="token punctuation">,</span> resultHandler<span class="token punctuation">,</span> rowBounds<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token comment">//...</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>                       <span class="token comment">// 关闭 ResultSet 对象</span>            <span class="token function">closeResultSet</span><span class="token punctuation">(</span>rsw<span class="token punctuation">.</span><span class="token function">getResultSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键点：handleRowValues(rsw, resultMap, defaultResultHandler, rowBounds, null);</strong></p><p>由于handleRowValues方法处理ResultSet返回的每一行Row,**调用了createResultObject()**方法创建结果对象，是在这个方法中完成了懒加载相关处理逻辑。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 创建映射后的结果对象</span>  <span class="token keyword">private</span> <span class="token class-name">Object</span> <span class="token function">createResultObject</span><span class="token punctuation">(</span><span class="token class-name">ResultSetWrapper</span> rsw<span class="token punctuation">,</span> <span class="token class-name">ResultMap</span> resultMap<span class="token punctuation">,</span> <span class="token class-name">ResultLoaderMap</span> lazyLoader<span class="token punctuation">,</span> <span class="token class-name">String</span> columnPrefix<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>       <span class="token comment">//...</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>resultObject <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">hasTypeHandlerForResultObject</span><span class="token punctuation">(</span>rsw<span class="token punctuation">,</span>                                                                  resultMap<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">{</span>          <span class="token comment">// 如果有内嵌的查询，并且开启延迟加载，则创建结果对象的代理对象</span>          <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ResultMapping</span><span class="token punctuation">&gt;</span></span> propertyMappings <span class="token operator">=</span>               resultMap<span class="token punctuation">.</span><span class="token function">getPropertyResultMappings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">ResultMapping</span> propertyMapping <span class="token operator">:</span> propertyMappings<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// issue gcode #109 &amp;&amp; issue #149</span>              <span class="token comment">//如果当前开启懒加载配置</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>propertyMapping<span class="token punctuation">.</span><span class="token function">getNestedQueryId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span>                   propertyMapping<span class="token punctuation">.</span><span class="token function">isLazy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment">//创建代理对象</span>                  resultObject <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getProxyFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span>resultObject<span class="token punctuation">,</span> lazyLoader<span class="token punctuation">,</span> configuration<span class="token punctuation">,</span> objectFactory<span class="token punctuation">,</span> constructorArgTypes<span class="token punctuation">,</span> constructorArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">break</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment">// 判断是否使用构造方法创建该结果对象</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>useConstructorMappings <span class="token operator">=</span> resultObject <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>constructorArgTypes<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// set current mapping result</span>      <span class="token keyword">return</span> resultObject<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定位到这里，就可以知道：</p><p><strong>创建映射后的结果对象流程中会判断是否开启了延迟加载配置，如果开启了延迟加载配置会创建一个代理对象，将结果返回。</strong></p><p><strong>为什么需要创建一个代理对象呢？</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token comment">/*    测试 延迟加载查询   */</span><span class="token annotation punctuation">@Test</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">TEST_QUERY_LAZY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">{</span>        <span class="token class-name">InputStream</span> inputStream<span class="token operator">=</span><span class="token class-name">Resources</span><span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token string">"sqlMapConfig.xml"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSessionFactory</span> factory<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">SqlSessionFactoryBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">SqlSession</span> sqlSession<span class="token operator">=</span>factory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">User</span> user<span class="token operator">=</span>sqlSession<span class="token punctuation">.</span><span class="token function">selectOne</span><span class="token punctuation">(</span><span class="token string">"com.mryan.mapper.IUserMapper.findById"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//下方输出语句 不涉及到orders表 于是不会打印orders相关日志</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"user："</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//延迟加载生效 涉及orders表 才会执行相关SQL语句 加载orders执行日志 （延迟加载 什么时候用什么时候查）</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"orders："</span><span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getOrderList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在执行完sqlSession.selectOne语句之后，<strong>如果创建了一个代理对象，动态的判断代理对象的getting方法是否是需要延迟加载的局部属性</strong>。</p><p>例如getOrderList被判定延迟加载配置生效进入代理对象拦截器方法，那么就会单独发送实现保存好的查询语句将orderList查询上来，然后通过反射将orderList设置进去，然后完成getorderList的调用</p><p>代理类的拦截方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>       <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> enhanced<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Method</span> methodProxy<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token constant">FINALIZE_METHOD</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                           <span class="token comment">// 加载所有延迟加载的属性</span>                           <span class="token keyword">if</span> <span class="token punctuation">(</span>aggressive <span class="token operator">||</span>                                lazyLoadTriggerMethods<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                               lazyLoader<span class="token punctuation">.</span><span class="token function">loadAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                           <span class="token comment">// 如果调用了 setting 方法，则不在使用延迟加载</span>                           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">PropertyNamer</span><span class="token punctuation">.</span><span class="token function">isSetter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                               <span class="token keyword">final</span> <span class="token class-name">String</span> property <span class="token operator">=</span>                                    <span class="token class-name">PropertyNamer</span><span class="token punctuation">.</span><span class="token function">methodToProperty</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                               lazyLoader<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移除</span>                           <span class="token comment">// 如果调用了 getting 方法，则执行延迟加载</span>                           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">PropertyNamer</span><span class="token punctuation">.</span><span class="token function">isGetter</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                               <span class="token keyword">final</span> <span class="token class-name">String</span> property <span class="token operator">=</span>                                    <span class="token class-name">PropertyNamer</span><span class="token punctuation">.</span><span class="token function">methodToProperty</span><span class="token punctuation">(</span>methodName<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token keyword">if</span> <span class="token punctuation">(</span>lazyLoader<span class="token punctuation">.</span><span class="token function">hasLoader</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                                   lazyLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">;</span>                               <span class="token punctuation">}</span>                           <span class="token punctuation">}</span>                       <span class="token punctuation">}</span>                   <span class="token punctuation">}</span>               <span class="token punctuation">}</span>               <span class="token comment">// 继续执行原方法</span>               <span class="token keyword">return</span> methodProxy<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>enhanced<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">throw</span> <span class="token class-name">ExceptionUtil</span><span class="token punctuation">.</span><span class="token function">unwrapThrowable</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在拦截方法中，判断了当前执行的方法是否拥有延迟加载属性，如果<strong>启用了延迟加载并且是getting方法，那么执行load加载方法</strong>.</p><p>而load加载方法其实也就是<strong>去执行一次SQL查询方法将结果set到代理对象中</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">load</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">Object</span> userObject<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>metaResultObject <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resultLoader <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//省略代码</span>                <span class="token comment">// 获得 Configuration 对象</span>                <span class="token keyword">final</span> <span class="token class-name">Configuration</span> config <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获得 MappedStatement 对象</span>                <span class="token keyword">final</span> <span class="token class-name">MappedStatement</span> ms <span class="token operator">=</span>                     config<span class="token punctuation">.</span><span class="token function">getMappedStatement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>mappedStatement<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 获得对应的 MetaObject 对象</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>metaResultObject <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">newMetaObject</span><span class="token punctuation">(</span>userObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 创建 ResultLoader 对象</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>resultLoader <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ResultLoader</span><span class="token punctuation">(</span>config<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ClosedExecutor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ms<span class="token punctuation">,</span>                                                      <span class="token keyword">this</span><span class="token punctuation">.</span>mappedParameter<span class="token punctuation">,</span>                        metaResultObject<span class="token punctuation">.</span><span class="token function">getSetterType</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>property<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token comment">//关键代码！！resultLoader.loadResult();</span>       <span class="token comment">//最终通过setValue方法将加载结果设置到代理对象中。</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>metaResultObject<span class="token punctuation">.</span><span class="token function">setValue</span><span class="token punctuation">(</span>property<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>resultLoader<span class="token punctuation">.</span><span class="token function">loadResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token comment">//resultLoader.loadResult() 去主动调用了一次查询方法并将结果进行提取</span> <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">loadResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>        <span class="token comment">// 查询结果</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token function">selectList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 提取结果</span>        resultObject <span class="token operator">=</span> resultExtractor<span class="token punctuation">.</span><span class="token function">extractObjectFromList</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> targetType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 返回结果</span>        <span class="token keyword">return</span> resultObject<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>总结：</p><ul><li><strong>延迟加载主要就是通过动态代理模式实现，通过代理拦截指定方法，</strong></li><li><strong>动态的判断代理对象的getting方法是否是需要延迟加载的局部属性</strong></li><li><strong>如果是那么执行load加载方法而load加载方法就是去执行一次SQL查询方法将结果set到代理对象中</strong></li><li><strong>从而现用现查，将结果设置到代理对象中返回，执行数据加载</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 基础篇</title>
      <link href="/2023/09/10/mybatis-ji-chu-pian/"/>
      <url>/2023/09/10/mybatis-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="MyBatis-基础篇"><a href="#MyBatis-基础篇" class="headerlink" title="MyBatis 基础篇"></a>MyBatis 基础篇</h2><h3 id="1-MyBatis概述"><a href="#1-MyBatis概述" class="headerlink" title="1.MyBatis概述"></a>1.MyBatis概述</h3><h4 id="1-1-什么是Mybatis"><a href="#1-1-什么是Mybatis" class="headerlink" title="1.1.什么是Mybatis"></a>1.1.什么是Mybatis</h4><ul><li>Mybatis是一个半<strong>ORM</strong>（对象关系映射）框架，它内部<strong>封装了JDBC</strong>，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li><li>MyBatis 可以使用 <strong>XML 或注解来配置和映射原生信息</strong>，将 POJO映射成数据库中的记录，避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 </li><li>通过xml 文件或注解的方式将要执行的各种 statement 配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架<strong>执行sql并将结果映射为java对象并返回（从执行sql到返回result的过程）。</strong></li></ul><p><strong>ORM:</strong></p><p>ORM（Object Relational Mapping），对象关系映射是一种为了解决关系型数据库数据与简单Java对 象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，<strong>将程序中的对象自动持久化到关系型数据库中</strong>。</p><p><strong>半ORM:</strong></p><p>Mybatis在<strong>查询关联对象或关联集合对象时，需要手动编写sql来完成</strong>，所以，称之为半自动ORM映射工具。使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。  </p><h4 id="1-2-为什么是Mybaits"><a href="#1-2-为什么是Mybaits" class="headerlink" title="1.2. 为什么是Mybaits"></a>1.2. 为什么是Mybaits</h4><ol><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。 </li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接； </li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。 </li><li>能够与Spring很好的集成； </li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护。</li></ol><p> <strong>JDBC编程有哪些不足之处，MyBatis是如何解决的：</strong></p><p>1、<strong>数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能</strong>，如果使用数据库连接池可解决此题。<br>解决：<strong>在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</strong></p><p>2、<strong>Sql语句写在代码中造成代码不易维护</strong>，实际应用sql变化的可能较大，sql变动需要改变java代码。<br>解决：<strong>将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</strong></p><p>3、<strong>向sql语句传参数麻烦</strong>，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一<br>对应。<br>解决： <strong>Mybatis自动将java对象映射至sql语句。</strong></p><p>4、<strong>对结果集解析麻烦</strong>，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。<br>解决：<strong>Mybatis自动将sql执行结果映射至java对象。</strong></p><h4 id="1-3-Mybatis功能架构"><a href="#1-3-Mybatis功能架构" class="headerlink" title="1.3.Mybatis功能架构"></a>1.3.Mybatis功能架构</h4><p>Mybatis的功能架构分为三层： </p><p><img src="/././imgc/60.png"></p><ul><li><strong>API接口层</strong>：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。 </li><li><strong>数据处理层</strong>：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。 </li><li><strong>基础支撑层</strong>：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><p><strong>主要组件及其关系：</strong></p><p><img src="/././imgc/66.png"></p><ul><li><strong>SqlSession</strong>：作为MyBatis⼯作的主要顶层API，表示和数据库交互的会话，完成必要数 据库增删改查功能。</li><li><strong>Executor</strong>：调度执行StatementHandler、ParameterHandler、ResultHandler执行相应的SQL语句</li><li><strong>StatementHandler</strong>：封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数、将Statement结果集转换成List集合。</li><li><strong>ParameterHandler</strong>：负责对用户传递的参数转换成JDBC Statement所需要的参数。处理SQL参数。</li><li><strong>ResultSetHandler</strong>：结果集ResultSet封装处理返回。</li><li><strong>TypeHandler</strong>：负责java数据类型和jdbc数据类型之间的映射和转换。</li><li><strong>MappedStatement</strong>：MappedStatement维护了⼀条＜select | update | delete | insert＞节点的封装。</li><li><strong>SqlSource</strong>：负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回。</li><li><strong>BoundSql</strong>：表示动态生成的SQL语句以及相应的参数信息。</li></ul><p><strong>Dao 接口，就是Mapper 接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中 MappedStatement 的 id 值，接口方法内的参数，就是传递给 sql 的参数。</strong> </p><p>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个 MappedStatement </p><p>在 MyBatis 中，每一个 &lt;select…&gt; 标签，都会被解析为一个 MappedStatement 对象。</p><p><strong>执行SQL语句的大致流程为：</strong></p><ol><li>加载配置，以XML为例，将主配置文件内容解析到Configuration中，将SQL配置信息加载成为多个<strong>MapperdStatement</strong>对象，存入内存中。</li><li>接口层调用MyBatis提供的API 传入参数对象，将请求传递给下层的数据处理层进行处理。</li><li>简单的来说数据处理层完成的任务如下：<ul><li>Parameterhandler完成参数映射（参数映射配置，参数映射 类型解析）根据SQL的ID搜寻对应的MappedStatement对象，根据传入的参数对象解析MappedStatement对象，SqlSource做SQL语句解析，动态SQL生成，获取需要执行的SQL语句和执行必要参数。</li><li>Executor执行SQL语句，获取数据库连接，根据得到的最终SQL语句和执行传入参数到数据库执行，并得到执行结果。</li><li>根据MappedStatement对象中的结果映射配置对得到的执行结果ResultSetHandler进行转换处理，并得到最终的处理结果。释放连接资源。最终将ResultSet结果集逐层返回。</li></ul></li></ol><h4 id="1-4-Executor执行器"><a href="#1-4-Executor执行器" class="headerlink" title="1.4.Executor执行器"></a>1.4.Executor执行器</h4><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor</strong>。</p><ul><li><strong>SimpleExecutor</strong>：简单执行器，每个语句都会创建一个新的PreparedStatement对象，不进行二级缓存。<strong>适用于小型应用或对性能要求不高的场景。</strong></li><li><strong>ReuseExecutor</strong>：重用执行器，执行器会重用预处理语句（PreparedStatement），可以缓存多个语句的预处理语句，但不支持二级缓存。<strong>适用于多次执行相同或类似语句的场景。</strong></li><li><strong>BatchExecutor</strong>：批处理执行器，执行器使用JDBC的批处理语句（batch）执行多个语句，可以提高批量操作的性能。<strong>适用于批量插入、更新或删除等场景。</strong></li></ul><p><strong>如何指定：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>defaultExecutorType<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>REUSE<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>  ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">Configuration</span> configuration <span class="token operator">=</span> sqlSession<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>configuration<span class="token punctuation">.</span><span class="token function">setDefaultExecutorType</span><span class="token punctuation">(</span><span class="token class-name">ExecutorType</span><span class="token punctuation">.</span><span class="token constant">REUSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//或者建SqlSession的方法传递ExecutorType类型参数</span><span class="token class-name">SqlSession</span> sqlSession <span class="token operator">=</span> sqlSessionFactory<span class="token punctuation">.</span><span class="token function">openSession</span><span class="token punctuation">(</span><span class="token class-name">ExecutorType</span><span class="token punctuation">.</span><span class="token constant">REUSE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-5-与Hibernate的异同"><a href="#1-5-与Hibernate的异同" class="headerlink" title="1.5.与Hibernate的异同"></a>1.5.与Hibernate的异同</h4><p><strong>相同点</strong> </p><p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。 </p><p><strong>不同点</strong> </p><p>映射关系 </p><p>MyBatis 是一个<strong>半自动映射</strong>的框架，配置Java对象与sql语句执行结果的对应关系，<strong>多表关联关系配置简单</strong> </p><p>Hibernate 是一个<strong>全表映射</strong>的框架，配置Java对象与数据库表的对应关系，<strong>多表关联关系配置复杂</strong> </p><p><strong>SQL优化和移植性</strong> </p><p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。 </p><p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性（<strong>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</strong>），但sql语句优化容易。</p><h3 id="2-MyBatis缓存机制"><a href="#2-MyBatis缓存机制" class="headerlink" title="2.MyBatis缓存机制"></a>2.MyBatis缓存机制</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1.概念"></a>2.1.概念</h4><ul><li><p>基本概念：MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地配置和定制。</p></li><li><p>作用：缓存可以极大的提升查询效率。</p></li><li><p>分类：MyBatis系统中默认定义了两级缓存，分别是<strong>一级缓存和二级缓存。</strong></p></li><li><p>基本介绍：</p><p>① 默认情况下，只有一级缓存（<strong>SqlSession</strong>级别的缓存，也称为本地缓存）开启。</p><p>② 二级缓存需要手动开启和配置，他是基于<strong>namespace</strong>级别的缓存。</p><p>③ 为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存。</p></li></ul><p><img src="/././imgc/62.png"></p><p><strong>SqlSession：</strong></p><ul><li><strong>SqlSession级别的缓存，缓存的数据只在SqlSession内有效</strong></li><li>SqlSession 是 MyBatis 中与数据库进行交互的主要接口。</li><li><strong>作用范围是一次数据库会话</strong>，通常，每个数据库操作都应该在一个独立的 SqlSession中进行。</li><li>在一个 SqlSession 中，可以执行多个数据库操作，并且 MyBatis 会自动管理事务的提交和回滚。</li></ul><p><strong>Namespace ：</strong></p><ul><li><strong>同一个namespace公用这一个缓存，所以对SqlSession是共享的。</strong></li><li>Namespace 是用于组织和管理 SQL 映射语句的概念。</li><li><strong>每个 Mapper 接口都应该有一个对应的 Namespace</strong>。</li><li>Namespace 的作用是在 XML 映射文件中定义与该 Mapper 接口相关的 SQL 映射语句。</li><li>通过 Namespace，可以在代码中通过 Mapper 接口的方法来执行对应的 SQL 语句。</li></ul><h4 id="2-2-一级缓存"><a href="#2-2-一级缓存" class="headerlink" title="2.2.一级缓存"></a>2.2.一级缓存</h4><p><strong>基本概念：</strong></p><p>是基于 <strong>SqlSession 级别</strong>的缓存，也叫本地缓存且是<strong>默认开启</strong>，因为每个用户在执行查询的时候都需要使用 SqlSession 来执行。</p><p>在应用运行过程中，我们有可能<strong>在一次数据库会话中，执行多次查询条件完全相同SQL</strong>，MyBatis 提供了一级缓存的方案优化这部分场景，如果是相同的 SQL 语句，会优先命中一级缓存，避免直接对数据库进行查询，提高性能。</p><p><strong>基本原理：</strong></p><p>在每个 SqlSession 中持有了 <strong>Executor</strong>，每个 Executor 中有一个 <strong>LocalCache</strong>。</p><p>当用户发起查询时，MyBatis 根据当前执行的语句生成 MappedStatement，在 Local Cache 进行查询，<strong>如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入 Local Cache</strong>，最后返回结果给用户。具体实现类的类关系图如下图所示： </p><p><img src="/././imgc/63.png"></p><p>所以在多个 Sqlsession 或者分布式环境下， 可能会导致数据库写操作出现脏数据，Mybatis就提供了二级缓存。</p><h4 id="2-3-二级缓存"><a href="#2-3-二级缓存" class="headerlink" title="2.3.二级缓存"></a>2.3.二级缓存</h4><p><strong>基本概念：</strong></p><p>二级缓存是基于<strong>namespace（mapper接口）</strong>，不同的SQLSession可以访问二级缓存的内容就是当多个用户在查询数据的时候，只要有任何一个 SqlSession 拿到了数据就会放入到二级缓存里面，其他的 SqlSession 就可以从二级缓存加载数据，<strong>实现了 SqlSession 之间缓存数据的共享</strong>。</p><p><strong>如何开启：</strong></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>  <span class="token comment">&lt;!-- 其他配置项 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>settings</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>setting</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>cacheEnabled<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>settings</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 其他配置项 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>开启二级缓存后，还需要在对应的 Mapper 接口上进行配置，才能使该 Mapper 接口的查询结果被缓存。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>mapper</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache-ref</span> <span class="token attr-name">namespace</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.mapper.UserMapper<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>    <span class="token comment">&lt;!-- 其他 SQL 映射配置 --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>mapper</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>POJO需要实现序列化接口</p><p>SqlSession对象关闭或提交之后，⼀级缓存中的数据才会被写⼊到⼆级缓存当中</p><p><strong>基本原理：</strong></p><p>使用 <strong>CachingExecutor 装饰了 Executor</strong>，所以在进入一级缓存的查询流程之前，会先通过 CachingExecutor 进行二级缓存的查询。 </p><p>开启二级缓存以后，会<strong>被多个 SqlSession 共享，所以它是一个全局缓存</strong>。因此它的查询流程是<strong>先查二级缓存，再查一级缓存，最后再查数据库</strong></p><p><img src="/././imgc/64.png"></p><p>并且还可以通过 Cache 接口实现类不同的组合，对 Cache 的可控性也更强</p><p>简单的示例代码</p><p>1.需要创建一个实现Cache接口的自定义缓存类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>ibatis<span class="token punctuation">.</span>cache<span class="token punctuation">.</span></span><span class="token class-name">Cache</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">LinkedHashMap</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FIFOCache</span> <span class="token keyword">implements</span> <span class="token class-name">Cache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> id<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> cache<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">FIFOCache</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> id<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> id<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">,</span> <span class="token class-name">Object</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">removeObject</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该类使用了一个LinkedHashMap作为缓存的存储容器，它按照插入顺序维护缓存中的对象。这意味着当缓存空间不足时，最早插入的对象会被移除，以腾出空间给新的对象</p><p>2.在MyBatis的配置文件中配置使用我们的自定义缓存类</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 其他配置项 --&gt;</span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environments</span> <span class="token attr-name">default</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>environment</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>development<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>transactionManager</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>JDBC<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token comment">&lt;!-- 事务管理器配置 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>transactionManager</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dataSource</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POOLED<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                <span class="token comment">&lt;!-- 数据源配置 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dataSource</span><span class="token punctuation">&gt;</span></span>                        <span class="token comment">&lt;!-- 配置使用自定义缓存类 --&gt;</span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cache</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.example.FIFOCache<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environment</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>environments</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在分布式环境下，由于默认的 MyBatis Cache 实现都是基于本地的，分布式环境下必然会出现读取到脏数据，需要使用集中式缓存将 MyBatis 的 Cache 接口实现，有一定的开发成本，直接使用 Redis，Memcached 等分布式缓存可能成本更低，安全性也更高。</p>]]></content>
      
      
      <categories>
          
          <category> MyBatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring AOP</title>
      <link href="/2023/09/07/spring-aop/"/>
      <url>/2023/09/07/spring-aop/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><h3 id="1-什么是Spring-AOP"><a href="#1-什么是Spring-AOP" class="headerlink" title="1.什么是Spring AOP"></a>1.什么是Spring AOP</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1.基本概念"></a>1.1.基本概念</h4><p>AOP（Aspect-Oriented Programming，<strong>面向切面编程</strong>）能够将那些与业务无关，却为业务模块所 </p><p>共同调用的逻辑或责任（例如<strong>事务处理、日志管理、权限控制</strong>等）封装起来，便于减少系统的重复 </p><p>代码，<strong>降低模块间的耦合度，并有利于未来的可扩展性和可维护性</strong>。</p><p>而 Spring AOP 是⼀个框架，提供了⼀种对 AOP 思想的实现，它们的关系和 IoC 与 DI 类似。</p><p>Spring AOP是基于<strong>动态代理</strong>的:</p><ul><li>代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理去创建代理对象；</li><li>而对于没有实现接口的对象，转而使用CGlib动态代理生成一个被代理对象的子类来作为代理。</li></ul><p><img src="/././imgc/50.png"></p><h4 id="1-2-组成"><a href="#1-2-组成" class="headerlink" title="1.2.组成"></a>1.2.组成</h4><p>1、<strong>切面（Aspect）</strong>：被抽取的公共模块，可能会横切多个对象。 在Spring AOP中，切面可以使用通用<br>类（基于模式的风格）或者在普通类中以 @AspectJ 注解来实现。</p><p>2、<strong>连接点（Join point）</strong>：指方法，在Spring AOP中，一个连接点 总是代表一个方法的执行。</p><p>3、<strong>通知（Advice）</strong>：在切面的某个特定的连接点（Join point）上执行的动作。</p><ul><li>​before(前置通知)</li><li>​after(后置通知)</li><li>​after-returning(返回后通知)</li><li>​after-throwing(抛出异常通知)</li><li>​around(环绕通知)</li></ul><p>4、<strong>切入点（Pointcut）</strong>：切入点是指 我们要对哪些Join point进行拦截的定义。通过切入点表达式，指<br>定拦截的方法，比如指定拦截add、search。</p><p>5、<strong>目标对象（Target Object）</strong>： 被一个或者多个切面（aspect）所通知（advise）的对象。</p><p>6、<strong>织入（Weaving）</strong>：指把增强应用到目标对象来创建新的代理对象的过程。</p><p>更多详细说明请查看Spring官网AOP部分:<a href="https://docs.spring.io/spring-framework/docs/5.2.25.RELEASE/spring-framework-reference/core.html#aop">Core Technologies (spring.io)</a></p><h4 id="1-3-Spring-AOP-与-AspectJ-的关系"><a href="#1-3-Spring-AOP-与-AspectJ-的关系" class="headerlink" title="1.3.Spring AOP 与 AspectJ 的关系"></a>1.3.Spring AOP 与 AspectJ 的关系</h4><p><strong>AspectJ：</strong>AspectJ 是一种流行的面向切面编程语言，它扩展了Java编程语言，引入了新的结构来模块化软件系统中的横切关注点，是 AOP 编程完全解决方案，算得上是Java生态系统中最完整的AOP框架了。 </p><p><strong>Spring虽然提供了AspectJ的支持，但只用到的AspectJ的切点解析和匹配</strong>。比如 @Aspect、@Pointcut、@Before、@After 、@Around 等注解都是来自于 AspectJ，利用AspectJ的解析execution、@Annotation等表达式的能力去解析，因为AspectJ也是一个优秀的框架，Spring为了不重复造轮子嘛，就利用到了这些。</p><p><strong>但是动态代理功能的实现是纯 Spring AOP 自己实现的</strong>。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p><ul><li>AspectJ相比于Spring AOP功能更加强大，但是Spring AOP相对来说更简单。</li><li>Spring AOP是属于运行时增强，而AspectJ是编译时增强。</li><li>Spring AOP基于代理（Proxying），而 AspectJ基于字节码操作（Bytecode Manipulation）。</li></ul><h3 id="2-Spring-AOP的使用"><a href="#2-Spring-AOP的使用" class="headerlink" title="2.Spring AOP的使用"></a>2.Spring AOP的使用</h3><h4 id="2-1-定义切面和切点"><a href="#2-1-定义切面和切点" class="headerlink" title="2.1.定义切面和切点"></a>2.1.定义切面和切点</h4><p>要使用Java@Configuration启用@AspectJ支持，请添加@EnableAspectJAutoProxy注释，如下例:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@EnableAspectJAutoProxy</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义切面类：<strong>被抽取的公共模块，可能会横切多个对象</strong></p><p>定义切入点：<strong>需要被增强的方法</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span></span><span class="token class-name">Ioc_test</span><span class="token punctuation">.</span>aspects<span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span></span><span class="token class-name">ProceedingJoinPoint</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>aspectj<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token operator">*</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>core<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Order</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span></span><span class="token class-name">Component</span></span><span class="token punctuation">;</span><span class="token comment">/** * returning * 各种增强类型 */</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAspect</span> <span class="token punctuation">{</span>    <span class="token comment">//在切点中我们要定义拦截的规则</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.yc.Ioc_test.Biz..add*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>@Aspect</strong>定义切面类 并使用@<strong>@Component</strong>被Spring托管</p><p><strong>@Pointcut</strong>(“execution(* com.yc.Ioc_test.Biz..add*(..))”)该表达式指定了一个切入点，用于匹配 com.yc.Ioc_test.Biz 包及其子包中以 “add” 开头的方法的任意参数。</p><p><strong>execution</strong>: 这是切入点指示符，指示匹配<strong>方法执行</strong>的连接点。<br>*****    : 这表示匹配任意返回类型的方法。<br>com.yc.Ioc_test.Biz: 这是包名，表示匹配该包下的类。<br><strong>..</strong>    : 这表示匹配零个或多个子包。<br>add*   : 这是方法名的模式，表示匹配以 “add” 开头的方法名。<br>(..)   : 这表示匹配任意参数的方法。</p><h4 id="2-2-定义相关通知"><a href="#2-2-定义相关通知" class="headerlink" title="2.2.定义相关通知"></a>2.2.定义相关通知</h4><p>通知定义的是<strong>被拦截的⽅法具体要执行的业务</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestAspect</span> <span class="token punctuation">{</span>    <span class="token comment">//@Pointcut("execution(* showAll(..))")</span>    <span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.yc.Ioc_test.Biz..add*(..))"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>   <span class="token comment">//正常返回 才起作用   返回增强的方法中的返回值</span>    <span class="token annotation punctuation">@AfterReturning</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"a()"</span><span class="token punctuation">,</span>returning <span class="token operator">=</span> <span class="token string">"retVal"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token class-name">Object</span> retVal<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"returning 返回结果为"</span><span class="token operator">+</span>retVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//仅在引发给定类型的异常时才运行     返回异常信息</span>    <span class="token annotation punctuation">@AfterThrowing</span><span class="token punctuation">(</span>pointcut <span class="token operator">=</span> <span class="token string">"a()"</span><span class="token punctuation">,</span>throwing <span class="token operator">=</span> <span class="token string">"ex"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show2</span><span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> ex<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"throwing 异常报出"</span><span class="token operator">+</span>ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">//    //都执行</span>    <span class="token annotation punctuation">@After</span><span class="token punctuation">(</span><span class="token string">"a()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">show3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"after 无论正常或异常都执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//</span><span class="token comment">//    //环绕型</span>    <span class="token annotation punctuation">@Around</span><span class="token punctuation">(</span><span class="token string">"a()"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">show4</span><span class="token punctuation">(</span><span class="token class-name">ProceedingJoinPoint</span> pjp<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>   <span class="token comment">//ProceedingJoinPoint  表示代理连接点</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在原方法前"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> o <span class="token operator">=</span> pjp<span class="token punctuation">.</span><span class="token function">proceed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"在原方法后"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> o<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-3-使用并验证"><a href="#2-3-使用并验证" class="headerlink" title="2.3.使用并验证"></a>2.3.使用并验证</h4><p>此处以<strong>环绕型@Around</strong>为例测试：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>ioc_test</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span></span><span class="token class-name">Ioc_test</span><span class="token punctuation">.</span><span class="token class-name">AppConfig</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span></span><span class="token class-name">Ioc_test</span><span class="token punctuation">.</span><span class="token class-name">Biz</span><span class="token punctuation">.</span><span class="token class-name">ResuserBiz</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span></span><span class="token class-name">Ioc_test</span><span class="token punctuation">.</span><span class="token class-name">Biz</span><span class="token punctuation">.</span><span class="token class-name">ResuserBizImpl</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">Test</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span>api<span class="token punctuation">.</span>extension<span class="token punctuation">.</span></span><span class="token class-name">ExtendWith</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span></span><span class="token class-name">Autowired</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span></span><span class="token class-name">ContextConfiguration</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>test<span class="token punctuation">.</span>context<span class="token punctuation">.</span>junit<span class="token punctuation">.</span>jupiter<span class="token punctuation">.</span></span><span class="token class-name">SpringExtension</span></span><span class="token punctuation">;</span><span class="token comment">//ApplicationContext ac = new AnnotationConfigApplicationContext(AppConfig.class);</span><span class="token comment">//@RunWith(value= SpringJUnit4ClassRunner.class)    junit</span><span class="token annotation punctuation">@ExtendWith</span><span class="token punctuation">(</span><span class="token class-name">SpringExtension</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>      <span class="token comment">//jupiter</span><span class="token annotation punctuation">@ContextConfiguration</span><span class="token punctuation">(</span>classes <span class="token operator">=</span> <span class="token class-name">AppConfig</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> test1 <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span> <span class="token comment">// private ResuserBizImpl resuserBiz;  // ResuserBizImpl没实现接口时  使用Spring CGLIB代理</span>    <span class="token keyword">private</span> <span class="token class-name">ResuserBiz</span> resuserBiz<span class="token punctuation">;</span>    <span class="token comment">//ResuserBizImpl 类有实现接口   使用标准 JDK 动态代理</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        resuserBiz<span class="token punctuation">.</span><span class="token function">addResuser</span><span class="token punctuation">(</span><span class="token string">"张三"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">//输出结果   ResuserBizImpl 类有实现接口ResuserBiz，Spring使用标准 JDK 动态代理实现的AOP。</span>在原方法前添加新用户张三在原方法后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Spring-AOP实现原理"><a href="#3-Spring-AOP实现原理" class="headerlink" title="3.Spring AOP实现原理"></a>3.Spring AOP实现原理</h3><p>Spring AOP 是构建在<strong>动态代理</strong>基础上，因此 <strong>Spring 对 AOP 的支持局限于方法级别的拦截</strong></p><p>Spring AOP 支持 <strong>JDK Proxy</strong> 和 <strong>CGLIB</strong> 方式实现动态代理</p><p>下面我们使用Maven模块aop_dynamicProxy来实现对方法的增强,结构如下图：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/././imgc/52.png"></p><h4 id="3-1-JDK-Proxy"><a href="#3-1-JDK-Proxy" class="headerlink" title="3.1.JDK Proxy"></a>3.1.JDK Proxy</h4><p>JDK Proxy 动态代理的实现无需引用第三方类，其动态代理类位于 <strong>java.lang.reflect</strong> 包中。</p><p>使用JDK动态代理是基于<strong>实现了接口</strong>的类，结构如下：</p><p><img src="/././imgc/53.png"></p><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><p>要增强的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//HelloI接口</span><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HelloI</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//HelloI实现类</span><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span> <span class="token keyword">implements</span> <span class="token class-name">HelloI</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloImpl 的sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloImpl 的showBye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>处理增强的类 CustomInvocationHandler</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//JDK 实现时，先通过实现 InvocationHandler 接⼝创建⽅法调⽤处理器，再通过 Proxy 来创建代理类。</span><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationHandler</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Proxy</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomInvocationHandler</span> <span class="token keyword">implements</span> <span class="token class-name">InvocationHandler</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>      <span class="token comment">//目标类的</span>    <span class="token comment">//通过构造方法传目标类</span>    <span class="token keyword">public</span> <span class="token class-name">CustomInvocationHandler</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//生成代理 对象的方法</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//jdk 中提供了 Proxy类 有一个方法专门用于根据接口生成代理类对象的方法</span>        <span class="token comment">//这也是为什么 jDK 动态代理要面向接口的原因</span>        <span class="token class-name">Object</span> proxy <span class="token operator">=</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span>  <span class="token class-name">CustomInvocationHandler</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> proxy<span class="token punctuation">;</span>   <span class="token comment">//$Proxy ..</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * java虚拟机 发现调用代理类的方法时回自动回调invoke()     * @param proxy  代理对象     * @param method 调用的方法     * @param args   方法的参数值     * @return     * @throws Throwable     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token comment">//切入点表达式筛选出需要前置增强的方法 </span>        <span class="token keyword">if</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">)</span><span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//解析@Pointcut表达式</span>            <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//showTime();</span>        <span class="token comment">//反射机制调用目标类的目标方法</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//后置增强</span>        <span class="token comment">//showTime();</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//增强的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间为："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以通过在Object returnValue = method.invoke(target,args);的前后写入增强的方法showTime()来实现不同的增强方式。</li><li>在写入增强的方法showTime()设置条件来实现解析@Pointcut表达式的作用</li></ul><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//配置将代理类的字节码保存在本地</span>        <span class="token comment">//System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");</span>        <span class="token class-name">HelloI</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//目标类</span>        <span class="token class-name">CustomInvocationHandler</span> handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomInvocationHandler</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成代理类</span>        <span class="token class-name">Object</span> proxy <span class="token operator">=</span> handler<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//System.out.println(proxy);</span>        <span class="token class-name">HelloI</span> hi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HelloI</span><span class="token punctuation">)</span>proxy<span class="token punctuation">;</span>        hi<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//proxy的sayHello()  --&gt;回调对象的 invoke()  --&gt;  目标类HelloImpl的目标方法sayHello()</span>        hi<span class="token punctuation">.</span><span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>核心点：</p><ul><li>由Proxy.newProxyInstance创建的<strong>代理对象拥有接口类的所有方法</strong></li><li>在测试类中调用代理类proxy时，虚拟机会<strong>自动回调InvocationHandler的实现类CustomInvocationHandler的invoke()<strong>，然后在invoke()方法里</strong>利用反射来掉用目标类的方法</strong>实现增强。</li></ul><h5 id="调用过程"><a href="#调用过程" class="headerlink" title="调用过程"></a>调用过程</h5><p>在测试类中加入配置</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">//配置将代理类的字节码保存在本地</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span><span class="token punctuation">,</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行完后生成$Proxy0.class 文件，通过这个文件能更直观的明白调用过程。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//</span><span class="token comment">// Source code recreated from a .class file by IntelliJ IDEA</span><span class="token comment">// (powered by Fernflower decompiler)</span><span class="token comment">//</span><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>sun<span class="token punctuation">.</span>proxy</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy<span class="token punctuation">.</span></span><span class="token class-name">HelloI</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">InvocationHandler</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Proxy</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">UndeclaredThrowableException</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> $<span class="token class-name">Proxy0</span> <span class="token keyword">extends</span> <span class="token class-name">Proxy</span> <span class="token keyword">implements</span> <span class="token class-name">HelloI</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m1<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m4<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m3<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m2<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Method</span> m0<span class="token punctuation">;</span>    <span class="token keyword">public</span> $<span class="token class-name">Proxy0</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Boolean</span><span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m1<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>var1<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var3<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var4<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m3<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m2<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m0<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            m1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"equals"</span><span class="token punctuation">,</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m4 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.yc.jdkproxy.HelloI"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m3 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.yc.jdkproxy.HelloI"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"showBye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m2 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            m0 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.Object"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"hashCode"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoSuchMethodError</span><span class="token punctuation">(</span>var2<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NoClassDefFoundError</span><span class="token punctuation">(</span>var3<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到这个类<strong>实现了我们传进去的HelloI接口，并拥有接口所有的方法</strong>（sayHello()，showBye()…）,</p><p>在$Proxy0的构造方法中传入了一个<strong>InvocationHandler实例</strong>对应<strong>CustomInvocationHandler对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> $<span class="token class-name">Proxy0</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> var1<span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>       <span class="token keyword">super</span><span class="token punctuation">(</span>var1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>追进super(var1)，进入Proxy，<strong>并将InvocationHandler实例传给了this.h。</strong></p><p><strong>结论1.所以Proxy类的h就是CustomInvocationHandler对象</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//Proxy</span><span class="token keyword">protected</span> <span class="token class-name">InvocationHandler</span> h<span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">protected</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token class-name">InvocationHandler</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>h <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当执行</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HelloI</span> hi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HelloI</span><span class="token punctuation">)</span>proxy<span class="token punctuation">;</span>hi<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>结论2.$Proxy0实现了HelloI接口的，所以hi.sayHello()此时就是调用的$Proxy0的sayHello().</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span>  <span class="token punctuation">{</span>       <span class="token keyword">try</span> <span class="token punctuation">{</span>           <span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RuntimeException</span> <span class="token operator">|</span> <span class="token class-name">Error</span> var2<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">throw</span> var2<span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var3<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">UndeclaredThrowableException</span><span class="token punctuation">(</span>var3<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中的**super.h.invoke(this, m4, (Object[])null)**，执行Proxy的h.invoke方法,而Proxy类的h就是CustomInvocationHandler对象，</p><p><strong>结论3.所以实际上是执行了CustomInvocationHandler的invoke方法</strong></p><p>再看CustomInvocationHandler的invoke方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token comment">//切入点表达式筛选出需要前置增强的方法</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"show"</span><span class="token punctuation">)</span><span class="token operator">&gt;=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment">//解析@Pointcut</span>            <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//showTime();</span>        <span class="token comment">//反射机制调用目标类的目标方法</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//后置增强</span>        <span class="token comment">//showTime();</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//与$Proxy0对应</span><span class="token keyword">super</span><span class="token punctuation">.</span>h<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> m4<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//可以看出method对应着m4(也就是sayHello()方法)</span><span class="token comment">//方法参数为null(没传入参数)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>结论4：方法中的method.invoke(target,args):通过反射机制调用了target(目标类)的sayHello方法</strong></p><p>由结论就可知hi.sayHello()的调用过程：</p><p><strong>proxy的sayHello()  –&gt;回调对象的 invoke()  –&gt;  目标类HelloI的目标方法sayHello()</strong></p><h5 id="JDK-proxy-底层原理"><a href="#JDK-proxy-底层原理" class="headerlink" title="JDK proxy 底层原理"></a>JDK proxy 底层原理</h5><ol><li>关键在于生成代理对象是<strong>用的 Proxy 类的静态方 newProxyInstance 获得代理对象</strong>这个<strong>代理类继承了 Proxy 类，并实现了之前定义的接口</strong>。</li><li>通过带有 InvocationHandler 参数的构造方法来创建实例，并<strong>把 InvocationHandler 传递到了 Proxy 类、中，它覆写了接口中所有的方法</strong>。</li><li>调用接口的方法时，通过调用代理类对应的方<strong>法回调了InvocationHandler 的invoke</strong>,然后再此方法中<strong>通过反射机制调用了目标类的目标方法</strong>实现增强。</li></ol><h4 id="3-2-CGLIB"><a href="#3-2-CGLIB" class="headerlink" title="3.2.CGLIB"></a>3.2.CGLIB</h4><p>CGLIB是一个功能强大，高性能的代码生成包。它<strong>为没有实现接口的类提供代理</strong>，为JDK的动态代理提供了很好的补充。</p><p>包结构如下：</p><p><img src="/././imgc/54.png"></p><p>因为CGLIB是第三方框架，需要导入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>cglib<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>3.3.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h5><p>要增强的类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloImpl 的sayHello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"HelloImpl 的showBye"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">Enhancer</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodInterceptor</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">net<span class="token punctuation">.</span>sf<span class="token punctuation">.</span>cglib<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span></span><span class="token class-name">MethodProxy</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span></span><span class="token class-name">Method</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Date</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyInterceptor</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>      <span class="token comment">//目标类的</span>    <span class="token comment">//传目标类</span>    <span class="token keyword">public</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//生成代理 对象的方法</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//生成的代理类的父类   target</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> objects<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> objects<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"当前时间为："</span><span class="token operator">+</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>CGLib 的调用流程就是<strong>通过调用拦截器的 intercept 方法来实现对被代理类的调用</strong>。</li><li>而拦截逻辑可以写在 **intercept 方法的 invokeSuper(o, objects);**的前后实现拦截。</li></ul><p>测试类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>cglib</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">com<span class="token punctuation">.</span>yc<span class="token punctuation">.</span>jdkproxy<span class="token punctuation">.</span></span><span class="token class-name">CustomInvocationHandler</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> test <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//配置将代理类的字节码保存在本地</span>        <span class="token comment">//System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles","true");</span>        <span class="token class-name">HelloImpl</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HelloImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//目标类</span>        <span class="token class-name">MyInterceptor</span> interceptor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyInterceptor</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//生成代理类</span>        <span class="token class-name">Object</span> proxy <span class="token operator">=</span> interceptor<span class="token punctuation">.</span><span class="token function">createProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">HelloImpl</span> hi <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">HelloImpl</span><span class="token punctuation">)</span> proxy<span class="token punctuation">;</span>        hi<span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//proxy的sayHello()  --&gt;回调对象的 invoke()  --&gt;  目标类HelloImpl的目标方法sayHello()</span>        hi<span class="token punctuation">.</span><span class="token function">showBye</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="调用过程-1"><a href="#调用过程-1" class="headerlink" title="调用过程"></a>调用过程</h5><p> //配置将代理类的字节码保存在本地</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token class-name">DebuggingClassWriter</span><span class="token punctuation">.</span><span class="token constant">DEBUG_LOCATION_PROPERTY</span> <span class="token punctuation">,</span><span class="token string">" d://cglib_proxy_classes"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行完后生成的文件：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloImpl</span>$$<span class="token class-name">EnhancerByCCLIB</span>$$c270593e <span class="token keyword">extends</span> <span class="token class-name">HelloImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Factory</span><span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">MethodInterceptor</span> var10000 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">CGLIB</span>$<span class="token constant">CALLBACK_O</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>var10000 <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token constant">CGLIB</span>$<span class="token function">BIND_CALLBACKS</span><span class="token punctuation">(</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            var10000 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">CGLIB</span>$<span class="token constant">CALLBACK_0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>var10000 <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>var10000<span class="token punctuation">.</span><span class="token function">intercept</span><span class="token punctuation">(</span><span class="token keyword">this</span>，<span class="token constant">C6LIB</span>$sayHello$<span class="token class-name">B</span>$<span class="token class-name">Hethod</span>，<span class="token constant">CGLIB</span>$emptyArgs，<span class="token constant">CGLIB</span>$sayHello$<span class="token number">0</span>$<span class="token class-name">Proxy</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到CGLIB的调用过程和JDK十分相似的，不同的是：</p><p>CGLIB代理<strong>继承了目标类，并把MethodInterceptor传递到了代理类</strong>中</p><p>调用类的方法时，通过调用代理类对应的方<strong>法回调了MethodInterceptor的intercept</strong>,然后再此方法中<strong>通过反射机制调用了目标类的目标方法</strong>实现增强。</p><h4 id="3-3-异同点"><a href="#3-3-异同点" class="headerlink" title="3.3.异同点"></a>3.3.异同点</h4><h5 id="实现区别"><a href="#实现区别" class="headerlink" title="实现区别"></a>实现区别</h5><ol><li>JDK 实现，要求被代理类必须实现接⼝，之后是通过 InvocationHandler 及 Proxy，在运⾏时动态的在内存中⽣成了代理类对象，该代理对象是通过实现同样的接⼝实现（类似静态代理接⼝实现的⽅式），只是该代理类是在运⾏期时，动态的织⼊统⼀的业务逻辑字节码来完成。</li><li>CGLIB 实现，被代理类可以不实现接⼝，是通过继承被代理类，在运⾏时动态的⽣成代理类对象 (三方框架，一般性能有优势)。</li></ol><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p><strong>劣势：</strong></p><ol><li>JDK：JDK的动态代理机制只能代理实现了接口的类，而不能实现接口的类就不能实现JDK的动态代理</li><li>CGLIB：CGLIB 的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对 final 修饰的类进行代理</li></ol><p><strong>优势：</strong></p><ol><li>JDK：最小化依赖关系，减少依赖意味着简化开发和维护，JDK本身的支持，可能比 cglib 更加可靠</li><li>JDK：平滑进行JDK版本升级，而字节码类库通常需要进行更新以保证在新版Java 上能够使用。代码实现简单</li><li>CGLIB：从某种角度看，限定调用者实现接口是有些侵入性的实践，类似cglib动态代理就没有这种限制。只操作我们关心的类，而不必为其他相关类增加工作量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 循环依赖问题</title>
      <link href="/2023/09/05/spring-xun-huan-yi-lai-wen-ti/"/>
      <url>/2023/09/05/spring-xun-huan-yi-lai-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-循环依赖问题"><a href="#Spring-循环依赖问题" class="headerlink" title="Spring 循环依赖问题"></a>Spring 循环依赖问题</h2><h3 id="1-什么是循环依赖"><a href="#1-什么是循环依赖" class="headerlink" title="1.什么是循环依赖"></a>1.什么是循环依赖</h3><p>假如我们有两个bean，A 和 B。他们的代码简单如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowire</span>    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowire</span>    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring在创建A的时候会出现这种现象：创建A实例后，在依赖注入时需要B，然后就去创建B，这时候发现又需要依赖注入 A ，这样就导致了循环依赖。</p><h3 id="2-Spring的解决方法"><a href="#2-Spring的解决方法" class="headerlink" title="2.Spring的解决方法"></a>2.Spring的解决方法</h3><h4 id="2-1-宏观思想"><a href="#2-1-宏观思想" class="headerlink" title="2.1.宏观思想"></a>2.1.宏观思想</h4><p>用<strong>三级缓存</strong>方式达到Bean<strong>提前曝光</strong>的目的：</p><p>Spring创建的过程简单的可以简单概括为 <strong>实例化——&gt;依赖注入——&gt;初始化。</strong>而Spring解决循环依赖的方法就是<strong>在实例化之后，依赖注入之前</strong>，将实例化的对象放到缓存中进行提前曝光，后边的对象则在实例化前，先到缓存中查找有无对应的实例化对象即可</p><p><img src="/././imgc/41.png"></p><h4 id="2-2-Spring三级缓存"><a href="#2-2-Spring三级缓存" class="headerlink" title="2.2.Spring三级缓存"></a>2.2.Spring三级缓存</h4><p>基本概念：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//一级缓存</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 二级缓存</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 三级缓存</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>第一级缓存：也叫单例池，存放已经经历了<strong>完整生命周期的Bean对象</strong>，可以直接使用的bean对象。</p><p>第二级缓存：提前曝光的单例对象的cache，存放原始的 bean 对象（<strong>尚未填充属性</strong>），用于解决循环依赖</p><p>第三级缓存：存放早期暴露的单例<strong>Bean的工厂</strong>，用于解决循环依赖（<strong>AOP</strong>的场景）。</p><p>使用过程：</p><p>我们先看一下Bean的生成流程，看看三级缓存是在什么地方有调用,如何解决循环依赖问题：</p><p><img src="/././imgc/42.png"></p><h5 id="1-Bean实例化前"><a href="#1-Bean实例化前" class="headerlink" title="1.Bean实例化前"></a>1.Bean实例化前</h5><p>Bean实例化前会<strong>先查询缓存</strong>，判断Bean是否已经存在防止重复实例化。</p><p><strong>AbstractBeanFactory.doGetBean</strong></p><p><img src="/././imgc/43.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span>  <span class="token comment">//继续追进</span>    <span class="token comment">//DefaultSingletonBeanRegistry</span><span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//最终方法实现</span><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token keyword">boolean</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 从一级缓存中获取Bean 获取到了则返回 没获取到继续</span>    <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isSingletonCurrentlyInCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从二级缓存中获取Bean  获取到了则返回 没获取到则继续</span>        singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> allowEarlyReference<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 加一把锁防止 线程安全 双重获取校验(可以避免多线程环境下重复创建单例对象的问题)</span>            <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 从一级缓存中获取Bean 获取到了则返回 没获取到继续</span>                singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 从二级缓存中获取Bean  获取到了则返回 没获取到则继续</span>                    singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 从三级缓存中获取 没获取到则返回</span>                        <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory <span class="token operator">=</span>                             <span class="token punctuation">(</span><span class="token class-name">ObjectFactory</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonFactory <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment">// 获取到了 执行三级缓存中的lambda表达式</span>                            singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 并将结果放入二级缓存</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 从三级缓存中移除</span>                            <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们看看这个获取的方法逻辑：</p><ol><li><strong>从一级缓存获取，获取到了，则返回</strong></li><li><strong>从二级缓存获取，获取到了，则返回</strong></li><li><strong>从三级缓存获取，获取到了，则执行三级缓存中的lambda表达式，将结果放入二级缓存，清除三级缓存</strong></li></ol><h5 id="2-Bean属性赋值前"><a href="#2-Bean属性赋值前" class="headerlink" title="2.Bean属性赋值前"></a>2.Bean属性赋值前</h5><p>Bean属性赋值前会先<strong>向三级缓存中放入一个lambda表达式</strong>，该表达式执行则会生成一个<strong>半成品Bean放入二级缓存</strong></p><p>AbstractAutowireCapableBeanFactory.doCreateBean 中</p><p><img src="/././imgc/45.png"></p><p>先看<strong>getEarlyBeanReference</strong> 方法：</p><p>该方法就是会判断该Bean是否需要被动态代理，两种返回结果：</p><ul><li>不需要代理，返回未属性注入、未初始化的半成品Bean</li><li>需要代理，返回未属性注入、未初始化的半成品Bean的代理对象</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token class-name">Object</span> bean<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>mbd<span class="token punctuation">.</span><span class="token function">isSynthetic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hasInstantiationAwareBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Iterator</span> var5 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getBeanPostProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 遍历后置处理器</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>var5<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">BeanPostProcessor</span> bp <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanPostProcessor</span><span class="token punctuation">)</span>var5<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 找到实现SmartInstantiationAwareBeanPostProcessor接口的</span>            <span class="token comment">// 该接口getEarlyBeanReference方法什么时候会执行？</span>            <span class="token comment">// AOP动态代理的时候 该方法执行就是判断该Bean是否需要被代理</span>            <span class="token comment">// 需要代理则会创建代理对象返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bp <span class="token keyword">instanceof</span> <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span> ibp <span class="token operator">=</span>                     <span class="token punctuation">(</span><span class="token class-name">SmartInstantiationAwareBeanPostProcessor</span><span class="token punctuation">)</span>bp<span class="token punctuation">;</span>                exposedObject <span class="token operator">=</span> ibp<span class="token punctuation">.</span><span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>exposedObject<span class="token punctuation">,</span> beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">// 这个Object有两种情况，一是实例化后的半成品Bean，二是半成品Bean动态代理后的代理对象</span>    <span class="token keyword">return</span> exposedObject<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>addSingletonFactory：</strong>这里就是将一个lambda表达式放入了三级缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingletonFactory</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>singletonFactory<span class="token punctuation">,</span> <span class="token string">"Singleton factory must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 一级缓存中不存在的话 </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 将lambda表达式放入三级缓存</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 清除二级缓存 </span>            <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：这里只是把lambda表达式放入了三级缓存，如果不从三级缓存中获取，这个表达式是不执行的，一旦执行了，就会把半成品Bean或者半成品Bean的代理对象放入二级缓存中了</strong></p><h5 id="3-Bean初始化完成后"><a href="#3-Bean初始化完成后" class="headerlink" title="3.Bean初始化完成后"></a>3.Bean初始化完成后</h5><p>将完整的Bean放入一级缓存，同时清空二、三级缓存</p><p>在<strong>AbstractBeanFactory.doGetBean</strong>中：</p><p><strong>getSingleton</strong>方法传参传了个lambda表达式，这个表达式内部就是Bean的实例化过程，初始化完成后，是要需要执行这个<strong>getSingleton</strong>方法的</p><p><img src="/././imgc/46.png"></p><p>追进<strong>getSingleton(beanName, singletonFactory)</strong></p><p>这个方法与上面那个不一样，重载了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 第一次进来这里获取肯定为null</span>            <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token comment">// 省略................</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">// 注意啊，这个就是执行外面那个传参的lambda表达式</span>                    <span class="token comment">// 所以这里才会跳到createBean方法那里去执行</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    newSingleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                 <span class="token comment">// 省略................</span>                <span class="token keyword">finally</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>recordSuppressedExceptions<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>suppressedExceptions <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterSingletonCreation</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">// 到了这说明Bean创建完了</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newSingleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment">// 这里就会把Bean放入一级缓存中了 同时清除二、三级缓存</span>                    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>追进 **this.addSingleton(beanName, singletonObject);**把Bean放入一级缓存同时清除二、三级缓存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> singletonObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment">// 放入一级缓存  </span>      <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 清除二、三级缓存</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>整个过程就三个地方跟缓存有关，我们假设现在要实例化A这个Bean，看看缓存是怎么变化的：</p><ol><li><strong>实例化前，获取缓存判断</strong>（三个缓存中肯定没有A，获取为null，进入实例化流程）</li><li><strong>实例化完成，属性注入前</strong>（往三级缓存中放入了一个lambda表达式，一、二级为null）</li><li><strong>初始化完成</strong>（将A这个Bean放入一级缓存，清除二、三级缓存）</li></ol><p>以上则是单个Bean生成过程中缓存的变化！！</p><h4 id="2-3-循环依赖的解决"><a href="#2-3-循环依赖的解决" class="headerlink" title="2.3.循环依赖的解决"></a>2.3.循环依赖的解决</h4><p>以A注入B，B注入A为例：</p><p><strong>A</strong>属性注入前就<strong>把lambda表达式放入了第三级缓存</strong>，所以<strong>B</strong>再注入A的时候会<strong>从第三级缓存中找到A的lambda表达式并执行，然后将半成品Bean放入第二级缓存</strong>，所以此时B注入的只是半成品的A对象，<strong>B创建完成后返回给A注入，A继续初始化，完成创建。</strong></p><p><strong>注意：</strong> B注入的半成品A对象只是一个引用，所以之后A初始化完成后，B这个注入的A就随之变成了完整的A</p><p><img src="/././imgc/47.png"></p><h3 id="3-思考"><a href="#3-思考" class="headerlink" title="3.思考"></a>3.思考</h3><h4 id="3-1-是否可以没有二级缓存"><a href="#3-1-是否可以没有二级缓存" class="headerlink" title="3.1.是否可以没有二级缓存"></a>3.1.是否可以没有二级缓存</h4><p>（1）当只有A依赖B，B依赖A 的时候，是可以没有二级缓存的。</p><p>（2）当超过2个对象进行相互依赖时，是有可能用到二级缓存的</p><p>ABC产生循环依赖时:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">C</span> c<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>A注入到C又需要从第三级缓存中获取实例，而第三级缓存里保存的并非真正的实例对象，而是**(lambda表达式)ObjectFactory**对象。</p><p>两次从三级缓存中获取都是<strong>ObjectFactory</strong>对象，而<strong>通过它创建的实例对象每次可能都不一样的</strong>。</p><p>为了解决这个问题，spring引入的第二级缓存。只用从第二级缓存中获取该对象即可.</p><h4 id="3-2-是否需要三级缓存"><a href="#3-2-是否需要三级缓存" class="headerlink" title="3.2.是否需要三级缓存"></a>3.2.是否需要三级缓存</h4><ol><li><p>如果没有代理，是可以不需要三级缓存。</p></li><li><p>如果创建的Bean有对应的代理，那需要三级缓存。</p><p>也就是其他对象注入时，注入的应该是对应的代理对象</p></li></ol><ul><li>怎么理解呢？ 以io流举例，我们一开始都是用的原始字节流，然后给别人用的也是字节流，但是，最后，我感觉不方便，我自己悄悄弄了个缓存字符流（类比代理对象），我是方便了，但是，别人用的，还是原始的字节流。</li></ul><p>在<code>Spring</code>无法提前知道这个对象是不是有<strong>循环依赖</strong>的情况，而<strong>正常情况下（没有循环依赖情况）</strong>，<code>Spring</code>都是在<strong>创建好完成品Bean之后</strong>才创建对应的<strong>代理</strong>。这时候<code>Spring</code>有两个选择：</p><ol><li><p>不管有没有循环依赖，<strong>都提前创建好代理对象</strong>，并将代理对象放入缓存，出现循环依赖时，其他对象直接就可以取到代理对象并注入。</p></li><li><p>不提前创建好代理对象，在<strong>出现循环依赖被其他对象注入时，才实时生成代理对象，</strong>这样在没有循环依赖的情况下，Bean就可以按着Spring设计原则的步骤来创建。</p></li></ol><p>Spring选择了第二种方式，那怎么做到提前曝光对象而又不生成代理呢？</p><p>Spring就是在对象外面包一层<strong>ObjectFactory（也就是第三级缓存）</strong>，提前曝光的是ObjectFactory对象，在被注入时才在<strong>ObjectFactory.getObject</strong>方式内<strong>实时生成代理对象</strong>。</p><p>而在前面提到的将ObjectFactory放入三级缓存中<strong>addSingletonFactory</strong>方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSingletonFactory</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getEarlyBeanReference</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> bean<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>getEarlyBeanReference</strong> 方法就判断该Bean是否需要被动态代理并返回两种结果。</p><h4 id="3-3-Spring解决不了循环依赖的情况"><a href="#3-3-Spring解决不了循环依赖的情况" class="headerlink" title="3.3.Spring解决不了循环依赖的情况"></a>3.3.Spring<strong>解决不了循环依赖的情况</strong></h4><h5 id="1-多例Bean"><a href="#1-多例Bean" class="headerlink" title="1.多例Bean"></a>1.多例Bean</h5><p>在多例作用域下，每次请求获取该 Bean 时，都会创建一个<strong>新的实例</strong>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span><span class="token string">"prototype"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyBean</span> <span class="token punctuation">{</span>    <span class="token comment">// ...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果存在循环依赖关系，并且其中一个或多个 Bean 是多例作用域，则在获取这些 Bean 时可能会导致循环依赖异常。这是因为 <strong>Spring 无法在创建对象时提供早期的引用</strong>，从而无法解决循环依赖。</p><h5 id="2-构造器注入"><a href="#2-构造器注入" class="headerlink" title="2.构造器注入"></a>2.构造器注入</h5><p>当循环依赖的时候，依赖的彼此都只提供带参数的构造方法的时候，如下:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这时候会报异常，因为这时候在实例化A的时候就需要b了（<strong>仅提供一个有参构造方法，所以Spring只能调用这个有参构造方法进行实例化</strong>），而这时候去创建B，发现B也需要a，而a又还没实例化，所以没法实例化了</p><p>这种情况的解决方法，加上注解 <strong>@Lazy</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>     <span class="token comment">//添加@Lazy注解</span>    <span class="token annotation punctuation">@Lazy</span>    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时代表构造方法中的<strong>B是延时加载</strong>，所以构造的时候Spring先帮我们<strong>创建了B的代理对象</strong>，这时候A就可以实例化成功，此时再去实例化B。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring的设计模式</title>
      <link href="/2023/09/03/spring-de-she-ji-mo-shi/"/>
      <url>/2023/09/03/spring-de-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring的设计模式"><a href="#Spring的设计模式" class="headerlink" title="Spring的设计模式"></a>Spring的设计模式</h2><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h3><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供全局访问点以获取该实例。这样可以<strong>节省资源并保证对象的唯一性</strong>。</p><p>单例模式的好处在于对一些重量级的对象，省略了重复创建对象花费的时间，<strong>减少了系统的开销</strong>，第二点是使用单例可以减少new操作的次数，<strong>减少了GC线程回收内存的压力</strong>。</p><h4 id="1-2-源码分析"><a href="#1-2-源码分析" class="headerlink" title="1.2.源码分析"></a>1.2.源码分析</h4><p><strong>Spring容器</strong>：Spring容器本身也是一个单例，它在应用程序生命周期内只存在一个实例。</p><p><strong>Bean默认的作用域</strong>:  在Spring中的Bean默认的作用域就是<strong>singleton单例</strong>的。</p><p>对于单例bean的创建方式，主要看DefaultSingletonBeanRegistry 的 getSingleton() 方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultSingletonBeanRegistry</span> <span class="token keyword">extends</span> <span class="token class-name">SimpleAliasRegistry</span> <span class="token keyword">implements</span> <span class="token class-name">SingletonBeanRegistry</span> <span class="token punctuation">{</span>    <span class="token comment">/** 保存单例Objects的缓存集合ConcurrentHashMap，key：beanName --&gt; value：bean实例 */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> singletonFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Assert</span><span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token string">"Bean name must not be null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//检查缓存中是否有实例，如果缓存中有实例，直接返回</span>            <span class="token class-name">Object</span> singletonObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singletonObject <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//省略...</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token comment">//通过singletonFactory获取单例</span>                    singletonObject <span class="token operator">=</span> singletonFactory<span class="token punctuation">.</span><span class="token function">getObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    newSingleton <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment">//省略...</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>newSingleton<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">addSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment">//返回实例</span>            <span class="token keyword">return</span> singletonObject<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">addSingleton</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">Object</span> singletonObject<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonObjects<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> singletonObject<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>singletonFactories<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>earlySingletonObjects<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>registeredSingletons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源码中可以看出，是通过ConcurrentHashMap的方式，如果在Map中存在则直接返回，如果不存在则创建，并且put进Map集合中，并且整段逻辑是使用同步代码块包住的，所以是线程安全的。</p><h3 id="2-代理模式"><a href="#2-代理模式" class="headerlink" title="2.代理模式"></a>2.代理模式</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><p>代理模式是一种结构型设计模式，它通过创建一个<strong>代理对象来控制对实际对象的访问</strong>，并在访问前后执行一些附加操作。代理模式可以实现横切关注点的解耦，如事务管理、日志记录等。</p><h4 id="2-2-源码分析"><a href="#2-2-源码分析" class="headerlink" title="2.2.源码分析"></a>2.2.源码分析</h4><p>Spring  <strong>AOP</strong>实现的关键在于动态代理</p><p>AOP是Spring的一个核心特性(<strong>面向切面编程</strong>)，作为面向对象的一种补充，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取并封装为一个可重用的模块，减少系统中的重复代码，降低了模块间的耦合度，提高系统的可维护性。</p><p>代理对象实现了接口: Spring AOP会使用Java动态代理<strong>JDK Proxy</strong>创建代理对象 完成对象的代理操作 </p><p>代理对象没有实现接口: Spring AOP会使用<strong>Cglib Proxy</strong>生成一个被代理对象的子类作为代理类完成对象代理操作</p><p><img src="/././imgc/33.png"></p><p>我们看DefaultAopProxyFactory的createAopProxy()方法，Spring通过此方法创建动态代理类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultAopProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">AopProxyFactory</span><span class="token punctuation">,</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token class-name">AopProxy</span> <span class="token function">createAopProxy</span><span class="token punctuation">(</span><span class="token class-name">AdvisedSupport</span> config<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">AopConfigException</span> <span class="token punctuation">{</span>        <span class="token comment">// 判断是否需要进行代理的优化、是否代理目标类而不是接口</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span><span class="token function">isOptimize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> config<span class="token punctuation">.</span><span class="token function">isProxyTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span>            <span class="token comment">// 以及是否没有用户提供的代理接口</span>            <span class="token function">hasNoUserSuppliedProxyInterfaces</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> targetClass <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getTargetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 检查目标类是否存在</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">AopConfigException</span><span class="token punctuation">(</span><span class="token string">"TargetSource cannot determine target class: "</span> <span class="token operator">+</span> <span class="token string">"Either an interface or a target is required for proxy creation."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 检查目标类是否是接口类型或者已经是代理类</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>targetClass<span class="token punctuation">.</span><span class="token function">isInterface</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">isProxyClass</span><span class="token punctuation">(</span>targetClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">// 返回JDK动态代理对象</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment">// 返回CGLIB代理对象</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ObjenesisCglibAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 返回JDK动态代理对象</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">JdkDynamicAopProxy</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-工厂模式"><a href="#3-工厂模式" class="headerlink" title="3.工厂模式"></a>3.工厂模式</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><p>工厂模式是一种创建对象的设计模式，它将对象的创建逻辑封装在一个工厂类中，而不是在客户端代码中直接实例化对象。通过工厂模式，可以实现<strong>解耦</strong>和灵活性，使得客户端代码与具体的对象创建逻辑分离。</p><h4 id="3-2-源码分析"><a href="#3-2-源码分析" class="headerlink" title="3.2.源码分析"></a>3.2.源码分析</h4><p>Spring中IOC就是控制反转，将对象的控制权转移给Spring，并由Spring创建实例和管理各个实例之间的依赖关系，其中，对象的创建就是通过BeanFactory 和 ApplicationContext 完成的。</p><p><strong>1.BeanFactory</strong> </p><p>BeanFactory是Spring里面最底层的接口，是IoC的核心，定义了IoC的基本功能(Bean的定义、加载、实例化，依赖注入和生命周期管理)。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">BeanFactory</span> <span class="token punctuation">{</span>    <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>        <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">getBean</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">;</span>    <span class="token comment">//省略...</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring中的Bean工厂是一个工厂模式的典型应用。Bean工厂负责创建和管理Bean实例，它将对象的实例化过程封装在工厂类中，通过配置文件或注解来描述Bean的创建逻辑。Bean工厂根据配置信息动态创建对象，并在需要时将对象提供给应用程序。</p><p><strong>2.ApplicationContext</strong> </p><p>ApplicationContext接口作为BeanFactory的子类，除了提供BeanFactory所具有的功能外，还扩展了其他更完整功能，对于Bean创建，ApplicationContext在容器启动时，一次性创建了所有的Bean。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationContext</span> <span class="token keyword">extends</span> <span class="token class-name">EnvironmentCapable</span><span class="token punctuation">,</span> <span class="token class-name">ListableBeanFactory</span><span class="token punctuation">,</span> <span class="token class-name">HierarchicalBeanFactory</span><span class="token punctuation">,</span><span class="token class-name">MessageSource</span><span class="token punctuation">,</span> <span class="token class-name">ApplicationEventPublisher</span><span class="token punctuation">,</span> <span class="token class-name">ResourcePatternResolver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">String</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> <span class="token function">getApplicationName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">String</span> <span class="token function">getDisplayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">long</span> <span class="token function">getStartupDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token annotation punctuation">@Nullable</span>    <span class="token class-name">ApplicationContext</span> <span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token class-name">AutowireCapableBeanFactory</span> <span class="token function">getAutowireCapableBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>应用上下文是一个高级工厂，它不仅负责创建和管理Bean实例，还提供了其他的应用级服务，如国际化、事件传播、资源管理等。应用上下文可以根据配置信息创建和组装Bean，并提供对它们的访问。</p><h3 id="4-模板模式"><a href="#4-模板模式" class="headerlink" title="4.模板模式"></a>4.模板模式</h3><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><p>模板方法模式是一种行为型设计模式，它定义了一个算法的骨架，在父类中定义了算法的结构，而将一些步骤的<strong>具体实现延迟到子类</strong>中。这样可以确保算法的一致性，并允许子类根据需要进行特定实现。</p><h4 id="4-2-源码分析"><a href="#4-2-源码分析" class="headerlink" title="4.2.源码分析"></a>4.2.源码分析</h4><ul><li><strong>Spring</strong>中以<strong>Template</strong>结尾的类,比如<strong>jdbcTemplate</strong>等,都是使用了模板方法模式。</li></ul><p><img src="/././imgc/32.png"></p><ul><li>Spring中的事务管理器就运用模板模式的设计，首先看PlatformTransactionManager类。这是最底层的接口，定义提交和回滚的方法</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PlatformTransactionManager</span> <span class="token punctuation">{</span>    <span class="token class-name">TransactionStatus</span> <span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> <span class="token class-name">TransactionDefinition</span> definition<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span>        <span class="token keyword">void</span> <span class="token function">rollback</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着看AbstractPlatformTransactionManager类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">commit</span><span class="token punctuation">(</span><span class="token class-name">TransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span> <span class="token punctuation">{</span>    <span class="token comment">//省略...</span>    <span class="token class-name">DefaultTransactionStatus</span> defStatus <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span><span class="token punctuation">)</span> status<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>defStatus<span class="token punctuation">.</span><span class="token function">isLocalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用processRollback()</span>        <span class="token function">processRollback</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">shouldCommitOnGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> defStatus<span class="token punctuation">.</span><span class="token function">isGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用processRollback()</span>        <span class="token function">processRollback</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//调用processCommit()</span>    <span class="token function">processCommit</span><span class="token punctuation">(</span>defStatus<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">//这个方法定义了骨架，里面会调用一个doRollback()的模板方法</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">,</span> <span class="token keyword">boolean</span> unexpected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//调用doRollback()模板方法</span>        <span class="token function">doRollback</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略了很多代码...</span><span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span> <span class="token punctuation">{</span>    <span class="token comment">//省略...</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">hasSavepoint</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isNewTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//省略...</span>        <span class="token comment">//调用doCommit()模板方法</span>        <span class="token function">doCommit</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFailEarlyOnGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        unexpectedRollback <span class="token operator">=</span> status<span class="token punctuation">.</span><span class="token function">isGlobalRollbackOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略了很多代码...</span><span class="token punctuation">}</span> <span class="token comment">//模板方法doRollback()，把重要的步骤延迟到子类去实现</span><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span> <span class="token comment">//模板方法doCommit()，把重要的步骤延迟到子类去实现</span><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">doCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">TransactionException</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把骨架中重要的doRollback()延迟到子类。一般来说，Spring默认是使用的事务管理器的实现类是DataSourceTransactionManager。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//通过继承AbstractPlatformTransactionManager抽象类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DataSourceTransactionManager</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractPlatformTransactionManager</span><span class="token keyword">implements</span> <span class="token class-name">ResourceTransactionManager</span><span class="token punctuation">,</span> <span class="token class-name">InitializingBean</span> <span class="token punctuation">{</span>    <span class="token comment">//重写doCommit()方法，实现具体commit的逻辑</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doCommit</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">DataSourceTransactionObject</span> txObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DataSourceTransactionObject</span><span class="token punctuation">)</span> status<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Connection</span> con <span class="token operator">=</span> txObject<span class="token punctuation">.</span><span class="token function">getConnectionHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Committing JDBC transaction on Connection ["</span> <span class="token operator">+</span> con <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            con<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TransactionSystemException</span><span class="token punctuation">(</span><span class="token string">"Could not commit JDBC transaction"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment">//重写doRollback()方法，实现具体的rollback的逻辑</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRollback</span><span class="token punctuation">(</span><span class="token class-name">DefaultTransactionStatus</span> status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">DataSourceTransactionObject</span> txObject <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">DataSourceTransactionObject</span><span class="token punctuation">)</span> status<span class="token punctuation">.</span><span class="token function">getTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Connection</span> con <span class="token operator">=</span> txObject<span class="token punctuation">.</span><span class="token function">getConnectionHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>status<span class="token punctuation">.</span><span class="token function">isDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Rolling back JDBC transaction on Connection ["</span> <span class="token operator">+</span> con <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      con<span class="token punctuation">.</span><span class="token function">rollback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TransactionSystemException</span><span class="token punctuation">(</span><span class="token string">"Could not roll back JDBC transaction"</span><span class="token punctuation">,</span> ex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-策略模式"><a href="#5-策略模式" class="headerlink" title="5.策略模式"></a>5.策略模式</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1.定义"></a>5.1.定义</h4><p>策略模式是一种行为型设计模式，它定义了一系列的算法，并将<strong>每个算法封装在独立的策略类</strong>中，使得它们可以<strong>相互替换</strong>。通过策略模式，可以在运行时选择不同的策略实现，从而实现灵活的配置和扩展。</p><h4 id="5-2-源码分析"><a href="#5-2-源码分析" class="headerlink" title="5.2.源码分析"></a>5.2.源码分析</h4><p><strong>AOP切面（Aspect）</strong>：在Spring的AOP（面向切面编程）中，策略模式常常用于定义和应用不同的切面策略。通过定义切面接口和不同的切面实现类，可以根据需要选择不同的切面策略，并将其应用于特定的目标方法中。</p><p><strong>Spring的Resource类</strong>：在Spring的Resource类，针对不同的资源，Spring定义了不同的Resource类的实现类，以此实现不同的访问方式，如下图：</p><p><img src="/././imgc/31.png"></p><ul><li><strong>UrlResource</strong>：访问网络资源的实现类。</li><li><strong>ServletContextResource</strong>：访问相对于 ServletContext 路径里的资源的实现类。</li><li><strong>ByteArrayResource</strong>：访问字节数组资源的实现类。</li><li><strong>PathResource</strong>：访问文件路径资源的实现类。</li><li><strong>ClassPathResource</strong>：访问类加载路径里资源的实现类。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/resource"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">resource</span><span class="token punctuation">(</span><span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"type"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> type<span class="token punctuation">,</span>                       <span class="token annotation punctuation">@RequestParam</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"arg"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> arg<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>    <span class="token class-name">Resource</span> resource<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"classpath"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//classpath下的资源</span>        resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClassPathResource</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"file"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//本地文件系统的资源</span>        resource <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PathResource</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//省略...</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"fail"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token class-name">InputStream</span> is <span class="token operator">=</span> resource<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//省略...</span>            <span class="token keyword">return</span> <span class="token string">"type:"</span> <span class="token operator">+</span> type <span class="token operator">+</span> <span class="token string">",arg:"</span> <span class="token operator">+</span> arg <span class="token operator">+</span> <span class="token string">"\r\n"</span> <span class="token operator">+</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>策略模式的思想：通过外部条件使用不同的算法解决问题（每个实现类的getInputStream()方法都不一样）</p><p>ClassPathResource的源码，是通过类加载器加载资源：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassPathResource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFileResolvingResource</span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">String</span> path<span class="token punctuation">;</span> <span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">ClassLoader</span> classLoader<span class="token punctuation">;</span> <span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>        <span class="token class-name">InputStream</span> is<span class="token punctuation">;</span>        <span class="token comment">//通过类加载器加载类路径下的资源</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>clazz <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>clazz<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>classLoader <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>classLoader<span class="token punctuation">.</span><span class="token function">getResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            is <span class="token operator">=</span> <span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemResourceAsStream</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//如果输入流is为null，则报错</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>is <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">FileNotFoundException</span><span class="token punctuation">(</span><span class="token function">getDescription</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" cannot be opened because it does not exist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">//返回InputStream</span>        <span class="token keyword">return</span> is<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再看UrlResource的源码，获取InputStream的实现又是另一种策略。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UrlResource</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractFileResolvingResource</span> <span class="token punctuation">{</span><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URI</span> uri<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URL</span> url<span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">URL</span> cleanedUrl<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token class-name">InputStream</span> <span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span><span class="token comment">//获取连接</span><span class="token class-name">URLConnection</span> con <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">openConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ResourceUtils</span><span class="token punctuation">.</span><span class="token function">useCachesIfNecessary</span><span class="token punctuation">(</span>con<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment">//获取输入流，并返回</span><span class="token keyword">return</span> con<span class="token punctuation">.</span><span class="token function">getInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// Close the HTTP connection (if applicable).</span><span class="token keyword">if</span> <span class="token punctuation">(</span>con <span class="token keyword">instanceof</span> <span class="token class-name">HttpURLConnection</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HttpURLConnection</span><span class="token punctuation">)</span> con<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">throw</span> ex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-观察者模式"><a href="#6-观察者模式" class="headerlink" title="6.观察者模式"></a>6.观察者模式</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1.定义"></a>6.1.定义</h4><p>观察者模式是一种行为型设计模式，它定义了<strong>一种一对多的依赖关系</strong>，当一个对象的状态发生变化时，它的<strong>所有依赖对象都会收到通知并自动更新</strong>。观察者模式实现了松耦合和对象间的解耦。</p><h4 id="6-2-源码分析"><a href="#6-2-源码分析" class="headerlink" title="6.2.源码分析"></a>6.2.源码分析</h4><p>Spring框架通过<strong>ApplicationEvent</strong>，<strong>ApplicationListener</strong>和<strong>ApplicationEventPublisher</strong>实现了观察者模式。</p><p>对应Spring事件驱动模型包含三种角色: <strong>事件Event角色</strong>， <strong>事件监听者Listener角色</strong>，<strong>事件发布者Publisher角色</strong></p><ol><li><p>事件Event角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">7099057708183571937L</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">Clock</span> clock<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationEvent，这是一个抽象类，抽象类下有四个实现类代表四种事件。</p><ul><li><strong>ContextStartedEvent</strong>：ApplicationContext启动后触发的事件。</li><li><strong>ContextStoppedEvent</strong>：ApplicationContext停止后触发的事件。</li><li><strong>ContextRefreshedEvent</strong>：ApplicationContext初始化或刷新完成后触发的事件。</li><li><strong>ContextClosedEvent</strong>：ApplicationContext关闭后触发的事件。</li></ul></li><li><p>事件监听者Listener角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">E</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PayloadApplicationEvent</span><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> <span class="token function">forPayload</span><span class="token punctuation">(</span><span class="token class-name">Consumer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> consumer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            consumer<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getPayload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>事件发布者Publisher角色</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventPublisher</span> <span class="token punctuation">{</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token class-name">ApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">)</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p>演示一下:</p><p>首先继承抽象类ApplicationEvent定义一个事件角色PayApplicationEvent。（<strong>写出相应的构造函数</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>     <span class="token keyword">private</span> <span class="token class-name">String</span> message<span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">PayApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">Object</span> source<span class="token punctuation">,</span> <span class="token class-name">String</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>message <span class="token operator">=</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> message<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>接着定义一个PayApplicationEvent事件的监听者PayListener。（<strong>重写onApplicationEvent() 方法</strong>）</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PayListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">PayApplicationEvent</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span><span class="token class-name">PayApplicationEvent</span> event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> message <span class="token operator">=</span> event<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"监听到PayApplicationEvent事件，消息为："</span> <span class="token operator">+</span> message<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后我们使用ApplicationContext发布事件（<strong>重写publishEvent() 方法发布消息</strong>）</p><p>注：ApplicationEventPublisher接口中的<strong>publishEvent()</strong> 发布事件方法,在AbstractApplicationContext中实现 </p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SpringmvcApplication</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token class-name">ApplicationContext</span> applicationContext <span class="token operator">=</span> <span class="token class-name">SpringApplication</span><span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">SpringmvcApplication</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        applicationContext<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PayApplicationEvent</span><span class="token punctuation">(</span>applicationContext<span class="token punctuation">,</span><span class="token string">"成功支付100元！"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-适配器模式"><a href="#7-适配器模式" class="headerlink" title="7.适配器模式"></a>7.适配器模式</h3><h4 id="7-1-定义"><a href="#7-1-定义" class="headerlink" title="7.1.定义"></a>7.1.定义</h4><p>是一种结构型设计模式，用于<strong>将一个类的接口转换成客户端所期望的另一个接口</strong>。它允许不兼容的接口能够一起工作，将原本不相关的类通过适配器进行<strong>协调和交互</strong>。</p><h4 id="7-2-源码分析"><a href="#7-2-源码分析" class="headerlink" title="7.2.源码分析"></a>7.2.源码分析</h4><p><strong>Spring AOP中的适配器模式：</strong></p><ul><li><p>Spring AOP中的增强和通知Advice使用了适配器模式,接口是AdvisorAdapter</p></li><li><p>常用的Advice类型包括: BeforeAdvice: 前置通知. 目标方法调用前增强 AfterAdvice: 后置通知. 目标方法调用后增强 AfterReturningAdvice: 目标方法执行结束之后 ,return之前</p></li><li><p>每个通知Advice都有对应的拦截器: BeforeAdvice - MethodBeforeAdviceInterceptor AfterAdvice - MethodAfterAdviceInterceptor AfterReturningAdvice - MethodAfterReturningAdviceInterceptor</p></li><li><p>Spring中预定义的通知要通过对应的适配器,适配成为MethodInterceptor接口类型的对象</p></li></ul><p><strong>Spring MVC中的适配器模式：</strong></p><ul><li><p>Spring MVC中 ,DispatchServlet根据请求信息调用HanlderMapping, 解析请求对应的Handler, 解析到对应的Handler后,开始由HandlerAdapter适配器进行处理</p></li><li><p>HandlerAdapter作为期望接口,具体的适配器实现类对具体目标类进行适配 .controller作为需要适配的类</p></li><li><p>通过使用适配器AdapterHandler可以对Spring MVC中众多类型的Controller通过不同的方法对请求进行处理</p></li></ul><p><strong>Spring MVC的适配器模式模拟代码</strong></p><ul><li>controller接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">HttpController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doHttpHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"http..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">SimpleController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSimplerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"simple..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationController</span> <span class="token keyword">implements</span> <span class="token class-name">Controller</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doAnnotationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"annotation..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>HandlerAdapter接口</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment">// 多种适配器类</span><span class="token keyword">class</span> <span class="token class-name">SimpleHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">SimpleController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doSimplerHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">SimpleController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">HttpHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">HttpController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doHttpHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">HttpController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">class</span> <span class="token class-name">AnnotationHandlerAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">HandlerAdapter</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">AnnotationController</span><span class="token punctuation">)</span> handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doAnnotationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">supports</span><span class="token punctuation">(</span><span class="token class-name">Object</span> handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>handler <span class="token keyword">instanceof</span> <span class="token class-name">AnnotationController</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>DispatchServlet类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">com<span class="token punctuation">.</span>test<span class="token punctuation">.</span>adapter</span><span class="token punctuation">;</span> <span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DispatchServlet</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">&gt;</span></span> handlerAdapters <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HandlerAdapter</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">public</span> <span class="token class-name">DispatchServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">AnnotationHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HttpHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handlerAdapters<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">SimpleHandlerAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 此处模拟SpringMVC从request取handler的对象，</span>        <span class="token comment">// 适配器可以获取到希望的Controller</span>        <span class="token class-name">HttpController</span> controller <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">// 得到对应适配器</span>        <span class="token class-name">HandlerAdapter</span> adapter <span class="token operator">=</span> <span class="token function">getHandler</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 通过适配器执行对应的controller对应方法</span>        adapter<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token class-name">HandlerAdapter</span> <span class="token function">getHandler</span><span class="token punctuation">(</span><span class="token class-name">Controller</span> controller<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//遍历：根据得到的controller(handler), 返回对应适配器</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">HandlerAdapter</span> adapter <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>handlerAdapters<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>adapter<span class="token punctuation">.</span><span class="token function">supports</span><span class="token punctuation">(</span>controller<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> adapter<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">DispatchServlet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">doDispatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// http...表示HttpController的处理方法被成功调用。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>该示例展示了适配器模式的应用。通过适配器模式，不同类型的Controller可以通过不同的适配器对应到相同的处理方法，实现了统一的处理流程。</p><p>这种设计可以提供灵活性和可扩展性，使得系统可以在不修改现有代码的情况下添加新的Controller类型。</p><h3 id="8-责任链模式"><a href="#8-责任链模式" class="headerlink" title="8.责任链模式"></a>8.责任链模式</h3><h4 id="8-1-定义"><a href="#8-1-定义" class="headerlink" title="8.1.定义"></a>8.1.定义</h4><p>责任链模式是一种行为型设计模式，它允许<strong>多个对象按照顺序处理请求</strong>，每个对象都可以选择处理请求或将其传递给下一个对象。</p><p>责任链模式为请求对象创建一个接收者处理链，通常接收者中会存在<strong>下一个接收者的引用</strong>，如果当前接收者无法处理当前请求时，则将请求对象传递到下一个接收者进行处理，从而实现责任链，直到可以处理请求对象为止。</p><h4 id="8-2-源码分析"><a href="#8-2-源码分析" class="headerlink" title="8.2.源码分析"></a>8.2.源码分析</h4><p><strong>Spring Security中的过滤器链（Filter Chain）</strong>：Spring Security使用责任链模式来处理Web请求的安全性。每个过滤器都有特定的功能，如身份验证、授权、会话管理等。这些过滤器按照特定的顺序组成过滤器链，每个过滤器在处理请求时可以选择继续处理或将请求传递给下一个过滤器。</p><p><strong>Spring MVC中的拦截器链（Interceptor Chain）</strong>：Spring MVC使用责任链模式来处理Web请求的拦截和预处理。拦截器按照配置的顺序组成拦截器链，每个拦截器可以在请求处理前后执行特定的操作，如日志记录、权限检查等。每个拦截器可以选择继续处理请求或将请求传递给下一个拦截器。</p><p><strong>Spring中的异常处理链（Exception Handling Chain）</strong>：Spring框架提供了异常处理机制，支持通过配置多个异常处理器来处理不同类型的异常。这些异常处理器按照配置的顺序组成异常处理链，每个处理器可以选择处理异常或将异常传递给下一个处理器。</p><p><strong>SpringSecurity</strong>是基于Spring实现的权限认证与校验的框架，它通过将请求内容交给过滤器链进行处理，通过框架提供的默认filter以及我们定义的filter来对请求进行处理，从而实现web权限的校验,其中的<strong>FilterChainProxy</strong>实际上实现了web中Filter过滤器，也是采用了责任链模式来实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>clearContext<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token punctuation">{</span>request<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token constant">FILTER_APPLIED</span><span class="token punctuation">,</span> <span class="token class-name">Boolean</span><span class="token punctuation">.</span><span class="token constant">TRUE</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">doFilterInternal</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> chain<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">RequestRejectedException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">doFilterInternal</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">)</span><span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span><span class="token comment">//...</span><span class="token keyword">if</span> <span class="token punctuation">(</span>filters <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> filters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//...</span>firewallRequest<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>chain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> firewallResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//...</span><span class="token class-name">VirtualFilterChain</span> virtualFilterChain <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VirtualFilterChain</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> chain<span class="token punctuation">,</span> filters<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//执行虚拟调用链virtualFilterChain的doFilter方法</span>virtualFilterChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>firewallRequest<span class="token punctuation">,</span> firewallResponse<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//VirtualFilterChain是FilterChainProxy中一个静态内部类</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">VirtualFilterChain</span> <span class="token keyword">implements</span> <span class="token class-name">FilterChain</span> <span class="token punctuation">{</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FilterChain</span> originalChain<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">&gt;</span></span> additionalFilters<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">FirewalledRequest</span> firewalledRequest<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">int</span> currentPosition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token class-name">VirtualFilterChain</span><span class="token punctuation">(</span><span class="token class-name">FirewalledRequest</span> firewalledRequest<span class="token punctuation">,</span> <span class="token class-name">FilterChain</span> chain<span class="token punctuation">,</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Filter</span><span class="token punctuation">&gt;</span></span> additionalFilters<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>originalChain <span class="token operator">=</span> chain<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>additionalFilters <span class="token operator">=</span> additionalFilters<span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> additionalFilters<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>firewalledRequest <span class="token operator">=</span> firewalledRequest<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doFilter</span><span class="token punctuation">(</span><span class="token class-name">ServletRequest</span> request<span class="token punctuation">,</span> <span class="token class-name">ServletResponse</span> response<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span><span class="token punctuation">,</span> <span class="token class-name">ServletException</span> <span class="token punctuation">{</span>                <span class="token comment">// 判断当前位置是否已经到达过滤器链的末尾</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 如果是末尾，直接调用原始的FilterChain的doFilter方法，将请求传递给下一个过滤器或目标Servlet进行处理</span><span class="token keyword">this</span><span class="token punctuation">.</span>firewalledRequest<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">this</span><span class="token punctuation">.</span>originalChain<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition<span class="token operator">++</span><span class="token punctuation">;</span><span class="token class-name">Filter</span> nextFilter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>additionalFilters<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>currentPosition <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//...</span><span class="token comment">//此处为责任链模式的实现，将请求对象交给一下一个处理方法进行处理</span>nextFilter<span class="token punctuation">.</span><span class="token function">doFilter</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上述代码展示了责任链模式的一种实现方式。通过构建一个责任链，每个过滤器节点都有机会处理请求，并决定是否将请求传递给下一个过滤器</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 基本概念</title>
      <link href="/2023/09/03/spring-ji-ben-gai-nian/"/>
      <url>/2023/09/03/spring-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-基本概念"><a href="#Spring-基本概念" class="headerlink" title="Spring 基本概念"></a>Spring 基本概念</h2><h3 id="1-Spring概述"><a href="#1-Spring概述" class="headerlink" title="1.Spring概述"></a>1.Spring概述</h3><p><a href="https://spring.io/">https://spring.io/</a></p><p><img src="/././imgc/20.png"></p><p>Spring 是个java企业级应用的开源开发框架。Spring主要用来开发Java应用，但是有些扩展是针对<br>构建J2EE平台的web应用。Spring 框架目标是简化Java企业级应用开发，并通过POJO为基础的编程模型促进良好的编程习惯</p><h3 id="2-为什么使用Spring框架"><a href="#2-为什么使用Spring框架" class="headerlink" title="2.为什么使用Spring框架"></a>2.为什么使用Spring框架</h3><ol><li><p><strong>轻量：</strong>Spring 是轻量的，基本的版本大约2MB。 </p></li><li><p><strong>控制反转：</strong>Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，而不是创建或查找 </p><p>依赖的对象们。 </p></li><li><p><strong>面向切面的编程</strong>(AOP)：Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。 </p></li><li><p><strong>容器：</strong>Spring 包含并管理应用中对象的生命周期和配置。 </p></li><li><p><strong>MVC</strong>框架：Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。 </p></li><li><p><strong>事务管理：</strong>Spring 提供一个持续的事务管理接口，可以扩展到上至本地事务下至全局事务 </p><p>（JTA）。 </p></li><li><p><strong>异常处理：</strong>Spring 提供方便的API把具体技术相关的异常（比如由JDBC，Hibernate or JDO抛 </p><p>出的）转化为一致的unchecked 异常。</p></li></ol><h4 id="2-1-Spring-IOC（控制反转）"><a href="#2-1-Spring-IOC（控制反转）" class="headerlink" title="2.1.Spring IOC（控制反转）"></a>2.1.Spring IOC（控制反转）</h4><p>Spring IOC，全称控制反转（Inversion of Control）,在传统的 Java 程序开发中，我们只能通过 new 关键字来创建对象， 这种导致程序中对象的依赖关系比较复杂，耦合度较高。 </p><p>而 IOC 的主要作用是实现了对象的管理，也就是我们把设计好的对象交给了 IOC 容器控制， 然后在需要用到目标对象的时候，直接从容器中去获取。</p><p>Spring的IOC有三种注入方式 ：构造器注入、setter方法注入、根据注解注入</p><p>描述IOC的常用注解：</p><ul><li><strong>@Component</strong>：可以用于注册所有bean</li><li><strong>@Repository</strong>：主要用于注册dao层的bean</li><li><strong>@Controller</strong>：主要用于注册控制层的bean</li><li><strong>@Service</strong>：主要用于注册服务层的bean</li></ul><h4 id="2-2-Spring-DI-依赖注入"><a href="#2-2-Spring-DI-依赖注入" class="headerlink" title="2.2.Spring DI   (依赖注入)"></a>2.2.Spring DI   (依赖注入)</h4><p>  有了 IOC 容器来管理 Bean 以后，相当于把对象的创建和查找依赖对象的控制权交给了容器，这种设计理念 使得对象与对象之间是一种松耦合状态，极大提升了程序的灵活性以及功能的复用性。 </p><p>然后，DI 表示依赖注入，也就是对于 IOC 容器中管理的 Bean，如果 Bean 之间存在依 赖关系，那么 IOC 容器需要 自动实现依赖对象的实例注入。</p><p>描述依赖关系主要有两种：</p><ul><li><strong>@Resource</strong>：java的注解，默认以<strong>byName</strong>的方式去匹配与属性名相同的bean的id，如果没有找到就会以byType的方式查找，如果byType查找到多个的话，使用**@Qualifier**注解（spring注解）指定某个具体名称的bean</li><li><strong>@Autowired</strong>：spring注解，默认是以<strong>byType</strong>的方式去匹配与属性名相同的bean的id，如果没有找到，就通过byName的方式去查找</li><li><strong>@Value</strong>: 用于注入属性值，可以从配置文件或其他来源读取值，并将其注入到标注了@Value的字段中。</li></ul><h3 id="3-Spring-Bean"><a href="#3-Spring-Bean" class="headerlink" title="3.Spring Bean"></a>3.Spring Bean</h3><h4 id="3-1-Spring-Bean的定义"><a href="#3-1-Spring-Bean的定义" class="headerlink" title="3.1.Spring Bean的定义"></a>3.1.Spring Bean的定义</h4><p>在 Spring 中，构成应用程序主干并由 <strong>Spring IoC 容器</strong>管理的对象称为 Bean。</p><p>Bean 是一个由 Spring IoC 容器实例化、组装和管理的对象</p><h4 id="3-2-Spring-中-Bean-从哪里来的"><a href="#3-2-Spring-中-Bean-从哪里来的" class="headerlink" title="3.2.Spring 中 Bean 从哪里来的"></a>3.2.<strong>Spring 中 Bean 从哪里来的</strong></h4><p>在 Spring 容器中，除了很多 Spring 内置的 Bean 以外，其他的 Bean 都是我们自己通 过 Spring 配置来声明的，然后，由 Spring 容器统一加载。</p><p>我们在 Spring 声明配置中 通常会配置以下内容，如：<strong>class（全类名）、id（也就是 Bean 的唯一标识）、 scope（作用域）以及 lazy-init（是否延时加载）</strong>等。之后，Spring 容器根据配置内容使用 对应的策略来创建 Bean 的实例。</p><h4 id="3-3-Spring-Bean-存在线程安全问题？"><a href="#3-3-Spring-Bean-存在线程安全问题？" class="headerlink" title="3.3.Spring  Bean 存在线程安全问题？"></a>3.3.<strong>Spring  Bean 存在线程安全问题？</strong></h4><p>回答这个问题之前我们得了解一下 <strong>Spring Bean 的作用域</strong>。</p><p>在 Spring 定义的作用域中，其中有 <strong>prototype（ 多例 Bean ）和 singleton （ 单例 Bean）</strong>。</p><ul><li>prototype 的 Bean，是在每次 getBean 的时候都会创建一个新的对象。</li><li>singleton 的Bean，在 Spring 容器中只会存在一个全局共享的实例。</li></ul><p><strong>因此，多例 Bean 是不存在线程安全问题的。</strong> </p><hr><p>而单例 Bean 就可能会存在线程安全问题。但是单例 Bean 又分为<strong>无状态 Bean 和有状态 Bean</strong>。</p><ul><li>无状态 Bean在多线程操作中只会对 Bean 的成员变量进行查询操作，<strong>不会修改成员变量的值</strong>。</li><li>有状态 Bean在多线程操作中如果需要<strong>对 Bean 中的成员变量进行数据更新操作</strong>。</li></ul><p>因此，无状态的单例 Bean 是不存在线程安全问题的。</p><p>所以，最终我们得出结论，在 Spring 中，只有<strong>有状态的单例 Bean</strong> 才会存在线程安全 </p><p>问题。</p><h4 id="3-4-如何处理-Spring-Bean-的线程安全问题？"><a href="#3-4-如何处理-Spring-Bean-的线程安全问题？" class="headerlink" title="3.4.如何处理 Spring Bean 的线程安全问题？"></a>3.4.<strong>如何处理 Spring Bean 的线程安全问题？</strong></h4><p>处理有状态单例 Bean 的线程安全问题有以下三种方法： </p><ol><li><p><strong>使用原型模式的Bean</strong>：将 Bean 的作用域由 “singleton” 单例 改为 “prototype” 多例。 </p></li><li><p><strong>单例模式的Bean设计为无状态</strong>：在 Bean 对象中避免定义可变的成员变量，当然，这样做不太现实。 </p></li><li><p><strong>使用Spring提供的注解和配置支持</strong>：Spring框架提供了一些注解和配置支持来处理线程安全问题。例如：</p><p>使用**@Scope(“request”)<strong>注解将Bean的作用域限定为每个请求，这样每个线程都会有一个独立的Bean实例。使用</strong>@Async**注解将方法标记为异步执行，Spring会为每个方法调用创建一个新的线程。</p></li><li><p><strong>在类中定义 ThreadLocal 的成员变量，并将需要的可变成员变量保存在 ThreadLocal 中</strong>：ThreadLocal 本身就具备线程隔离的特性，这就相当于为每个线 程提供了一个独立的变量副本，每个线程只需要操作自己的线程副本变量，从而解决线 程安全问题</p></li></ol><h3 id="4-Spring-Bean-生命周期"><a href="#4-Spring-Bean-生命周期" class="headerlink" title="4.Spring Bean 生命周期"></a>4.<strong>Spring Bean 生命周期</strong></h3><h4 id="4-1-创建前准备阶段"><a href="#4-1-创建前准备阶段" class="headerlink" title="4.1.创建前准备阶段"></a>4.1.创建前准备阶段</h4><p><img src="/././imgc/22.png"></p><p>这个阶段主要的作用是，Bean 在开始加载之前，需要从上下文和相关配置中解析并查找 Bean 有关的扩展实现</p><p>比如像<code>init-method</code>-容器在初始化 bean 时调用的方法、<code>destory-method</code>，容器在 </p><p>销毁 bean 时调用的方法。 </p><p>以及，BeanFactoryPostProcessor 这类的 bean 加载过程中的前置和后置处理。</p><h4 id="4-2-创建实例阶段"><a href="#4-2-创建实例阶段" class="headerlink" title="4.2.创建实例阶段"></a>4.2.创建实例阶段</h4><p><img src="/././imgc/23.png"></p><p>这个阶段主要是通过反射来创建Bean的实际对象，并且扫描和解析Bean的声明的一些属性。‍</p><h4 id="4-3-依赖注入阶段"><a href="#4-3-依赖注入阶段" class="headerlink" title="4.3.依赖注入阶段"></a>4.3.依赖注入阶段</h4><p><img src="/././imgc/24.png"></p><p>如果被实例化的 Bean 存在依赖其他 Bean 对象的情况，则需要对这些依赖 bean 进行对象注入。比如常见的**@Autowired、setter 注入**等依赖注入的配置形式。 </p><p>同时，在这个阶段会触发一些扩展的调用，比如常见的扩展类：</p><ul><li>BeanPostProcessors (用来实现 bean 初始化前后的扩展回调) </li><li>InitializingBean（这个类有一个 afterPropertiesSet()，这个在工作中也比较常见）</li><li>BeanFactoryAware 等等。</li></ul><h4 id="4-4-容器缓存阶段"><a href="#4-4-容器缓存阶段" class="headerlink" title="4.4.容器缓存阶段"></a>4.4.容器缓存阶段</h4><p><img src="/././imgc/25.png"></p><p>容器缓存阶段主要是把 bean 保存到容器以及 Spring 的缓存中，到了这个阶段，Bean就可以被开发者使用了。 </p><p>这个阶段涉及到的操作，常见的有，<code>init-method</code>这个属性配置的方法， 会在这个阶段调用。 </p><p>以及像 BeanPostProcessors 方法中的后置处理器方法如： </p><p>postProcessAfterInitialization，也会在这个阶段触发。</p><h4 id="4-5-销毁实例阶段"><a href="#4-5-销毁实例阶段" class="headerlink" title="4.5.销毁实例阶段"></a>4.5.销毁实例阶段</h4><p><img src="/././imgc/26.png"></p><p>当 Spring 应用上下文关闭时，该上下文中的所有 bean 都会被销毁。 </p><p>如果存在 Bean 实现了 DisposableBean 接口，或者配置了<code>destory-method</code>属性，会 </p><p>在这个阶段被调用。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> Spring </tag>
            
            <tag> IOC </tag>
            
            <tag> DI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文件属性内容</title>
      <link href="/2023/09/01/linux-wen-jian-shu-xing-nei-rong/"/>
      <url>/2023/09/01/linux-wen-jian-shu-xing-nei-rong/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-文件属性内容"><a href="#Linux-文件属性内容" class="headerlink" title="Linux 文件属性内容"></a>Linux 文件属性内容</h2><h4 id="1-文件属性"><a href="#1-文件属性" class="headerlink" title="1.文件属性"></a>1.文件属性</h4><h5 id="1-文件属性查看"><a href="#1-文件属性查看" class="headerlink" title="1.文件属性查看"></a>1.文件属性查看</h5><p>Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。</p><p>在Linux中我们可以使用<code>ll</code>或者<code>ls –l</code>命令来显示一个文件的属性以及文件所属的用户和组</p><p>如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#使用 ls -l查看文件权限</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls -l</span>total <span class="token number">20</span>drwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:29 java_homedrwx------ <span class="token number">2</span> redis redis <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:45 redisdrwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:05 test1drwx--x--x <span class="token number">2</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:14 test2drwx------ <span class="token number">2</span> www   www   <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">14</span>:08 www<span class="token comment">#解析test2的第一列   drwx--x--x </span><span class="token comment">#第一个字符表示文件类型：</span>d 表示目录   （- 表示普通文件，l 表示符号链接等<span class="token punctuation">..</span>.）rwx--x--x    （rwx：读，写，执行；--x：执行；--x：执行<span class="token comment">#其他列</span><span class="token number">1</span>. 第二列是与文件或目录相关联的硬链接数。<span class="token number">2</span>. 第三列是文件或目录的所有者用户名。<span class="token number">3</span>. 第四列是文件或目录的所属组名。<span class="token number">4</span>. 第五列是文件或目录的大小（以字节为单位）。<span class="token number">5</span>. 第六列是最后修改时间。<span class="token number">6</span>. 第七列是文件或目录的名称。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-文件属性修改"><a href="#2-文件属性修改" class="headerlink" title="2.文件属性修改"></a>2.文件属性修改</h5><p>1.chgrp：更改文件属组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chgrp</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>-R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。</p><p>2.chown：更改文件属主，也可以同时更改文件属组</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>–R<span class="token punctuation">]</span> 属主名 文件名<span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> 属主名：属组名 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>3.chmod：更改文件9个属性</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chmod</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> xyz 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>[-rwxrwx—] 分数则是：</p><ul><li>owner = rwx = 4+2+1 = 7</li><li>group = rwx = 4+2+1 = 7</li><li>others= — = 0+0+0 = 0</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#示例</span><span class="token function">chmod</span> <span class="token number">770</span> filename<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>770这三位数分别代表所有者、所属组的用户、其他用户；<br>数字 7 转换为二进制是 111，即读（r）、写（w）和执行（x）<br>数字 4 转换为二进制是 111，即读（r）、写（w）和执行（x）<br>数字 1 转换为二进制是 000，无权限</p><h4 id="2-文件内容"><a href="#2-文件内容" class="headerlink" title="2.文件内容"></a>2.文件内容</h4><p>Linux系统中使用以下命令来查看文件的内容：</p><ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl  显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul><p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p><h5 id="1-cat-由第一行开始显示文件内容"><a href="#1-cat-由第一行开始显示文件内容" class="headerlink" title="1.cat (由第一行开始显示文件内容)"></a>1.cat (由第一行开始显示文件内容)</h5><p>选项与参数：</p><ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhcp<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto<span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet<span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-tac-从最后一行开始显示"><a href="#2-tac-从最后一行开始显示" class="headerlink" title="2.tac(从最后一行开始显示)"></a>2.tac(从最后一行开始显示)</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># tac /etc/sysconfig/network-scripts/ifcfg-eth0</span><span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet<span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto<span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes<span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0<span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-nl-显示行号"><a href="#3-nl-显示行号" class="headerlink" title="3.nl  显示行号"></a>3.nl  显示行号</h5><p>选项与参数：</p><ul><li>-b ：指定行号指定的方式，主要有两种：-b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；-b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种：-n ln ：行号在荧幕的最左方显示；-n rn ：行号在自己栏位的最右方显示，且不加 0 ；-n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># nl /etc/sysconfig/network-scripts/ifcfg-eth0</span>     <span class="token number">1</span><span class="token assign-left variable">BOOTPROTO</span><span class="token operator">=</span>dhcp     <span class="token number">2</span><span class="token assign-left variable">DEVICE</span><span class="token operator">=</span>eth0     <span class="token number">3</span><span class="token assign-left variable">ONBOOT</span><span class="token operator">=</span>yes     <span class="token number">4</span><span class="token assign-left variable">STARTMODE</span><span class="token operator">=</span>auto     <span class="token number">5</span><span class="token assign-left variable">TYPE</span><span class="token operator">=</span>Ethernet     <span class="token number">6</span><span class="token assign-left variable">USERCTL</span><span class="token operator">=</span>no<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux Vim使用</title>
      <link href="/2023/09/01/linux-vim-mo-shi/"/>
      <url>/2023/09/01/linux-vim-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux-Vim使用"><a href="#Linux-Vim使用" class="headerlink" title="Linux Vim使用"></a>Linux Vim使用</h2><h4 id="1-vim简介"><a href="#1-vim简介" class="headerlink" title="1.vim简介"></a>1.vim简介</h4><ul><li>Vim是从 vi 发展出来的一个文本编辑器</li><li>代码补完、编译及错误跳转等方便编程的功能特别丰富</li></ul><p><img src="/././imgc/2.png"></p><h4 id="2-模式"><a href="#2-模式" class="headerlink" title="2.模式"></a>2.模式</h4><p>vim 共分为三种模式，分别是<strong>命令模式</strong>，<strong>输入模式</strong>和<strong>底线命令模式</strong></p><h5 id="1-命令模式："><a href="#1-命令模式：" class="headerlink" title="1.命令模式："></a><strong>1.命令模式：</strong></h5><p>使用 vi/vim，便进入了命令模式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>a.txt  java_home  redis  www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># vi a.txt </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>我们此时按下i，并不会输入一个字符，i被当作了一个命令j进入输入模式。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">                                                                                                    ~                                                                                                        ~                                                                                                        -- INSERT --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以下是常用的几个命令：</p><ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul><h5 id="2-输入模式："><a href="#2-输入模式：" class="headerlink" title="2.输入模式："></a><strong>2.输入模式：</strong></h5><p>在命令模式下按下i就进入了输入模式。输入helloword</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helloword                                                                                                      ~                                                                                                        ~                                                                                                        -- INSERT --<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在输入模式中，可以使用以下按键：</p><ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul><h5 id="3-底线命令模式"><a href="#3-底线命令模式" class="headerlink" title="3.底线命令模式"></a><strong>3.底线命令模式</strong></h5><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p><p>ESC退出输入模式，:就进入了底线命令模式wq保存并退出</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">helloword                          ~                                                                                                        ~                                                                                                        :wq<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><ul><li>q 退出程序</li><li>w 保存文件</li></ul><p>按ESC键可随时退出底线命令模式。</p><p>查看a.txt</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cat a.txt </span>helloword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/././imgc/3.png"></p><h4 id="3-其他指令"><a href="#3-其他指令" class="headerlink" title="3.其他指令"></a>3.其他指令</h4><h5 id="1-命令模式"><a href="#1-命令模式" class="headerlink" title="1.命令模式"></a>1.命令模式</h5><table><thead><tr><th>指令</th><th>说明</th></tr></thead><tbody><tr><td>[Ctrl] + [b]</td><td>屏幕『向上』移动一页</td></tr><tr><td>[Ctrl] + [f]</td><td>屏幕『向下』移动一页</td></tr><tr><td>0 或功能键[Home]</td><td>移动到这一行的最前面字符处</td></tr><tr><td>$ 或功能键[End]</td><td>移动到这一行的最后面字符处</td></tr><tr><td>gg</td><td>移动到这个档案的第一行</td></tr><tr><td>G</td><td>移动到这个档案的最后一行</td></tr><tr><td>/word</td><td>向光标之下寻找一个名称为 word 的字符串</td></tr><tr><td>dd，yy</td><td>删除，复制游标所在的那一整行</td></tr><tr><td>u，[Ctrl]+r</td><td>复原，重做前一个动作</td></tr></tbody></table><h5 id="2-输入模式"><a href="#2-输入模式" class="headerlink" title="2.输入模式"></a>2.输入模式</h5><table><thead><tr><th><strong>i, I</strong></th><th>i 为『从光标处输入』， I 为『所在行的第一个非空格符处开始输入』</th></tr></thead><tbody><tr><td>a,A</td><td>a 为『光标的下一个字符处开始输入』， A 为『从光标的最后一个字符处开始输入』</td></tr><tr><td>o,O</td><td>o 为『光标下一行处输入新的一行』；O 为光标上一行输入新的一行</td></tr><tr><td>r,R</td><td>r 只会取代光标那一个字符一次；R会一直取代，直到按下 ESC 为止</td></tr><tr><td>[Esc]</td><td>退出编辑模式，回到一般模式中</td></tr></tbody></table><h5 id="3-底线命令模式-1"><a href="#3-底线命令模式-1" class="headerlink" title="3.底线命令模式"></a><strong>3.底线命令模式</strong></h5><table><thead><tr><th>:w</th><th>将编辑的数据写入硬盘档案中</th></tr></thead><tbody><tr><td>:w!</td><td>若文件属性为『只读』时，强制写入该档案。</td></tr><tr><td>:q</td><td>离开 vi</td></tr><tr><td>:wq</td><td>储存后离开,若为 :wq! 则为强制储存后离开</td></tr><tr><td>ZZ</td><td>若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</td></tr><tr><td>:set nu</td><td>显示行号</td></tr><tr><td>:set nonu</td><td>取消行号</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2023/09/01/linux-chang-jian-zhi-ling/"/>
      <url>/2023/09/01/linux-chang-jian-zhi-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="1-linux-常用命令"><a href="#1-linux-常用命令" class="headerlink" title="1.linux 常用命令"></a>1.linux 常用命令</h2><p><strong>绝对路径：</strong></p><p>路径的写法，由根目录 / 写起，例如：/usr/share/doc 这个目录。</p><p><strong>相对路径：</strong></p><p>路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成：cd ../man 这就是相对路径的写法。</p><h4 id="1-目录的常用命令"><a href="#1-目录的常用命令" class="headerlink" title="1.目录的常用命令"></a>1.目录的常用命令</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls: 列出目录cd：切换目录pwd：显示目前的目录mkdir：创建一个新的目录rmdir：删除一个空的目录cp: 复制文件或目录rm: 移除文件或目录mv: 移动文件与目录，或修改文件与目录的名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="1-ls选项："><a href="#1-ls选项：" class="headerlink" title="1.ls选项："></a>1.ls选项：</h5><p>选项与参数</p><ul><li>-a ：全部的文件，连同隐藏文件( 开头为 . 的文件) 一起列出来(常用)</li><li>-l ：长数据串列出，包含文件的属性与权限等等数据；(常用)</li></ul><p>将目录下的所有文件列出来(含属性与隐藏档)</p><pre class="line-numbers language-none"><code class="language-none">[root@www ~]# ls -al ~<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-cd选项："><a href="#2-cd选项：" class="headerlink" title="2.cd选项："></a>2.cd选项：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"> <span class="token comment"># 回到根目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd / </span><span class="token comment"># 回到上一级</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd .. </span><span class="token comment"># 表示回到自己的家目录，亦即是 /root 这个目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd ~</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ /<span class="token punctuation">]</span><span class="token comment"># ls</span>bin   dev  home  lib64     media  opt    proc  run   srv  tmp  varboot  etc  lib lost+found  mnt    patch  root  sbin  sys  usr  www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="3-pwd-选项："><a href="#3-pwd-选项：" class="headerlink" title="3.pwd 选项："></a>3.pwd 选项：</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 单纯显示出目前的工作目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ opt<span class="token punctuation">]</span><span class="token comment"># cd ~</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># pwd</span>/root<span class="token comment"># 如果是链接，要显示真实地址，可以使用 -P参数</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ bin<span class="token punctuation">]</span><span class="token comment"># pwd -P</span>/usr/bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-mkdir-（创建新目录）"><a href="#4-mkdir-（创建新目录）" class="headerlink" title="4.mkdir （创建新目录）"></a>4.mkdir （创建新目录）</h5><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-mp<span class="token punctuation">]</span> 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#进入home 创建一个 test 文件夹</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  <span class="token builtin class-name">test</span>www<span class="token comment">#如需 创建多级目录 加这个 -p 的选项</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir -p  test1/test2/test3</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  test1  www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd test1</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test1<span class="token punctuation">]</span><span class="token comment"># ls</span>test2<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test1<span class="token punctuation">]</span><span class="token comment"># cd test2</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test2<span class="token punctuation">]</span><span class="token comment"># ls</span>test3<span class="token comment">#如需指定目录的权限 加-m 表示</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir -m 711 test2</span><span class="token comment">#711表示目录的权限，具体含义如下：</span><span class="token number">711</span>这三位数分别代表所有者、所属组的用户、其他用户；数字 <span class="token number">7</span> 转换为二进制是 <span class="token number">111</span>，即读（r）、写（w）和执行（x）数字 <span class="token number">4</span> 转换为二进制是 011，即只有写和执行权限数字 <span class="token number">1</span> 转换为二进制是 001，即只有执行权限<span class="token comment">#使用 ls -l查看文件权限</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls -l</span>total <span class="token number">20</span>drwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:29 java_homedrwx------ <span class="token number">2</span> redis redis <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">17</span>:45 redisdrwxr-xr-x <span class="token number">3</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:05 test1drwx--x--x <span class="token number">2</span> root  root  <span class="token number">4096</span> Sep  <span class="token number">1</span> <span class="token number">18</span>:14 test2drwx------ <span class="token number">2</span> www   www   <span class="token number">4096</span> Aug <span class="token number">27</span> <span class="token number">14</span>:08 www<span class="token comment">#解析test2的第一列   drwx--x--x </span><span class="token comment">#第一个字符表示文件类型：</span>d 表示目录   （- 表示普通文件，l 表示符号链接等<span class="token punctuation">..</span>.）rwx--x--x    （rwx：读，写，执行；--x：执行；--x：执行）与创建是所设置的一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="5-rmdir-删除空的目录"><a href="#5-rmdir-删除空的目录" class="headerlink" title="5.rmdir ( 删除空的目录 )"></a>5.rmdir ( 删除空的目录 )</h5><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rmdir</span> <span class="token punctuation">[</span>-p<span class="token punctuation">]</span> 目录名称<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#删除刚刚创建test2目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rmdir test2 </span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>-p ：连同上一级『空的』目录也一起删除</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rmdir -p test1/test2/test3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h6 id="注意：这个-rmdir-仅能删除空的目录，你可以使用-rm-命令来删除非空目录"><a href="#注意：这个-rmdir-仅能删除空的目录，你可以使用-rm-命令来删除非空目录" class="headerlink" title="注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录"></a><strong>注意：这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录</strong></h6><h5 id="6-cp-复制文件或目录"><a href="#6-cp-复制文件或目录" class="headerlink" title="6.cp ( 复制文件或目录 )"></a>6.cp ( 复制文件或目录 )</h5><p>语法</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> 来源档<span class="token punctuation">(</span>source<span class="token punctuation">)</span> 目标档<span class="token punctuation">(</span>destination<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li><strong>-a：</strong>相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li><strong>-p：</strong>连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li><strong>-d：</strong>若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li><strong>-r：</strong>递归持续复制，用於目录的复制行为；(常用)</li><li><strong>-f：</strong>为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li><strong>-i：</strong>若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 找一个有文件的目录，我这里找到 root目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd /root</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ ~<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token comment"># 复制 root目录下的install.sh 到 home目录下</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp /root/install.sh /home</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token comment"># 再次复制，加上-i参数，增加覆盖询问？</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp -i /root/install.sh /home</span>cp: overwrite ‘/home/install.sh’? y <span class="token comment"># n不覆盖，y为覆盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="7-rm-移除文件或目录"><a href="#7-rm-移除文件或目录" class="headerlink" title="7.rm ( 移除文件或目录 )"></a>7.rm ( 移除文件或目录 )</h5><p>语法：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>-fir<span class="token punctuation">]</span> 文件或目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>选项与参数：</p><ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 将刚刚在 cp 的实例中创建的 install.sh删除掉！</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># rm -i install.sh</span>rm: remove regular <span class="token function">file</span> ‘install.sh’? y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h5 id="8-mv-移动文件与目录，或修改名称"><a href="#8-mv-移动文件与目录，或修改名称" class="headerlink" title="8.mv  ( 移动文件与目录，或修改名称 )"></a>8.mv  ( 移动文件与目录，或修改名称 )</h5><p>选项与参数：</p><ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">#复制一个文件到当前目录</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cp /root/install.sh /home</span><span class="token comment"># 创建一个文件夹 test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mkdir test</span><span class="token comment"># 将复制过来的文件移动到我们创建的目录，并查看</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mv install.sh test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  redis  <span class="token builtin class-name">test</span>www<span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># cd test</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test<span class="token punctuation">]</span><span class="token comment"># ls</span>install.sh<span class="token comment"># 将文件夹重命名，然后再次查看！</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ test<span class="token punctuation">]</span><span class="token comment"># cd ..</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># mv test mvtest</span><span class="token punctuation">[</span>root@iZwz9bi9r5ta5wwk4bl7xfZ home<span class="token punctuation">]</span><span class="token comment"># ls</span>java_home  mvtest  redis  www<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux概述</title>
      <link href="/2023/09/01/linux-gai-shu/"/>
      <url>/2023/09/01/linux-gai-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Linux简介"><a href="#1-Linux简介" class="headerlink" title="1.Linux简介"></a>1.Linux简介</h2><ol><li><p>Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的。</p></li><li><p>Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX（可移植操作系统接口） 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统。</p></li><li><p>Linux 能运行主要的 UNIX 工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统</p><p>在服务器端，在开发领域linux倒是越来越受欢迎，linux在开源社区的地位依然岿然不动。</p><p>尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p></li></ol><h2 id="2-Linux发行版"><a href="#2-Linux发行版" class="headerlink" title="2.Linux发行版"></a>2.Linux发行版</h2><p><img src="/././imgc/1.png"></p><p>目前市面上较知名的发行版有：<strong>Ubuntu</strong>、RedHat、<strong>CentOS</strong>、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等。</p><h2 id="3-linux-环境搭建"><a href="#3-linux-环境搭建" class="headerlink" title="3.linux 环境搭建"></a>3.linux 环境搭建</h2><h4 id="1-虚拟机安装"><a href="#1-虚拟机安装" class="headerlink" title="1.虚拟机安装"></a>1.虚拟机安装</h4><p>1、可以通过镜像进行安装</p><p>2、安装 VMware 虚拟机软件，然后打开我们的镜像即可使用！</p><h4 id="2-购买云服务器（推荐）"><a href="#2-购买云服务器（推荐）" class="headerlink" title="2.购买云服务器（推荐）"></a>2.购买云服务器（推荐）</h4><p>虚拟机安装后占用空间，也会有些卡顿,选择购买一台自己的服务器，这样的话更加接近真实线上工作.</p><p>1.阿里云购买服务器：<a href="https://www.aliyun.com/">https://www.aliyun.com</a></p><p>2.购买完毕后，获取服务器的ip地址</p><p>3.下载远程连接工具（Xshell,FinalShell等），进行远程连接使用</p><p>4.进行文件下载会比较慢，推荐安装Xftp 配合Xshell（可视化且方便传输）</p><p><a href="https://www.xshell.com/zh/free-for-home-school/">家庭/学校免费 - NetSarang Website (xshell.com)</a>(可授权免费安装)</p><h2 id="4-走近Linux系统"><a href="#4-走近Linux系统" class="headerlink" title="4.走近Linux系统"></a>4.走近Linux系统</h2><h4 id="1-开机"><a href="#1-开机" class="headerlink" title="1.开机"></a>1.开机</h4><p>开机会启动许多程序。它们在Windows叫做”服务”（service），在Linux就叫做”守护进程”（daemon）.</p><p>一般来说，用户的登录方式有三种：</p><ul><li>命令行登录</li><li>ssh登录</li><li>图形界面登录</li></ul><p>最高权限账户为 root，可以操作一切！</p><h4 id="2-关机"><a href="#2-关机" class="headerlink" title="2.关机"></a>2.关机</h4><p>关机指令为：shutdown .</p><p>拓展操作</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sync</span> <span class="token comment"># 将数据由内存同步到硬盘中。</span><span class="token function">shutdown</span> <span class="token comment"># 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：</span><span class="token function">shutdown</span> –h <span class="token number">10</span> <span class="token comment"># 这个命令告诉大家，计算机将在10分钟后关机</span><span class="token function">shutdown</span> –h now <span class="token comment"># 立马关机</span><span class="token function">shutdown</span> –h <span class="token number">20</span>:25 <span class="token comment"># 系统会在今天20:25关机</span><span class="token function">shutdown</span> –h +10 <span class="token comment"># 十分钟后关机</span><span class="token function">shutdown</span> –r now <span class="token comment"># 系统立马重启</span><span class="token function">shutdown</span> –r +10 <span class="token comment"># 系统十分钟后重启</span><span class="token function">reboot</span> <span class="token comment"># 就是重启，等同于 shutdown –r now</span><span class="token function">halt</span> <span class="token comment"># 关闭系统，等同于shutdown –h now 和 poweroff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h4><p>登录系统后，在当前命令窗口下输入命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> /<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>以下是对这些目录的解释：</strong></p><ul><li><strong>/bin</strong>：bin是Binary的缩写, 这个目录存放着最经常使用的命令。</li><li><strong>/boot：</strong> 这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</li><li><strong>/dev ：</strong> dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</li><li><strong>/etc：</strong> 这个目录用来存放所有的系统管理所需要的配置文件和子目录。</li><li><strong>/home</strong>：用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。</li><li><strong>/lib</strong>：这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。</li><li><strong>/lost+found</strong>：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</li><li><strong>/media</strong>：linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</li><li><strong>/mnt</strong>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</li><li><strong>/opt</strong>：这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</li><li><strong>/proc</strong>：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。</li><li><strong>/root</strong>：该目录为系统管理员，也称作超级权限者的用户主目录。</li><li><strong>/sbin</strong>：s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</li><li><strong>/srv</strong>：该目录存放一些服务启动之后需要提取的数据。</li><li><strong>/sys</strong>：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs 。</li><li><strong>/tmp</strong>：这个目录是用来存放一些临时文件的。</li><li><strong>/usr</strong>：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录。</li><li><strong>/usr/bin：</strong> 系统用户使用的应用程序。</li><li><strong>/usr/sbin：</strong> 超级用户使用的比较高级的管理程序和系统守护程序。</li><li><strong>/usr/src：</strong> 内核源代码默认的放置目录。</li><li><strong>/var</strong>：这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。</li><li><strong>/run</strong>：是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象</title>
      <link href="/2023/08/30/c-mian-xiang-dui-xiang/"/>
      <url>/2023/08/30/c-mian-xiang-dui-xiang/</url>
      
        <content type="html"><![CDATA[<h2 id="C-面向对象"><a href="#C-面向对象" class="headerlink" title="C++面向对象"></a>C++面向对象</h2><p>public 共有成员<br>谁都可以访问(使用/调用)<br>protected保护成员<br>只有自己和子类可以访问<br>private 私有成员<br>只有自己（类内部）可以访问<br>成员访问<br>访问限定符仅作用于类，因此同一个类的不同对象，可以相互访问非共有部分。<br>类和结构体区别<br>在C++中，类和结构没有本质区别，唯一不同在于<br>类的默认访问控制属性为private<br>结构的默认访问控制属性为public<br>封装<br>对不同成员的控制访问属性加以区分，体现了C++作为面向对象语言的封装特性</p><h3 id="在栈中创建对象"><a href="#在栈中创建对象" class="headerlink" title="在栈中创建对象"></a>在栈中创建对象</h3><p>在栈中创建一个对象<br>格式: 类名 对象名<br>People people;<br>在栈中创建多个对象<br>类名 对象数组名[元素个数]</p><h3 id="在堆中创建对象"><a href="#在堆中创建对象" class="headerlink" title="在堆中创建对象"></a>在堆中创建对象</h3><p>在堆中创建单个对象</p><p>类名 *指针名 = new 类名<br>People *sirius = new People;<br>在堆中创建多个对象<br>类名 *对象数组指针名 = new 类名[元素个数]<br><img src="/././imgc/1686015643781.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class dog{public:    void eat()    {        cout &lt;&lt; "吃饭";    }    void run()    {        cout &lt;&lt; "跑步";    }    void sleep()    {        cout &lt;&lt; "睡觉";    }private:    string name, kind, color;    int age;};int main(){    // 堆区创建对象    cout &lt;&lt; "我是堆区的对象" &lt;&lt; endl;    dog *dui = new dog();    dui-&gt;eat();    dui-&gt;run();    dui-&gt;sleep();    cout &lt;&lt; endl;    // 栈区创建对象    dog zhan;    cout &lt;&lt; "我是栈区的对象" &lt;&lt; endl;    zhan.eat();    zhan.run();    zhan.sleep();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是堆区的对象<br>吃饭跑步睡觉<br>我是栈区的对象<br>吃饭跑步睡觉</p><p><img src="/././imgc/1686015729660.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{  private:    int sno,        grade;};int main(){    // 指针数组的方式创建对象    student *p[4];    for (int i = 0; i &lt; 4; i++)    {        p[i] = new student; // 让数组中的每一个指针指向一个对象    }    cout &lt;&lt; sizeof(p) &lt;&lt; endl;    // 一次性创建4个对象    student *q = new student[4];    cout &lt;&lt; sizeof(q);}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>32<br>8</p><h3 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h3><p>构造函数为什么要放在public<br>在外部实例化对象时自动调用构造函数，如果是其他访问方式，没办法调用构造函数，也就不能实例化对象</p><p>构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。<br>一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。</p><h3 id="参数初始化表"><a href="#参数初始化表" class="headerlink" title="参数初始化表"></a>参数初始化表</h3><p>注意，参数初始化顺序与初始化表列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。<br>如果用户没有定义，编译器会自动生成一个默认的析构函数。这个析构函数的函数体是空的，也没有形参，也不执行任何操作。</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class student{public:    student(int a, int b) : sno(a), grade(b)    {        cout &lt;&lt; "我是构造有参数" &lt;&lt; endl;    };    student()    {        cout &lt;&lt; "我是构造无参数" &lt;&lt; endl;    };    ~student() // 不能被重载    {        cout &lt;&lt; "我是析构" &lt;&lt; endl;    }private:    int sno,        grade;};int main(){    student *p = new student(3, 4);    student *q = new student[4];    delete p;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造有参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是构造无参数<br>我是析构</p><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p>成员函数最终被编译成与对象无关的普通函数，除了成员变量，会丢失所有信息，所以编译时要在成员函数中添加一个额外的参数，把当前对象的首地址传入，以此来关联成员函数和成员变量。这个额外的参数，实际上就是 this，它是成员函数和成员变量关联的桥梁。它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。</p><h3 id="类中const成员"><a href="#类中const成员" class="headerlink" title="类中const成员"></a>类中const成员</h3><ol><li>const成员变量<br>必须使用初始化参数列表，初始化后不能修改</li><li>const成员函数<br>const成员函数不能修改基本成员变量。不能调用非const成员函数</li><li>const对象<br>对象中的数据成员不允许被改变。<br>常对象只能调用常成员函数</li></ol><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    const int a;//常数据成员    int b;    void fun() const//常成员函数    {        cout &lt;&lt; "我是常成员函数";    }     Test(int c) : a(c) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;a &lt;&lt; this-&gt;b &lt;&lt; endl; }};int main(){    const Test p1(2);//常对象    p1.fun();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>我是构造函数20<br>我是常成员函数</p><h3 id="拷贝构造函数（复制构造函数）"><a href="#拷贝构造函数（复制构造函数）" class="headerlink" title="拷贝构造函数（复制构造函数）"></a>拷贝构造函数（复制构造函数）</h3><p><img src="/././imgc/1686376068957.png"></p><p>同构造函数一样，如果用户不提供拷贝构造函数，编译器提供默认拷贝构造函数。<br><strong>注意：因为拷贝构造函数属于构造函数，有的编译器会在用户提供构造函数的时候也不再提供拷贝构造。</strong></p><h4 id="浅拷贝（复制地址）"><a href="#浅拷贝（复制地址）" class="headerlink" title="浅拷贝（复制地址）"></a>浅拷贝（复制地址）</h4><p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间，<strong>当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。</strong></p><p><img src="/././imgc/1686397072070.png"></p><h4 id="深拷贝（复制内存）"><a href="#深拷贝（复制内存）" class="headerlink" title="深拷贝（复制内存）"></a>深拷贝（复制内存）</h4><p>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的。<strong>拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</strong></p><p><img src="/././imgc/1686397184821.png"></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    int a;    char *name;    Test(int c, char *name) : a(c), name(name) { cout &lt;&lt; "我是构造函数" &lt;&lt; this-&gt;name &lt;&lt; endl; }    Test(const Test &amp;TestA) { cout &lt;&lt; "我是拷贝构造函数" &lt;&lt; TestA.name &lt;&lt; endl; }    ~Test() { cout &lt;&lt; "我是析构" &lt;&lt; endl; }};int main(){    Test *p1 = new Test(2, "张三");    Test *p2 = new Test(*p1); // 拷贝构造函数Test(const Test &amp;);    delete p1;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>我是构造函数张三<br>我是拷贝构造函数张三<br>我是析构</p><h3 id="类static成员"><a href="#类static成员" class="headerlink" title="类static成员"></a>类static成员</h3><ul><li>静态成员在类的所有对象中是公有的</li><li>内存是程序运行时分配</li><li>使用前必须初始化且只能初始化一次</li><li>初始化不能在类定义中，通过作用域限定符初始化</li><li>优点<br>static成员的名字是在类的作用域中，因此可以<strong>避免与其它类成员或全局对象名字冲突。</strong><br>可以实施封装，<strong>static成员可以是私有的，而全局对象不可以。</strong><br>阅读程序容易看出static成员与某个类相关联，这种<strong>可见性可以清晰地反映程序员的意图</strong></li></ul><p>类型 类名 :: 变量名=值；</p><h3 id="static成员函数"><a href="#static成员函数" class="headerlink" title="static成员函数"></a>static成员函数</h3><ul><li>不再属于对象，不需要通过对象访问</li><li><strong>static成员函数没有this指针</strong>，所以静态成员函数不可以访问非静态成员。只能访问静态成员（静态成员和静态变量）</li><li>非静态成员函数可以访问静态成员</li></ul><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span>class Test<span class="token punctuation">{</span>public<span class="token operator">:</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> Test<span class="token operator">::</span>b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    Test t1<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span>b<span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> Test<span class="token operator">::</span>b<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单例模式-待"><a href="#单例模式-待" class="headerlink" title="单例模式(待)"></a>单例模式(待)</h3><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><p>友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，<strong>但是友元函数并不是成员函数。</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Test{public:    friend void fun(const Test &amp;a);    Test(int a) : b(a) {}private:    int b;};void fun(const Test &amp;a){    cout &lt;&lt; a.b &lt;&lt; "我是友元函数" &lt;&lt; endl;}int main(){    Test a(2);    fun(a);    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2我是友元函数</p><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。</p><p><strong>只有友元可以访问，其他依然不能访问</strong>。若类B是类A的友元。则只有类B的成员函数可以访问类A中的隐藏信息</p><p><strong>友元是单向的，不具有交换性</strong>。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p><p><strong>友元关系不具有传递性</strong>。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p><h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 引用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言进阶篇</title>
      <link href="/2023/08/30/c-yu-yan-jin-jie-pian/"/>
      <url>/2023/08/30/c-yu-yan-jin-jie-pian/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言进阶篇"><a href="#C语言进阶篇" class="headerlink" title="C语言进阶篇"></a>C语言进阶篇</h1><p>本文是对</p><p>文章进行的学习总结</p><h2 id="结构体的介绍"><a href="#结构体的介绍" class="headerlink" title="结构体的介绍"></a>结构体的介绍</h2><h3 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a>结构体的定义</h3><h4 id="第一种直接struct-加结构体名定义"><a href="#第一种直接struct-加结构体名定义" class="headerlink" title="第一种直接struct 加结构体名定义"></a>第一种直接struct 加结构体名定义</h4><p>struct  结构体名</p><p>{ </p><p>类型 属性名；</p><p>类型 属性名；</p><p>….</p><p>类型 属性名；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token comment">//student为结构体名</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span><span class="token comment">//结构的属性</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span>a<span class="token punctuation">;</span><span class="token comment">//a为结构体变量一种定义变量的方式1</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">//struct student a;//这也是一种定义变量的方式2</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为10a。</p><h4 id="第二种利用typedef-struct-结构体名定义结构体"><a href="#第二种利用typedef-struct-结构体名定义结构体" class="headerlink" title="第二种利用typedef struct 结构体名定义结构体"></a>第二种利用typedef struct 结构体名定义结构体</h4><p>typedef struct 结构体名{</p><p>类型 属性名；</p><p>类型 属性名；</p><p>…</p><p>类型 属性名；</p><p>}m;<em>//struct student 是数据类型，typedef 数据类型 p，p就是（struct student）只是重新修改了而已</em></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> m<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    m a<span class="token punctuation">;</span><span class="token comment">//定义结构体变量名a</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a。</p><h4 id="第三种嵌套定义结构体"><a href="#第三种嵌套定义结构体" class="headerlink" title="第三种嵌套定义结构体"></a>第三种嵌套定义结构体</h4><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>struct 结构体名</p><p>{</p><p>属性名：属性值；</p><p>属性名：属性值；</p><p>}</p><p>属性名：属性值；</p><p>}</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">teacher</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> b<span class="token punctuation">;</span>     <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>b<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果也为10a</p><h4 id="结构体数组"><a href="#结构体数组" class="headerlink" title="结构体数组"></a>结构体数组</h4><p>定义格式和一般定义结构差不多，只是变量名为数组。每一个数组都有结构体的属性。但属性值要分别定义。以下用循环定义每一个结构体数组的属性值。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>打印结构为</p><p>10a</p><p>10a。</p><h4 id="计算结构体所占用的内存"><a href="#计算结构体所占用的内存" class="headerlink" title="计算结构体所占用的内存"></a>计算结构体所占用的内存</h4><p>结构体的内存存储讲究对齐法则。<strong>所有属性所占的内存向占最大内存的那个属性对齐</strong>，例如计算以下结构体所占内存，char类型占1个字节，而int类型占4个字节，所以char类型向int类型对齐，则以下结构体所占内存为8。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>`<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为8。</p><p><img src="/././imgc/1685427766651.png"></p><p>以上为student结构体在内存的情况，0-3为整型类型num的存储空间，4-7为char类型sex的存储空间。</p><h2 id="共用体的简单介绍"><a href="#共用体的简单介绍" class="headerlink" title="共用体的简单介绍"></a>共用体的简单介绍</h2><p>上述结构体所占内存可见非常废内存，char类型占用1个字节就占一个字节，为什么占用4个字节，所以共用体就比较节约内存了。<strong>共用体内存看所占内存最大的那个类型。其他类型共用它的内存。</strong></p><p>共用体的定义和结构体的定义差不多，结构体定义所用的关键字为struct，共用体的定义所用关键字为union。所以以下仅对共用体所占内存进行描述。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">union</span> student<span class="token punctuation">{</span>    <span class="token keyword">char</span> uni<span class="token punctuation">;</span>    <span class="token keyword">char</span> sex<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>uni <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>uni<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">union</span> student<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上代码的结果为</p><p>a</p><p>a</p><p>1。</p><p><img src="/././imgc/1685428496266.png" alt="1685428496266"></p><p>以上为共用体的占用内存情况，uni和sex，因为uni和sex都仅占一个内存，所以赋值进行的覆盖，先赋值b，如何赋值a，但共用一个内存，所以a覆盖了b。</p><h2 id="枚举的介绍"><a href="#枚举的介绍" class="headerlink" title="枚举的介绍"></a>枚举的介绍</h2><p>之前介绍了结构体和共用体，结构体的关键字为struct，共用体的关键字为union，而枚举定义的关键字为enum。枚举类型简化了#define定义多个值的操作</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">,</span>    b<span class="token punctuation">,</span>    c<span class="token punctuation">,</span>    d<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//week为枚举名，p为枚举变量</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结果为0123。可以认为枚举中的变量值从0开始赋值。</p><h4 id="枚举的简单应用"><a href="#枚举的简单应用" class="headerlink" title="枚举的简单应用"></a>枚举的简单应用</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token comment">//枚举名</span><span class="token punctuation">{</span>    first<span class="token punctuation">,</span>    two<span class="token punctuation">,</span>    three<span class="token punctuation">,</span>    four<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token comment">//枚举的变量名p</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span>k<span class="token punctuation">;</span><span class="token comment">//对枚举变量进行赋值的变量也要是枚举类型，所以这里要进行强制类型转换</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span>        <span class="token punctuation">{</span>        <span class="token keyword">case</span> first<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"first"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> two<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> three<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> four<span class="token operator">:</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为first。可以认为枚举变量中存储了</p><h4 id="枚举所占空间"><a href="#枚举所占空间" class="headerlink" title="枚举所占空间"></a>枚举所占空间</h4><p>C++标准文档中是这样说明的：“<strong>枚举类型的尺寸是以能够容纳最大枚举子的值的整数的尺寸</strong>”，同时标准中也说名了：“<strong>枚举类型中的枚举子的值必须要能够用一个int类型表述</strong>”。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">{</span>    a<span class="token punctuation">}</span> p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">enum</span> <span class="token class-name">week</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>无论怎么添加枚举中的成员，输出的结果都为4个字节即一个整型类型的大小</p><h2 id="指针变量的介绍"><a href="#指针变量的介绍" class="headerlink" title="指针变量的介绍"></a>指针变量的介绍</h2><p>变量有int类型 char类型 doubke类型等等,指针变量也有同样的类型,不过指针的值是一个变量的地址,,<strong>实际上的是指针指向的是变量的地址</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> <span class="token comment">// 定义了一个整型类型的指针</span>    <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>    a <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>             <span class="token comment">// 指针变量a指向整型变量b的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a指向变量的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 打印a指向的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 打印指针a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 打印变量b的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上输出的结果为</p><p>8<br>6487572<br>6487576<br>6487572</p><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>  <span class="token keyword">struct</span> <span class="token class-name">student</span>    <span class="token punctuation">{</span>        <span class="token keyword">int</span> num<span class="token punctuation">;</span>        <span class="token keyword">char</span> sex<span class="token punctuation">;</span>    <span class="token punctuation">}</span> a<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// a为结构体变量,p为结构体指针,p指向a的地址</span>    a<span class="token punctuation">.</span>num <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    a<span class="token punctuation">.</span>sex <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span>sex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10a</p><p>10a</p><h4 id="void类型的指针"><a href="#void类型的指针" class="headerlink" title="void类型的指针"></a>void类型的指针</h4><p>C语言中的void类型，代表任意类型，而不是空的意思，而是说它的类型是未知的，是还没指定的。<br>void * 是void类型的指针。void类型的指针的含义是：这是一个指针变量，该指针指向一个<br>void类型的数。void类型的数就是说这个数有可能是int，也有可能是float，也有可能是个结构体，哪种类型都有可能，只是我当前不知道。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">char</span> b <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>                    <span class="token comment">// p指向这个地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是int类型的，所以要强制转换成对应类型的指针</span>    p <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 因为这个数据是char类型的，所以要强制转换成对应类型的指针</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>a</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p><strong>函数指针是实质上就是一个指针，不过他指向的是一个函数的地址。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//定义了一个函数指针</span>    p <span class="token operator">=</span> sum<span class="token punctuation">;</span><span class="token comment">//函数指针指向sum函数</span>    <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span>     <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用指针进行函数的调用</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> sum<span class="token punctuation">;</span>    sum <span class="token operator">=</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>9<br>9</p><h4 id="指针函数（和函数指针区别）"><a href="#指针函数（和函数指针区别）" class="headerlink" title="指针函数（和函数指针区别）"></a>指针函数（和函数指针区别）</h4><p>说到函数指针就不得不提到指针函数了，<strong>指针函数实质上是一个函数不过返回的是一个指针</strong>。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">;</span>      <span class="token comment">// 定义一个指针用来接收返回的地址</span>    p <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 指针p接收指针函数的返回的指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>max<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>    <span class="token punctuation">{</span>        max <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> max<span class="token punctuation">;</span> <span class="token comment">// 返回一个指针，这个指针指向的是最大值的地址</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h4><p>数组指针同理，<strong>本质上也是一个指针不过指向的是一个数组</strong>，直接上代码感觉下面的代码已经很详细了</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> b<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个二维数组的指针，注意要[3]为该数组指针的边界值</span>    p <span class="token operator">=</span> b<span class="token punctuation">;</span>      <span class="token comment">// 二维数组指针指向b数组</span>    <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 定义了一个一维数组的指针</span>    q <span class="token operator">=</span> a<span class="token punctuation">;</span>      <span class="token comment">// 一维数组指针指向a数组</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>q <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>p <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注意如果没有给出数组指针p的[3]这个边界值*(p+1)会报错说没有给出指针的边界值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出的结果为</p><p>2<br>5</p><h4 id="指针数组（和数组指针区别）"><a href="#指针数组（和数组指针区别）" class="headerlink" title="指针数组（和数组指针区别）"></a>指针数组（和数组指针区别）</h4><p>同理，<strong>指针数组是一个是数组不过里面存放的是指针。</strong></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 定义了一个指针数组</span>    a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    b <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    c <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span> <span class="token comment">// 数组里面的元素指向一个地址</span>    p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出指向地址的值</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>2</p><p>3</p><p>4</p><h4 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span><span class="token operator">*</span>p1 <span class="token operator">=</span> <span class="token operator">&amp;</span>p<span class="token punctuation">;</span>        <span class="token comment">// 指向这个指针</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> p1<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// p1的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%p\n"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a的地址</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a的值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>5<br>000000000062FE08<br>000000000062FE14<br>000000000062FE14<br>5</p><h2 id="链表的介绍"><a href="#链表的介绍" class="headerlink" title="链表的介绍"></a>链表的介绍</h2><p>理解为一种思想，用结构体指针来实现的，结构体中的成员包括数据和结构体指针，结构体中的结构体指针指向的是下个结构体的地址，即用结构体中的结构体指针来链接各个结构体，整体称谓链表，那么有了链表就需要一个头指针来输出他，可以理解链表是多米诺骨牌，牌已经摆好了，只用推一下这个链表就展现到你眼前了，而这个推一下的动作就是头指针，</p><p><img src="/././imgc/1685508777711.png" alt="1685508777711"></p><h3 id="第一种静态链表的介绍与实现"><a href="#第一种静态链表的介绍与实现" class="headerlink" title="第一种静态链表的介绍与实现"></a>第一种静态链表的介绍与实现</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> score<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 创建一个节点</span><span class="token punctuation">}</span> p<span class="token punctuation">;</span>                      <span class="token comment">// 重新定义了struct student这个类型</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    p a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">// 给结构体变量赋值</span>    b<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    d<span class="token punctuation">.</span>score <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>     <span class="token comment">// 头指针保存a的地址</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>   <span class="token comment">// a的节点保存结构体变量b的地址</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>   <span class="token comment">// b的节点保存结构体变量c的地址</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>   <span class="token comment">// c的节点保存结构体变量d的地址</span>    d<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 给最后一个节点写个内容 用于判断节点是否已经遍历完成</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token comment">// 头指针如果没有保存最后一个节点的内容 就一直遍历</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d  "</span><span class="token punctuation">,</span> head<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 遍历score</span>        head <span class="token operator">=</span> head<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>           <span class="token comment">// 把结构体中的next指针赋值给head结构体指针，则head指针指向的是下一个节点的地址。</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10  20  30  40 </p><h3 id="第二种动态链表的介绍与实现"><a href="#第二种动态链表的介绍与实现" class="headerlink" title="第二种动态链表的介绍与实现"></a>第二种动态链表的介绍与实现</h3><p>静态链表是提前知道了有几个结构体变量，而实际上我们并不知道我们需要10个或者100个结构体变量来满足我们的需求，所以我们就需要一个动态的链表，我们需要多少它就给多少。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>next<span class="token punctuation">;</span> <span class="token comment">// 定义结构体指用来指向下一个结构体的地址</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token comment">// 定义结构体指针函数用来动态定义链表并返回链表的头指针</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> q <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>new<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">,</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>                       <span class="token comment">// head指针指向链表的头指针，new指针指向新创建的结构体地址，last指针指向链表最后一个结构体</span>    head <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 先给头指针分配内存空间，不分配默认为4个字节</span>    last <span class="token operator">=</span> head<span class="token punctuation">;</span>                                             <span class="token comment">// 尾指针指向链表的最后一个结构体的地址</span>    head<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>a<span class="token operator">--</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        q<span class="token operator">++</span><span class="token punctuation">;</span>        new <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">student</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 给新添加的结点分配内存空间</span>        new<span class="token operator">-&gt;</span>a <span class="token operator">=</span> q<span class="token punctuation">;</span>        last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> new<span class="token punctuation">;</span> <span class="token comment">// 链表与新创建的结构体链接起来</span>        last <span class="token operator">=</span> new<span class="token punctuation">;</span>       <span class="token comment">// 尾指针指向链表的最后一个结构体地址</span>    <span class="token punctuation">}</span>    last<span class="token operator">-&gt;</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span> <span class="token comment">// 尾指针的值为空代表链表结束</span>    <span class="token keyword">return</span> head<span class="token punctuation">;</span>       <span class="token comment">// 返回链表的头节点</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> c<span class="token punctuation">;</span>    <span class="token keyword">struct</span> <span class="token class-name">student</span> <span class="token operator">*</span>p<span class="token punctuation">;</span> <span class="token comment">// 用来接收链表的头节点</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment">// 循环遍历链表并输出值</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入5</p><p>输出的结果为01234</p><p>注意上述malloc分配的地址空间是连续的，比如为int *p整型指针分配8个字节，则8个字节的内存空间是连续的，并且可以用 *(p+0)和 *(p+1)来分别为其赋值。</p><h2 id="关键字的介绍"><a href="#关键字的介绍" class="headerlink" title="关键字的介绍"></a>关键字的介绍</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break<strong>用于打断循环，也就是执行到break，直接跳出循环，</strong>可以打断for，switch，while，do..while。break可以跳出for，但是如果用一个以上的for，则是打断离它最近的for。</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue<strong>用于跳出本次循环，不是退出循环，而是只跳出本次的循环</strong></p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>1.修饰全局变量，如果static修饰了全局变量，那只能在本工程使用，其他工程就不能调用了，</p><p>2.修饰局部变量，它是存储在静态存储区的，用static修饰过后，就是函数执行结束，值依然在，如果static未被赋值，默认值就是 0；</p><p>3.static修饰函数，函数也只能在本工程使用，其他工程不可调用。</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 修饰局部变量</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    i<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>12<br>11</p><h3 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;malloc.h&gt;</span></span><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">extern</span> <span class="token keyword">int</span> y<span class="token punctuation">;</span> <span class="token comment">// 注用extern修饰的变量要提前赋值且不能在为其赋值了，不然会报错。</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token function">fun1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>0<br>1</p><h3 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h3><p>C语言允许为一个数据类型起一个新的别名，就像给人起“绰号”一样。起别名的目的不是为了提高程序运行效率，而是为了编码方便。</p><p>例如 typedef int a;表示的是为int取别名a，之后定int类型的变量可以 a  b；来定义一个整型变量b</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>1.对变量声明只读特性，保护变量值以防被修改</p><p>2.节省空间，避免不必要的内存分配。const修饰的变量在程序运行过程中只有一份拷贝</p><h3 id="define-无参"><a href="#define-无参" class="headerlink" title="#define 无参"></a>#define 无参</h3><p>#define 既不是定义，也不是声明，所以是不分配内存的，#define说白了就是替换的意思。</p><p>#define 宏名 字符串</p><h3 id="define-有参"><a href="#define-有参" class="headerlink" title="#define 有参"></a>#define 有参</h3><p>带参就是跟函数一样可以代替一些操作。</p><p>#define N(y) ((y)*(y))</p><h3 id="if"><a href="#if" class="headerlink" title="#if"></a>#if</h3><p>#if N </p><p>…</p><p>#else</p><p>…</p><p>如果N为真执行#if和#else之间的语句，否则执行#else之后的语句</p><h3 id="写过的题目"><a href="#写过的题目" class="headerlink" title="写过的题目"></a>写过的题目</h3><h4 id="一-链表的反转"><a href="#一-链表的反转" class="headerlink" title="一.链表的反转"></a>一.链表的反转</h4><p><img src="/././imgc/1685792379205.png" alt="1685792379205"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token punctuation">;</span><span class="token punctuation">}</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>head<span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span><span class="token function">ReverseList</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>pHead<span class="token punctuation">)</span><span class="token comment">//反转的指针函数</span><span class="token punctuation">{</span>    <span class="token comment">// write code here</span>    <span class="token keyword">struct</span> <span class="token class-name">ListNode</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token operator">*</span>q<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>pHead <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        p <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>pHead<span class="token operator">-&gt;</span>next <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            q <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> pHead<span class="token punctuation">;</span>            pHead <span class="token operator">=</span> pHead<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>            p<span class="token operator">-&gt;</span>next <span class="token operator">=</span> q<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        pHead<span class="token operator">-&gt;</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span><span class="token comment">//遍历完之后要把头结点指向p</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> pHead<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    a<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    b<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    c<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    head <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>    a<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>b<span class="token punctuation">;</span>    b<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token operator">&amp;</span>c<span class="token punctuation">;</span>    c<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>    p <span class="token operator">=</span> <span class="token function">ReverseList</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> p<span class="token operator">-&gt;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>        p <span class="token operator">=</span> p<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用了两个指针，q和p分别指向头结点的前两个结点，可以说头节点带着q和p去找链表的结点，p改变结点的指向，</p><p>q保存了被指向的结点。</p><p>输出结果为321</p><h4 id="二-链表的合并"><a href="#二-链表的合并" class="headerlink" title="二.链表的合并"></a>二.链表的合并</h4><p><img src="/././imgc/1685875845805.png" alt="1685875845805"></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     struct ListNode *next; * }; */</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list1<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">ListNode</span><span class="token operator">*</span> list2<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list2<span class="token operator">==</span><span class="token constant">NULL</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//前面两个条件剔除了空链表的情况</span>    <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>val<span class="token operator">&lt;</span>list2<span class="token operator">-&gt;</span>val<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        list1<span class="token operator">-&gt;</span>next<span class="token operator">=</span> <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token operator">-&gt;</span>next<span class="token punctuation">,</span>list2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//让最小的节点指向下一次遍历返回的结果</span>        <span class="token keyword">return</span> list1<span class="token punctuation">;</span><span class="token comment">//返回较小的节点</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span>     <span class="token punctuation">{</span>        list2<span class="token operator">-&gt;</span>next<span class="token operator">=</span><span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span>list2<span class="token operator">-&gt;</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> list2<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>本题用到了递归算法，每次把两个链表较小的那个结点放入栈 的最低端，一直到其中一个链表遍历完，如何释放，得到链表的头结点点。</p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 结构体 </tag>
            
            <tag> 指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本篇</title>
      <link href="/2023/08/30/c-ji-chu-pian/"/>
      <url>/2023/08/30/c-ji-chu-pian/</url>
      
        <content type="html"><![CDATA[<p>C++学习（进阶加基础）</p><p>本文笔记链接</p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>C++有自己的头文件，例如iostream 没有.h<br>也可以用C的头文件 例如stdio.h 有.h<br>或者将C文件C++化 例如<a href="https://so.csdn.net/so/search?q=cstdio&amp;spm=1001.2101.3001.7020">cstdio</a> 前面加c没有.h</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>1.划分逻辑单元。避免名字冲突，</p><p>2.同名的命名空间可以合并，有时候一个名字空间太冗余或者其他原因需要分开实现在不同地方，</p><p>3.声明和定义分开，在命名空间中声明的函数，定义时要加：：作用域限定符。</p><p>4.命名空间可以嵌套，调用时则用a：：b：：要调用的对象。</p><p>5.using namespace 名字空间名<br>使用后该名字空间对于当前作用域可见，可以不再使用作用域限定符，一旦使用，不可再隐藏。<br>std名字空间全局可见。std标准库定义名字空间。</p><h3 id="：：作用域限定符"><a href="#：：作用域限定符" class="headerlink" title="：：作用域限定符"></a>：：作用域限定符</h3><p>表示：：后面的内容属于：：前面。翻译成中文就是 的<br>如果：：前面没有内容表示全局</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;namespace a{    char name = 'a';    void eat()    {        cout &lt;&lt; "吃饭" &lt;&lt; endl;    }}namespace b{    char name = 'a';    void eat()    {        cout &lt;&lt; "喝水" &lt;&lt; endl;    }}int main(){    a::eat();    b::eat();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果</p><p>吃饭<br>喝水</p><h3 id="bool类型"><a href="#bool类型" class="headerlink" title="bool类型"></a>bool类型</h3><ul><li>true表示真 单字节整数1</li><li>false表示假 单字节整数0</li></ul><p>boolalpha bool类型使用字符输出<br>noboolalpha bool关闭字符输出，数值输出</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    bool b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> boolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"字符输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> noboolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"数值输出"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl         <span class="token operator">&lt;&lt;</span> <span class="token string">"内存大小"</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>字符输出true<br>数值输出1<br>内存大小1</p><h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><ul><li>用函数已被编译好的二进制代码，替换对该函数的调用指令。提高效率，避免函数调用开销。</li><li><strong>使用inline关键字期望该函数被优化为内联，是否内联由编译器决定</strong>。</li><li>内联会使可执行文件内存变大，只有频繁调用的简单函数适合内联。复杂函数和递归函数都不适合内联。</li></ul><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>同一作用域中，函数名相同，参数表不同的函数。重载和返回值和参数名没有关系。</p><blockquote><p>函数作用域不是定义决定的，是声明决定的。</p></blockquote><blockquote><p>重载是编译器通过换名实现，<br>在linux下 用gcc -c 获取.o 使用nm .o文件查看<br>在windows下查看obj文件，或者不定义函数，只声明和使用<br>通过extern “C”可以要求C++编译器按照C方式处理函数接口</p></blockquote><h4 id="缺省参数和哑元"><a href="#缺省参数和哑元" class="headerlink" title="缺省参数和哑元"></a>缺省参数和哑元</h4><p>为函数指定缺省值，调用时若未指定实参，则对应的形参取缺省值</p><h4 id="缺省参数的特点"><a href="#缺省参数的特点" class="headerlink" title="缺省参数的特点"></a>缺省参数的特点</h4><ol><li>最好在函数声明中指定。可以利用声明改缺省值。</li><li>禁止在声明和定义同时指定缺省参数。可能不一致，编译器禁止</li><li>缺省参数只能在最后，即你某个参数指定为缺省参数，后面所有参数都要有缺省值</li><li>不要因为是用缺省参数导致重载歧义</li></ol><p>只指定类型而不指定名称的函数参数，叫做哑元。<br>使用哑元1.兼容之前版本。二.形成函数重载</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>引用（reference）是c++对c语言的重要扩充。<br>引用就是某一变量（内存）的一个别名，对引用的操作与对变量直接操作完全一样。其格式为：<br>类型 &amp;引用变量名 = 已定义过的变量名。</p><p>&amp;符号：跟在类型后是引用，没有类型是取地址<br>*符号：跟在类型后是指针，没有类型是解引用</p><h4 id="引用的特点"><a href="#引用的特点" class="headerlink" title="引用的特点"></a>引用的特点</h4><ul><li>一个变量可取多个别名。</li><li>引用必须初始化，不能为空。</li><li>引用只能在初始化的时候引用一次 ，不能更改为转而引用其他变量</li></ul><h4 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h4><p>引用变量和被引用的变量虽然是同一个变量，但是可以被不同修饰符修饰</p><h4 id="引用做参数"><a href="#引用做参数" class="headerlink" title="引用做参数"></a>引用做参数</h4><ul><li>节省空间+提高效率</li><li>值传递，形参生成局部临时变量接收实参的值。</li><li>引用传递，形参是实参的别名</li><li>指针传递，传入实参的地址，指针通过地址访问修改值</li></ul><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;void fun1(int a){    a += 1;}void fun2(int &amp;a){    a += 1;}void fun3(int *a){    *a += 1;}int main(){    int a = 10;    fun1(a);    cout &lt;&lt; a &lt;&lt; endl;    fun2(a);    cout &lt;&lt; a &lt;&lt; endl;    fun3(&amp;a);    cout &lt;&lt; a &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>10<br>11<br>12</p><h4 id="引用做函数返回值"><a href="#引用做函数返回值" class="headerlink" title="引用做函数返回值"></a>引用做函数返回值</h4><p>当引用做函数的返回值时: 函数可以放在赋值语句的左边(可以当左值)</p><p>实现了动态引用</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int &amp;fun1(int &amp;a){    return a;}int main(){    int b;    int c = 3;    int d = 4;    fun1(b) = c;    cout &lt;&lt; b &lt;&lt; endl;    fun1(b) = d;    cout &lt;&lt; b &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输出结果为</p><p>3<br>4</p><h3 id="动态分配-内存池"><a href="#动态分配-内存池" class="headerlink" title="动态分配+内存池"></a>动态分配+内存池</h3><h4 id="动态分配"><a href="#动态分配" class="headerlink" title="动态分配"></a>动态分配</h4><p>C语言使用malloc来动态分配内存空间，free释放内存空间，C++使用new和delete来创建和释放内存空间</p><p>在分配内存的同时初始化 int *p=new int(100);表示 *p的值为100；数组方式new的需要以数组方式delete</p><p>int *p = new int[2]{4, 2};  delete [ ]p;</p><h4 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h4><p>预先分配好，放到进程空间的内存块，用户申请与释放内存其实都是在进程内进行,遇到小对象时就是基于内存池的。只有当内存池空间不够时，才会再从系统找一块很大的内存</p><h3 id="引用和指针的区别和联系"><a href="#引用和指针的区别和联系" class="headerlink" title="引用和指针的区别和联系"></a>引用和指针的区别和联系</h3><p>两者都是地址的概念<br>指针指向一块内存，其内容为所指内存的地址；<br>引用是某块儿内存的别名。</p><p>1.指针是一个实体，而引用仅是个别名；<br>2.引用使用时无需解引用(*)，指针需要解引用；<br>3.引用只能在定义时被初始化一次，之后不可变；指针可变；<br>4.引用没有 const，指针有 const；const修饰的指针不可变；<br>5.引用不能为空，指针可以为空；<br>6.“sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；<br>7.指针和引用的自增(++)运算意义不一样；<br>8.从内存分配上看：程序为指针变量分配内存区域，而引用不需要分配内存区域。</p><h3 id="new-和delete实现二维数组的动态申请内存"><a href="#new-和delete实现二维数组的动态申请内存" class="headerlink" title="new 和delete实现二维数组的动态申请内存"></a>new 和delete实现二维数组的动态申请内存</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int **arr = NULL;int **fun(int a, int b) // 动态分配数组函数{    int i;    arr = new int *[a]; // 创建指向一维数组的指针数组    for (int i = 0; i &lt; b; i++)    {        arr[i] = new int[b]; // 为每一个指针数组的值进行赋值    }    arr[0][0] = 5;    return arr;}int main(){    int **q; // 用来接收函数返回的二维数组的头地址    int a, b;    cin &gt;&gt; a &gt;&gt; b; // 输入行列    q = fun(a, b);    cout &lt;&lt; **q &lt;&lt; endl;    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>输入</p><p>2</p><p>2</p><p>输出结果为</p><p>5</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2023/08/30/jvm-la-ji-hui-shou/"/>
      <url>/2023/08/30/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h4 id="1-1-引用计数器"><a href="#1-1-引用计数器" class="headerlink" title="1.1.引用计数器"></a>1.1.引用计数器</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>垃圾回收引用计数法（Reference Counting Garbage Collection）是一种常用的垃圾回收算法，它的基本思想是对每个对象记录它的引用计数，当引用计数为0时，就可以将这个对象回收掉。</li></ul><h5 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h5><ul><li>为每个对象维护一个引用计数器，记录当前有多少个指针引用了这个对象。</li><li>当有一个指针指向了这个对象时，引用计数器加1；当有一个指针不再引用这个对象时，引用计数器减1。</li><li>当引用计数器为0时，说明这个对象已经没有任何指针引用它了，可以将这个对象回收掉。</li></ul><h5 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><p><strong>优点</strong></p><p>​可以实现快速的内存回收，因为它不需要遍历整个堆内存，只需要回收引用计数为0的对象即可。</p><p><strong>缺点</strong></p><p>​实现比较复杂，需要为每个对象维护引用计数器，而且容易出现循环引用的问题，导致内存泄漏。</p><p><img src="/./img/6.5.png"></p><p>​<strong>循环引用指的是两个或多个对象之间相互引用，形成了一个闭环，如果这些对象的引用计数都不为0，那么它们将永远无法被回收，从而导致内存泄漏。</strong></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2.可达性分析算法"></a>1.2.可达性分析算法</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>​可达性分析算法（Reachability Analysis Algorithm）是现代垃圾回收算法中最常用的一种。它的基本思想是从一组根对象开始，通过<strong>遍历对象之间的引用关系</strong>，找到所有可以被访问到的对象，并将这些对象标记为存<strong>活对象</strong>。所有未被标记的对象则可以被视为<strong>垃圾对象</strong>，可以被回收</p><h5 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h5><ol><li><p>从一组根对象(gc_roots)开始，例如Java虚拟机中的堆栈、静态变量等。</p></li><li><p>遍历所有根对象能够访问到的对象，将这些对象标记为存活对象。</p></li><li><p>遍历所有已标记的存活对象，找到它们所引用的对象，将这些对象也标记为存活对象。</p></li><li><p>重复步骤3，直到所有可达对象都被标记为存活对象。</p></li><li><p>将未被标记的对象作为垃圾对象，进行回收。</p><p><strong>根对象(gc_roots)的查看（MAT工具）</strong></p><p><img src="/./img/6.6.png"></p></li></ol><h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3.四种引用"></a>1.3.四种引用</h4><p><img src="/./img/6.7.png"></p><h5 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h5><ul><li>强引用是最常见的引用类型</li><li>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li><li>通过<strong>new关键字创建一个对象</strong>，该对象具有强引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h5><ul><li>软引用是一种相对强引用弱化了一些的引用类型。</li><li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时</strong>会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li><li>常用于<strong>缓存对象，例如，图片缓存、数据缓存</strong>等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h5><ul><li>弱引用比软引用还要弱化一些。</li><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li><li>常用于<strong>ThreadLocal、WeakHashMap</strong>等</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h5><ul><li><p>虚引用是最弱化的引用类型。</p></li><li><p>如果一个对象只具有虚引用，那么无法通过虚引用获取到该对象，也无法通过虚引用对该对象进行任何操作。</p></li><li><p>虚引用主要用于在对象被回收时收到一个系统通知，例如，当一个对象被回收时，可以在虚引用的引用队列中收到通知。</p></li><li><p>必须配合引用队列使用，主要配合 <strong>ByteBuffer</strong>使用，被引用对象回收时，会将虚引用入队，由<strong>Reference Handler</strong>线程调用虚引用相关方法释放直接内存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="5-终结器引用"><a href="#5-终结器引用" class="headerlink" title="5.终结器引用"></a>5.终结器引用</h5><ul><li>终结器引用是一种特殊的引用类型，用于在对象被回收之前执行特定的清理操作。</li><li>无需手动编码，但其内部配合引用队列使用</li><li>终结器引用入队（被引用对象暂时没有被回收)，再由<strong>Finalizer线程</strong>通过终结器引用找到被引用对象并调用它的<strong>finalize方法</strong>，第二次GC时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1.标记清除"></a>2.1.标记清除</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记清除（Mark and Sweep）是一种垃圾回收算法，用于自动内存管理。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法分为两个阶段：标记和清除。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在清除阶段，垃圾回收器清除未被标记的对象，释放它们占用的内存。</li></ul><p><img src="/./img/7.1.png"></p><h5 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点：可以处理循环引用的情况，即当两个或多个对象相互引用时，它们之间的引用关系会被正确地识别和处理。</li><li>缺点：清除内存的过程可能会导致内存碎片化。</li></ul><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2.标记整理"></a>2.2.标记整理</h4><h5 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记整理（Mark and Compact）是标记清除算法的改进版本，在标记和清除阶段之后，还会对内存进行<strong>整理</strong>，以解决标记清除算法可能导致的内存碎片化问题。</p><h5 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h5><p>算法也分为两个阶段：标记和整理。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在整理阶段，垃圾回收器将所有标记为“存活”的对象移动到内存的一端，将未被标记的对象移动到内存的另一端，然后将这些未被标记的内存区域释放掉，以形成一块<strong>连续的内存空间</strong>。</li></ul><p><img src="/./img/7.2.png"></p><h5 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以解决标记清除算法可能导致的内存碎片化问题，从而减少了内存分配失败的概率。</li><li>缺点在于它需要在程序暂停时执行垃圾回收操作，可能会影响程序的性能。</li></ul><h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3.复制"></a>2.3.复制</h4><h5 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h5><p>复制（Copying）是将内存分为两个区域，每次只使用其中的一半。当当前区域的内存使用率达到一定阈值时，垃圾回收器会扫描当前区域中的存活对象，将它们复制到另一个空闲区域中，然后将当前区域清空，以便下一轮内存分配使用。</p><h5 id="2-作用-2"><a href="#2-作用-2" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法的主要步骤如下：</p><ol><li><p>将内存分为两个大小相等的区域，分别称为“From Space”和“To Space”。初始时，所有对象存放在From Space中。当From Space中的内存使用率达到一定阈值时，垃圾回收器开始扫描From Space中的存活对象。</p><p><img src="/./img/8.1.png"></p></li><li><p>垃圾回收器将这些存活对象复制到To Space中，并按照它们在From Space中的顺序排列。</p><p><img src="/./img/8.2.png"></p></li><li><p>垃圾回收器清空From Space，使其成为空闲空间。<img src="/./img/8.3.png"></p></li><li><p>交换From Space和To Space的角色，使To Space成为新的From Space，From Space成为空闲空间。</p><p><img src="/./img/8.4.png"></p></li></ol><h5 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以避免内存碎片化问题，因为每次复制存活对象时，都会将它们按顺序排列在新的空间中，从而形成一块连续的内存空间。另外，复制算法不需要执行标记和清除或标记和整理等额外的操作，因此执行起来比较高效。</li><li>缺点在于它需要使用双倍的内存空间来执行复制操作，这可能会导致<strong>内存使用率较低</strong>。此外，复制算法不能有效地处理长时间存活的对象，因为这些对象需要被反复复制，导致垃圾回收的效率降低。因此，复制算法通常用于<strong>处理生命周期短的对象</strong>，例如临时变量和函数调用栈中的对象。</li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3.分代垃圾回收"></a>3.分代垃圾回收</h2><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>Minor GC（新生代垃圾回收）是指针对新生代内存区域进行的垃圾回收，新生代内存区域通常是指年轻代和幸存者代。</li><li>Full GC（老年代垃圾回收）是指针对整个堆内存进行的垃圾回收。堆内存通常是指整个Java虚拟机中的内存区域，包括新生代和老年代。</li></ul><h5 id="2-作用-3"><a href="#2-作用-3" class="headerlink" title="2.作用"></a>2.作用</h5><p><img src="/./img/8.5.png"></p><ul><li><p>对象首先分配在伊甸园区域</p><p>当一个大对象内存大于伊甸园的内存时，就直接进入老年代</p><p>大对象内存也大于老年代的内存时，就会进行full gc</p></li><li><p>新生代空间不足时，<strong>触发minor gc</strong>，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to</p></li><li><p>minor gc 会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15 (4bit)</p></li><li><p>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么<strong>触发full gc</strong>，STW的时间更长</p></li></ul><p>3.相关jvm参数</p><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或-XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn或(-XX:NewSize=size +-XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-xX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-xx:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h4 id="4-1-串行回收器"><a href="#4-1-串行回收器" class="headerlink" title="4.1.串行回收器"></a>4.1.串行回收器</h4><h5 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h5><h5 id="2-堆内存较小，适合个人电脑"><a href="#2-堆内存较小，适合个人电脑" class="headerlink" title="2.堆内存较小，适合个人电脑"></a>2.堆内存较小，适合个人电脑</h5><p><strong>serial、Serial old收集器</strong>（Hotspot中Client模式下默认的新生代垃圾收集器）</p><p><strong>算法：复制算法、串行回收和”Stop The World”机制的方式执行内存回收</strong></p><p>​<strong>除新生代之外，Serial还提供用于老年代垃圾回收的Serial Old收集器。Serial Old同样采用了串行回收和”Stop The World”，只不过内存回收算法使用的是标记-压缩算法</strong></p><p><img src="/./img/a1.png"></p><h4 id="4-2-并行回收器"><a href="#4-2-并行回收器" class="headerlink" title="4.2.并行回收器"></a>4.2.并行回收器</h4><h5 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu"><a href="#2-堆内存较大，多核cpu" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-单位时间内，stw时间最短"><a href="#3-单位时间内，stw时间最短" class="headerlink" title="3.单位时间内，stw时间最短"></a>3.单位时间内，stw时间最短</h5><p><strong>Parallel收集器</strong>(jdk8默认使用)、ParNew、Parallel scavenge、Parallel old</p><p><strong>算法：复制算法、并行回收、”Stop The World”</strong></p><p>​<strong>Parallel在JDK1.6提供了用于执行老年代的Parallel Old，用来代替Serial Old<br>​Parallel Old采用了标记-压缩算法，但同样是基于并行回收、”Stop The World”</strong></p><p><strong>目标：是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾回收器</strong><br>           <strong>自适应调节策略也是Parallel Scavenge和ParNew的区别</strong></p><p>高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：执行<strong>批量处理、订单处理、工资支付、科学计算</strong>的应用程序</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>-XX:+UseParallelGC~-XX:+UseParalleloldGc</p><p><img src="/./img/b1.png"></p><h4 id="4-3-并发回收器"><a href="#4-3-并发回收器" class="headerlink" title="4.3.并发回收器"></a>4.3.并发回收器</h4><h5 id="1-多线程-1"><a href="#1-多线程-1" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu-1"><a href="#2-堆内存较大，多核cpu-1" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-尽可能让单次的stw时间最短"><a href="#3-尽可能让单次的stw时间最短" class="headerlink" title="3.尽可能让单次的stw时间最短"></a>3.尽可能让单次的stw时间最短</h5><h5 id="4-3-1-CMS收集器"><a href="#4-3-1-CMS收集器" class="headerlink" title="4.3.1.CMS收集器"></a>4.3.1.CMS收集器</h5><p><strong>算法：CMS采用标记-清除算法，也会有STW</strong></p><p><strong>目的：尽可能缩短垃圾回收时用户线程的停顿时间。停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验</strong></p><p>过程：</p><ol><li>初始标记阶段(Initial-Mark)：所有的工作线程会因为STW而出现短暂的停顿，这个阶段的主要任务仅仅只是标记除GC Roots能直接关联到的对象。一旦标记完成后就会恢复之前的应用线程。由于直接关联对象比较小，所以这里速度非常快</li><li>并发标记(Concurrent-Mark)：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但是不需要停顿用户线程，可以与垃圾回收线程并发运行</li><li>重新标记(Remark)：由于在并发标记阶段中，程序的工作线程会和垃圾回收线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除(Concurrent-Sweep)：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发的</li></ol><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>-XX:+UseConcMarkSweepGC~ -XX :+UseParNewGC ~ Serialold</p><p><img src="/./img/c1.png"></p><h5 id="4-3-2-G1"><a href="#4-3-2-G1" class="headerlink" title="4.3.2.G1"></a>4.3.2.G1</h5><p><img src="/./img/d1.png"></p><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>   G1（Garbage First）收集器是 JDK7 提供的一个新收集器，在 JDK9 中更被指定为官方GC收集器，与CMS收集器相比，最突出的改进是：</p><blockquote><ul><li>基于 “标记-整理” 算法，收集后不会产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ul></blockquote><p> G1 收集器不采用传统的新生代和老年代物理隔离的布局方式，仅在逻辑上划分新生代和老年代，将整个堆内存划分为2048个大小相等的独立内存块Region，每个Region是逻辑连续的一段内存并使用不同的Region来表示新生代和老年代，G1不再要求相同类型的 Region 在物理内存上相邻，而是通过Region的动态分配方式实现逻辑上的连续。</p><p>​        G1收集器通过跟踪Region中的垃圾堆积情况，每次根据设置的垃圾回收时间，回收优先级最高的区域，避免整个新生代或整个老年代的垃圾回收，使得stop the world的时间更短、更可控，同时在有限的时间内可以获得最高的回收效率。</p><p>​        通过区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>G1垃圾回收器的工作过程主要包括以下几个步骤：</p><ol><li><p>初始标记阶段（Initial Mark）：这个阶段是G1垃圾回收器的STW（Stop-The-World）阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的根对象，并标记所有的年轻代对象和部分老年代对象。这个阶段的主要目的是确定哪些对象是存活的，哪些对象可以被回收。</p></li><li><p>并发标记阶段（Concurrent Mark）：这个阶段是G1垃圾回收器的并发标记阶段，即在应用程序运行的同时，对存活对象进行标记。在这个阶段，G1会对所有的老年代对象进行标记。这个阶段的主要目的是标记所有的存活对象，为下一阶段的回收做准备。</p></li><li><p>并发预清理阶段（Concurrent Preclean）：这个阶段是G1垃圾回收器的并发预清理阶段，即在应用程序运行的同时，对标记的对象进行清理。在这个阶段，G1会清理掉一些无用的对象，以便在下一阶段的回收中提高效率。</p></li><li><p>最终标记阶段（Final Mark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的存活对象，以及在并发标记阶段和并发预清理阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>筛选回收阶段（Live Data Counting and Evacuation）：这个阶段是G1垃圾回收器的并发筛选回收阶段，即在应用程序运行的同时，对标记的对象进行筛选和回收。在这个阶段，G1会根据区域的垃圾比例和空间利用率等因素，动态选择回收对象，以最大化回收效率。这个阶段的主要目的是回收垃圾最多的区域，以最大化回收效率。</p></li><li><p>再次标记阶段（Remark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记在筛选回收阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>清理阶段（Cleanup）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会回收所有未被标记的对象，并进行内存整理。这个阶段的主要目的是回收内存空间，为应用程序提供足够的可用内存。</p></li></ol><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)，默认的暂停目标是200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region<br>整体上是标记+整理算法，两个区域之间是复制算法</li><li>缺点，例如在回收大对象时的性能可能不如其他垃圾回收器。</li></ul><h6 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h6><p>-XX : +UseG1GC<br>-XX:G1HeapRegionsize=size|<br>-XX:MaxGCPauseMillis=time</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p><img src="/./img/12.png"></p><p>最小化地使用内存和并行开销，请选serial GC;</p><p>最大化应用程序的吞吐量，请选Parallel GC;</p><p>最小化Gc的中断或停顿时间，请选CMs GC。</p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h2><h5 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h5><p><strong>案例1：Full GC和Minor GC频繁</strong></p><p>​在此情形下，需要先确定应用程序的内存使用情况，例如堆内存大小、对象创建和销毁的频率等。如果堆内存过小，可能会导致垃圾收集的频率增加，从而影响应用程序的性能。可以通过增加堆内存大小来减少垃圾收集的频率。</p><p>​另外，需要分析垃圾收集的日志，查看Full GC和Minor GC的发生频率和原因。如果Full GC和Minor GC的发生频率过高，可能是因为应用程序中存在大量的无用对象或内存泄漏。可以使用一些内存分析工具来识别和优化这些问题，例如查看内存堆转储（heap dump）中的对象信息、分析对象引用关系等。</p><p><strong>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong></p><p>​在此情形下，需要增加CMS收集器的并发线程数，以提高CMS收集器的并发处理能力，减少单次Full GC的暂停时间。可以使用参数”-XX:CMSConcurrentMTEnabled”来启用CMS收集器的多线程并发模式。</p><p>​另外，需要分析Full GC的日志，查看Full GC的原因和持续时间。如果Full GC的持续时间过长，可能是因为CMS收集器的老年代空间不足，导致Full GC无法回收足够的内存空间。可以通过增加老年代的空间大小来解决这个问题。</p><p><strong>案例3：老年代充裕情况下，发生Full GC（1.7）</strong></p><p>​在此情形下，可能是因为应用程序中存在大量的长时间存活的对象，导致老年代空间被占满，无法再分配新的对象。可以通过增加老年代的空间大小来解决这个问题。</p><p>​另外，还可以考虑使用G1收集器来改善垃圾收集的效率和性能。G1收集器可以根据应用程序的实际情况，动态调整垃圾回收的策略和参数，以最小化暂停时间和最大化吞吐量。可以通过使用参数”-XX:+UseG1GC”来启用G1收集器。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的内存结构</title>
      <link href="/2023/08/30/jvm-nei-cun-jie-gou/"/>
      <url>/2023/08/30/jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><ul><li><h5 id="JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"><a href="#JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。" class="headerlink" title="JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"></a>JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。</h5></li></ul><h4 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2.作用"></a>1.2.作用</h4><p><img src="/./img/2.1.png"></p><ol><li><h5 id="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"><a href="#用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。" class="headerlink" title="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"></a>用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。</h5></li><li><h5 id="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"><a href="#实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。" class="headerlink" title="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"></a>实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。</h5></li></ol><h4 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3.特点"></a>1.3.特点</h4><ol><li><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5></li><li><h5 id="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"><a href="#是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区" class="headerlink" title="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"></a>是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区</h5></li><li><h5 id="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"><a href="#执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空" class="headerlink" title="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"></a>执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空</h5></li></ol><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><p><img src="/./img/2.png"></p><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><h5 id="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"><a href="#JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。" class="headerlink" title="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"></a>JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。</h5><p><img src="/./img/2.2.PNG"></p><ul><li><h5 id="每个线程运行是所需要的内存，称为虚拟机栈"><a href="#每个线程运行是所需要的内存，称为虚拟机栈" class="headerlink" title="每个线程运行是所需要的内存，称为虚拟机栈"></a>每个线程运行是所需要的内存，称为虚拟机栈</h5></li><li><h5 id="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"><a href="#每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存" class="headerlink" title="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"></a>每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存</h5></li><li><h5 id="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"><a href="#每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法" class="headerlink" title="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"></a>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</h5><h5 id="问题解析："><a href="#问题解析：" class="headerlink" title="问题解析："></a>问题解析：</h5><p><strong>(1).垃圾回收是否涉及栈内存?</strong></p><p>​垃圾回收（Garbage Collection）一般是针对堆内存（Heap Memory）的，而与栈内存（Stack Memory）没有直接关系。</p><p><strong>(2).栈内存分配越大越好吗?</strong></p><p>​栈内存的大小应该根据具体的需求和系统资源进行合理分配，不是越大越好。</p><p><strong>(3).方法内的局部变量是否线程安全?│</strong></p><h5 id="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"><a href="#–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的" class="headerlink" title="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"></a>–<strong>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</strong></h5><h5 id="–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全"><a href="#–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全" class="headerlink" title="–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全"></a>–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全</h5></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2.栈内存溢出"></a>2.2.栈内存溢出</h4><h5 id="–出现StackOverflowError-异常"><a href="#–出现StackOverflowError-异常" class="headerlink" title="–出现StackOverflowError 异常"></a>–出现StackOverflowError 异常</h5><ul><li><h5 id="栈帧过多导致栈内存溢出-方法调用层次过深"><a href="#栈帧过多导致栈内存溢出-方法调用层次过深" class="headerlink" title="栈帧过多导致栈内存溢出(方法调用层次过深)"></a>栈帧过多导致栈内存溢出(方法调用层次过深)</h5><p><img src="/./img/%E6%A0%881.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="栈帧过大导致栈内存溢出-方法中创建过多的局部变量"><a href="#栈帧过大导致栈内存溢出-方法中创建过多的局部变量" class="headerlink" title="栈帧过大导致栈内存溢出(方法中创建过多的局部变量)"></a>栈帧过大导致栈内存溢出(方法中创建过多的局部变量)</h5><p><img src="/./img/%E6%A0%882.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置虚拟机栈大小-："><a href="#设置虚拟机栈大小-：" class="headerlink" title="设置虚拟机栈大小  ："></a>设置虚拟机栈大小  ：</h5><ol><li>-Xss：用于设置单个线程的栈大小。</li><li>-XX:ThreadStackSize：也可以使用这个参数来设置单个线程的栈大小。</li><li>在启动 Java 应用程序时通过指定这些参数来设置虚拟机栈的大小，例如：java -Xss1m MyClass</li></ol></li></ul><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3.线程运行诊断"></a>2.3.线程运行诊断</h4><ul><li><h5 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h5><p><strong>定位:</strong></p><h6 id="a-用top定位哪个进程对cpu的占用过高"><a href="#a-用top定位哪个进程对cpu的占用过高" class="headerlink" title="a.用top定位哪个进程对cpu的占用过高"></a>a.用top定位哪个进程对cpu的占用过高</h6><h6 id="b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高"><a href="#b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高" class="headerlink" title="b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)"></a>b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)</h6><h6 id="c-jstack-进程id"><a href="#c-jstack-进程id" class="headerlink" title="c.jstack 进程id"></a>c.jstack 进程id</h6><h6 id="可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号"><a href="#可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号" class="headerlink" title="可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号"></a>可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</h6></li><li><h5 id="程序运行很长时间没有结果"><a href="#程序运行很长时间没有结果" class="headerlink" title="程序运行很长时间没有结果"></a>程序运行很长时间没有结果</h5><p><img src="/./img/x.png"></p></li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="/./img/3.png"></p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><h5 id="本地方法栈的主要功能是为执行本地方法时提供栈空间"><a href="#本地方法栈的主要功能是为执行本地方法时提供栈空间" class="headerlink" title="本地方法栈的主要功能是为执行本地方法时提供栈空间"></a>本地方法栈的主要功能是为执行本地方法时提供栈空间</h5><h5 id="本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"><a href="#本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。" class="headerlink" title="本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"></a>本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。</h5><h6 id="JVM-中的本地方法主要有以下两种类型："><a href="#JVM-中的本地方法主要有以下两种类型：" class="headerlink" title="JVM 中的本地方法主要有以下两种类型："></a>JVM 中的本地方法主要有以下两种类型：</h6><ul><li>​-Native 方法：Native 方法是指在 Java 中声明的本地方法，其实现由本地代码编写。</li><li>​-JNI 方法：JNI 方法是指在本地代码中实现的 Java 方法</li></ul><h4 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2.举例"></a>3.2.举例</h4><ul><li><p>java.lang.System：System 类包含一些与系统操作相关的本地方法，例如获取系统属性、读取标准输入输出流等。</p></li><li><p>java.io.FileDescriptor：FileDescriptor 类封装了一个操作系统文件描述符，它的本地方法用于创建、读写和关闭文件。</p></li><li><p>java.net.SocketImpl：SocketImpl 类是一个网络套接字的实现类，它的本地方法用于创建和管理底层的网络连接。</p></li><li><p>java.util.zip.Inflater：Inflater 类是一个压缩解压缩器，它的本地方法用于解压缩数据。</p></li><li><p>java.util.Random：Random 类是一个随机数生成器，它的本地方法用于获取随机数种子和生成随机数。</p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="/./img/4.png"></p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><h5 id="1-Heap-堆"><a href="#1-Heap-堆" class="headerlink" title="1.Heap 堆"></a>1.Heap 堆</h5><h5 id="堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"><a href="#堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。" class="headerlink" title="堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"></a>堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（<strong>通过new关键字创建对象）等数据。</strong></h5><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><ul><li><h5 id="是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器"><a href="#是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器" class="headerlink" title="是线程共享的:  堆中对象要考虑线程安全的问题–> 线程栈和程序计数器"></a>是线程共享的:  堆中对象要考虑线程安全的问题–&gt; 线程栈和程序计数器</h5></li><li><h5 id="有垃圾回收机制"><a href="#有垃圾回收机制" class="headerlink" title="有垃圾回收机制"></a>有垃圾回收机制</h5></li><li><h5 id="动态分配-堆的空间大小是在-JVM-启动时动态分配的"><a href="#动态分配-堆的空间大小是在-JVM-启动时动态分配的" class="headerlink" title="动态分配:  堆的空间大小是在 JVM 启动时动态分配的"></a>动态分配:  堆的空间大小是在 JVM 启动时动态分配的</h5></li><li><h5 id="分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象"><a href="#分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象" class="headerlink" title="分代管理：分为新生代和老年代 –>  新创建的对象,经过多次垃圾回收的对象"></a>分代管理：分为新生代和老年代 –&gt;  新创建的对象,经过多次垃圾回收的对象</h5></li><li><h5 id="物理实现：由操作系统的虚拟内存来实现的"><a href="#物理实现：由操作系统的虚拟内存来实现的" class="headerlink" title="物理实现：由操作系统的虚拟内存来实现的"></a>物理实现：由操作系统的虚拟内存来实现的</h5></li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2.堆内存溢出"></a>4.2.堆内存溢出</h4><h5 id="–出现OutOfMemoryError异常"><a href="#–出现OutOfMemoryError异常" class="headerlink" title="–出现OutOfMemoryError异常"></a>–出现OutOfMemoryError异常</h5><ol><li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序会不断地创建字符串对象并添加到列表中，当字符串的数量太大时，就会导致堆内存溢出错误，抛出 OutOfMemoryError 异常。</p></li><li><h5 id="设置虚拟机堆大小"><a href="#设置虚拟机堆大小" class="headerlink" title="设置虚拟机堆大小"></a>设置虚拟机堆大小</h5><h5 id="Xms：设置-Java-堆的初始大小。"><a href="#Xms：设置-Java-堆的初始大小。" class="headerlink" title="-Xms：设置 Java 堆的初始大小。"></a>-Xms：设置 Java 堆的初始大小。</h5><h5 id="Xmx：设置-Java-堆的最大大小。"><a href="#Xmx：设置-Java-堆的最大大小。" class="headerlink" title="-Xmx：设置 Java 堆的最大大小。"></a>-Xmx：设置 Java 堆的最大大小。</h5></li></ol><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3.堆内存诊断"></a>4.3.堆内存诊断</h4><ul><li><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5></li></ul><ol><li>jps 指令<br>查看当前系统中有哪些java进程</li><li>jmap-heap {pid}  指令<br>查看堆内存占用情况</li><li>jconsole指令  -&gt;工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 指令</li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="/./img/5.png"></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"><a href="#JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。" class="headerlink" title="JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"></a>JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。</h5><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h4><p><img src="/./img/5.1.png"></p><ul><li><h5 id="在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"><a href="#在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。" class="headerlink" title="在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"></a>在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。</h5></li><li><h5 id="在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"><a href="#在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。" class="headerlink" title="在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"></a>在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。</h5></li></ul><h4 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h4><h5 id="出现OutOfMemoryError-Metaspace-异常"><a href="#出现OutOfMemoryError-Metaspace-异常" class="headerlink" title="-出现OutOfMemoryError:Metaspace 异常"></a>-出现OutOfMemoryError:Metaspace 异常</h5><ol><li><p><strong>示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Path</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaspaceOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.example.DynamicClass"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token class-name">String</span> classPath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>**调整元空间的大小   **</p><p><strong>-XX:MaxMetaspaceSize = 8m</strong></p><p><strong>jdk1.6的情况 -XX:MaxPermSize=8m</strong></p></li></ol><h4 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstantPoolExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 常量池中的字符串常量</span>                <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将"Hello, world!"字符串常量放入常量池中</span>        <span class="token comment">// 在编译时将"Hello, world!"字符串常量放入常量池中并将str2指向常量池中的同一个字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>         <span class="token comment">// 在运行时，创建一个新的字符串对象，并将其指向堆中新建的一个对象</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个字符串常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为它们指向不同的对象</span>                <span class="token comment">// 常量池中的数字常量</span>        <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将数字常量100放入常量池中</span>        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 将数字常量100放入常量池中，并将num2指向常量池中的同一个数字常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个数字常量</span>                <span class="token comment">// 常量池中的类引用</span>        <span class="token comment">// 在编译时，将ConstantPoolExample类的引用放入常量池中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">ConstantPoolExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>         <span class="token comment">// 在编译时，将字符串常量"ConstantPoolExample"放入常量池中</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"ConstantPoolExample"</span><span class="token punctuation">;</span> <span class="token comment">// true，它们都指向常量池中的同一个类引用</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</strong>**</li><li><em><em>运行时常量池，常量池是</em>.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</em>*</li></ul><h4 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>StringTable 是 Java 虚拟机（JVM）中的一个<strong>数据结构</strong>(JDK 8 中基于字符串哈希值的分离链接哈希表)，用于存储字符串常量。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>StringTable 的作用是<strong>优化字符串的存储和共享</strong>，从而减少内存的开销。</p><p>在 Java 应用程序中，字符串常量通常占用较大的内存空间，如果每次都创建新的字符串对象，会导致内存占用量增加，从而影响应用程序的性能。为了避免这种情况，Java 使用了 StringTable 来存储字符串常量，并在<strong>需要使用(延迟加载)字符串常量时直接引用 StringTable 中的对象</strong>，从而避免了重复创建字符串对象，减少了内存占用量。</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为字符串常量是共享的</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为字符串对象不是共享的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./img/s.jpg"></p><ul><li>在String s4 = s1+s2 是通过new StringBuilder()…  –&gt;字符串变量 s4 是通过字符串变量 a 和 b 的拼接得到的，它是一个新的字符串对象，与字符串常量 “ab” 不相等，</li><li>String s5 = “a”+”b”  是在StringTable中取的已存在的”ab”   –&gt; 字符串常量 “ab” 和 “a” + “b” 的值相等</li></ul><h5 id="4-特性"><a href="#4-特性" class="headerlink" title="4.特性"></a>4.特性</h5><ol><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是StringBuilder ( 1.8)</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用intern方法，主动将串池中还没有的字符串对象放入串池</p><p><strong>1.8将这个字符串对象尝试放入串池，如果有则并不会放入（还在堆区），如果没有则放入串池(堆区-&gt;常量池），会把串池中的对象返回</strong><br><strong>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份,放入串池,会把串池中的对象返回</strong></p><p>–示例一：   String s = new String(“a”)+new String (“b”)”写在String x = “ab前面</p><p><img src="/./img/51.png"></p><p>1.8中：”ab” 在串池中没有，会将s放入串池(s从堆区-&gt;常量池），得到的结果为：s==x 为true</p><p>1.6中：”ab” 在串池中没有，会将s拷贝一份再放入串池(s还在堆区），得到的结果为：s==x 为false</p><p>–示例二：如果将String x = “ab”写在String s = new String(“a”)+new String (“b”)前面</p><p>如果有则并不会放入–&gt;都不会进入串池 s==x  都为 false</p></li></ol><h5 id="5-位置"><a href="#5-位置" class="headerlink" title="5.位置"></a>5.位置</h5><p><img src="/./img/61.png"></p><ul><li><p>JDK 7 及之前的版本中，String Table 是一个固定大小的哈希表存储在永久代中，因此在运行时无法动态扩容</p></li><li><p>JDK 8 引入了一种叫做 <strong>Compact Strings</strong> 的技术，可以将字符串常量存储在堆中</p><p>Compact Strings 技术的实现方式是将较短的字符串常量（长度小于等于 16）存储为字节数组，而不是存储为 char 数组。</p></li></ul><h5 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6.垃圾回收"></a>6.垃圾回收</h5><p><img src="/./img/62.png"></p><h5 id="7-调优"><a href="#7-调优" class="headerlink" title="7.调优"></a>7.调优</h5><ul><li>可通过参数 <code>-XX:StringTableSize</code> 来设置 StringTable 的桶大小</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableBenchmark</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NUM_STRINGS</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">BUCKET_SIZES</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1009</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">65536</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">:</span> <span class="token constant">BUCKET_SIZES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Testing with bucket size "</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">runBenchmark</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 构造大量的字符串常量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">NUM_STRINGS</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"string"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 调整 StringTable 的桶大小</span>        <span class="token class-name">StringTable</span><span class="token punctuation">.</span><span class="token function">adjustSize</span><span class="token punctuation">(</span>bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印 StringTable 的统计信息</span>        <span class="token class-name">StringTableStats</span><span class="token punctuation">.</span><span class="token function">printStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印程序运行时间</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Time taken: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">1009</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">1009</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">6.579</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">17</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">1267</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">8192</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">8192</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">1.219</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">6</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">891</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">65536</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">65536</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">0.153</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">1</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">849</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以考虑将字符串对象入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"><a href="#JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存" class="headerlink" title="JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"></a>JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存</h5><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h4><p><strong>JVM直接内存可以通过Java NIO（New I/O）库中的ByteBuffer类来进行访问和操作，它的主要特点是可以提高I/O操作的效率，减少内存复制和上下文切换的开销。</strong></p><h5 id="–java的io操作-存在缓冲区的复制操作"><a href="#–java的io操作-存在缓冲区的复制操作" class="headerlink" title="–java的io操作(存在缓冲区的复制操作)"></a>–java的io操作(存在缓冲区的复制操作)</h5><p><img src="/./img/6.1.png"></p><h5 id="–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024"><a href="#–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024" class="headerlink" title="–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);"></a>–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);</h5><p>这个方法会在<strong>堆内存</strong>中分配一个DirectByteBuffer对象，并在<strong>操作系统</strong>中分配一块原生内存，用来存储ByteBuffer对象中的数据。</p><p><img src="/./img/6.2.png"></p><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h4><h5 id="直接内存的释放："><a href="#直接内存的释放：" class="headerlink" title="直接内存的释放："></a>直接内存的释放：</h5><h5 id="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"><a href="#Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。" class="headerlink" title="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"></a>Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。</h5><ol><li>调用DirectByteBuffer类的clear()方法</li><li>freeMemory(long address)：释放指定地址的内存块。</li></ol><p><img src="/./img/6.3.png"></p><h5 id="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"><a href="#由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存" class="headerlink" title="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"></a>由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存</h5><p><strong>–ByteBuffer.allocateDirect(1024*1024)中对Unsafe的调用;</strong></p><p><img src="/./img/6.4.png"></p><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner(虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemor来释放直接内存</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><h4 id="1-部分："><a href="#1-部分：" class="headerlink" title="1.部分："></a>1.部分：</h4><ol><li><h5 id="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"><a href="#堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。" class="headerlink" title="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"></a>堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。</h5></li><li><h5 id="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"><a href="#栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。" class="headerlink" title="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"></a>栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。</h5></li><li><h5 id="方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"><a href="#方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。" class="headerlink" title="方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"></a>方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。</h5></li><li><h5 id="本地方法栈（Native-Stack）：用于存储Native方法的现场数据。"><a href="#本地方法栈（Native-Stack）：用于存储Native方法的现场数据。" class="headerlink" title="本地方法栈（Native Stack）：用于存储Native方法的现场数据。"></a>本地方法栈（Native Stack）：用于存储Native方法的现场数据。</h5></li><li><h5 id="PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。"></a>PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h4><ol><li><h5 id="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"><a href="#堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。" class="headerlink" title="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"></a>堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。</h5></li><li><h5 id="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"><a href="#栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。" class="headerlink" title="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"></a>栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。</h5></li><li><h5 id="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"><a href="#方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。" class="headerlink" title="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"></a>方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。</h5></li><li><h5 id="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"></a>PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="3-区别："><a href="#3-区别：" class="headerlink" title="3.区别："></a>3.区别：</h4><ol><li><h5 id="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"><a href="#栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。" class="headerlink" title="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"></a>栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。</h5></li><li><h5 id="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"><a href="#方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。" class="headerlink" title="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"></a>方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。</h5></li><li><h5 id="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"><a href="#PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。" class="headerlink" title="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"></a>PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本概念</title>
      <link href="/2023/08/30/jvm-ji-ben-gai-nian/"/>
      <url>/2023/08/30/jvm-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="一、什么是-JVM？"><a href="#一、什么是-JVM？" class="headerlink" title="一、什么是 JVM？"></a>一、什么是 JVM？</h2><h4 id="JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。"><a href="#JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。" class="headerlink" title="JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。"></a>JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。</h4><h2 id="二、JVM-的组成"><a href="#二、JVM-的组成" class="headerlink" title="二、JVM 的组成"></a>二、JVM 的组成</h2><p><img src="/./img/jvm1.png"></p><ol><li><h4 id="类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。</h4></li><li><h4 id="运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分："><a href="#运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分：" class="headerlink" title="运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分："></a>运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分：</h4><ul><li><h5 id="方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。"><a href="#方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。" class="headerlink" title="方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。"></a>方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。</h5></li><li><h5 id="堆（Heap）：存储对象实例。"><a href="#堆（Heap）：存储对象实例。" class="headerlink" title="堆（Heap）：存储对象实例。"></a>堆（Heap）：存储对象实例。</h5></li><li><h5 id="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"><a href="#栈（Stack）：存储局部变量、操作数栈、方法返回值等。" class="headerlink" title="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"></a>栈（Stack）：存储局部变量、操作数栈、方法返回值等。</h5></li><li><h5 id="本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。"><a href="#本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。" class="headerlink" title="本地方法栈（Native Method Stack）：存储 JNI 调用信息。"></a>本地方法栈（Native Method Stack）：存储 JNI 调用信息。</h5></li><li><h5 id="PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。"><a href="#PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。" class="headerlink" title="PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。"></a>PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。</h5></li></ul></li><li><h4 id="执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。"><a href="#执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。" class="headerlink" title="执行引擎（Execution Engine）：负责将字节码解释成机器码执行。"></a>执行引擎（Execution Engine）：负责将字节码解释成机器码执行。</h4></li><li><h4 id="本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。"><a href="#本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。" class="headerlink" title="本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。"></a>本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。</h4></li><li><h4 id="JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。"><a href="#JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。" class="headerlink" title="JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。"></a>JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。</h4></li></ol><h2 id="三、JVM-的工作原理"><a href="#三、JVM-的工作原理" class="headerlink" title="三、JVM 的工作原理"></a>三、JVM 的工作原理</h2><h4 id="JVM-的工作原理如下："><a href="#JVM-的工作原理如下：" class="headerlink" title="JVM 的工作原理如下："></a>JVM 的工作原理如下：</h4><p><img src="/./img/jvm2.png"></p><ol><li><h5 id="类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。</h5></li><li><h5 id="执行引擎将字节码解释成机器码执行。"><a href="#执行引擎将字节码解释成机器码执行。" class="headerlink" title="执行引擎将字节码解释成机器码执行。"></a>执行引擎将字节码解释成机器码执行。</h5></li><li><h5 id="在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"><a href="#在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。" class="headerlink" title="在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"></a>在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。</h5></li><li><h5 id="执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"><a href="#执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。" class="headerlink" title="执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"></a>执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。</h5></li><li><h5 id="执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"><a href="#执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。" class="headerlink" title="执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"></a>执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。</h5></li></ol><h2 id="四、JVM-的优化"><a href="#四、JVM-的优化" class="headerlink" title="四、JVM 的优化"></a>四、JVM 的优化</h2><h4 id="1-内存分配优化"><a href="#1-内存分配优化" class="headerlink" title="1.内存分配优化"></a>1.内存分配优化</h4><p>​可以通过调整堆大小、使用对象池等方式优化内存的分配和回收。</p><h4 id="2-垃圾回收优化"><a href="#2-垃圾回收优化" class="headerlink" title="2.垃圾回收优化"></a>2.垃圾回收优化</h4><pre><code> 可以通过选择不同的垃圾回收算法、调整垃圾回收参数等方式优化垃圾回收效率。</code></pre><h4 id="3-即时编译优化"><a href="#3-即时编译优化" class="headerlink" title="3.即时编译优化"></a>3.即时编译优化</h4><p>​可以通过调整 JIT 编译器的参数、选择不同的编译策略等方式优化即时编译效率。</p><h4 id="4-多线程优化"><a href="#4-多线程优化" class="headerlink" title="4.多线程优化"></a>4.多线程优化</h4><p>​可以通过合理地使用多线程技术，提高程序的并发性能。</p><h2 id="五、JVM-的调优工具"><a href="#五、JVM-的调优工具" class="headerlink" title="五、JVM 的调优工具"></a>五、JVM 的调优工具</h2><h4 id="1-jstat"><a href="#1-jstat" class="headerlink" title="1.jstat"></a>1.jstat</h4><p>​用于监控 JVM 运行时数据区的状态。</p><h4 id="2-jmap"><a href="#2-jmap" class="headerlink" title="2.jmap"></a>2.jmap</h4><p>​用于生成堆转储文件，分析堆内存使用情况。</p><h4 id="3-jconsole"><a href="#3-jconsole" class="headerlink" title="3.jconsole"></a>3.jconsole</h4><p>​用于监控 JVM 的运行状态，包括内存、线程、GC 等信息。</p><h4 id="4-VisualVM"><a href="#4-VisualVM" class="headerlink" title="4.VisualVM"></a>4.VisualVM</h4><p>​用于监控和分析 JVM 应用程序的性能，包括内存、线程、GC 等信息。</p><h4 id="5-jprofiler"><a href="#5-jprofiler" class="headerlink" title="5.jprofiler"></a>5.jprofiler</h4><p>​用于分析 JVM 应用程序的性能瓶颈，包括方法调用时间、线程状态、内存分配等信息。</p><h6 id="总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。"><a href="#总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。" class="headerlink" title="总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。"></a>总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。</h6><h2 id="六、JVM、JRE、JDK、JavaSE-和-JavaEE"><a href="#六、JVM、JRE、JDK、JavaSE-和-JavaEE" class="headerlink" title="六、JVM、JRE、JDK、JavaSE 和 JavaEE"></a>六、JVM、JRE、JDK、JavaSE 和 JavaEE</h2><p><img src="/./img/jvm_jre_jdk.png"></p><h4 id="1-JVM（Java-Virtual-Machine）"><a href="#1-JVM（Java-Virtual-Machine）" class="headerlink" title="1.JVM（Java Virtual Machine）"></a>1.JVM（Java Virtual Machine）</h4><h5 id="Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。"><a href="#Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。" class="headerlink" title="Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。"></a>Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。</h5><h4 id="2-JRE（Java-Runtime-Environment）"><a href="#2-JRE（Java-Runtime-Environment）" class="headerlink" title="2.JRE（Java Runtime Environment）"></a>2.JRE（Java Runtime Environment）</h4><h5 id="Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。"><a href="#Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。" class="headerlink" title="Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。"></a>Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。</h5><h4 id="3-JDK（Java-Development-Kit）"><a href="#3-JDK（Java-Development-Kit）" class="headerlink" title="3.JDK（Java Development Kit）"></a>3.JDK（Java Development Kit）</h4><h5 id="Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。"><a href="#Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。" class="headerlink" title="Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。"></a>Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。</h5><h4 id="4-JavaSE（Java-Platform-Standard-Edition）"><a href="#4-JavaSE（Java-Platform-Standard-Edition）" class="headerlink" title="4.JavaSE（Java Platform, Standard Edition）"></a>4.JavaSE（Java Platform, Standard Edition）</h4><h5 id="Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。"><a href="#Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。" class="headerlink" title="Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。"></a>Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。</h5><h4 id="5-JavaEE（Java-Platform-Enterprise-Edition）"><a href="#5-JavaEE（Java-Platform-Enterprise-Edition）" class="headerlink" title="5.JavaEE（Java Platform, Enterprise Edition）"></a>5.JavaEE（Java Platform, Enterprise Edition）</h4><h5 id="Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。"><a href="#Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。" class="headerlink" title="Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。"></a>Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。</h5><h6 id="总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。"><a href="#总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。" class="headerlink" title="总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。"></a>总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。</h6><h3 id="七、常见的-JVM（Java-Virtual-Machine）"><a href="#七、常见的-JVM（Java-Virtual-Machine）" class="headerlink" title="七、常见的 JVM（Java Virtual Machine）"></a>七、常见的 JVM（Java Virtual Machine）</h3><p><img src="/./img/jvm%E5%AE%9E%E7%8E%B0.png"></p><ol><li><h4 id="Oracle-JDK（Java-Development-Kit）："><a href="#Oracle-JDK（Java-Development-Kit）：" class="headerlink" title="Oracle JDK（Java Development Kit）："></a>Oracle JDK（Java Development Kit）：</h4><h5 id="是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="OpenJDK："><a href="#OpenJDK：" class="headerlink" title="OpenJDK："></a>OpenJDK：</h4><h5 id="是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="IBM-JDK："><a href="#IBM-JDK：" class="headerlink" title="IBM JDK："></a>IBM JDK：</h4><h5 id="是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="Azul-Zulu-JDK："><a href="#Azul-Zulu-JDK：" class="headerlink" title="Azul Zulu JDK："></a>Azul Zulu JDK：</h4><h5 id="是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。"><a href="#是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。" class="headerlink" title="是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。"></a>是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。</h5></li><li><h4 id="Amazon-Corretto-JDK："><a href="#Amazon-Corretto-JDK：" class="headerlink" title="Amazon Corretto JDK："></a>Amazon Corretto JDK：</h4><h5 id="是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。"><a href="#是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。" class="headerlink" title="是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。"></a>是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。</h5></li><li><h4 id="AdoptOpenJDK："><a href="#AdoptOpenJDK：" class="headerlink" title="AdoptOpenJDK："></a>AdoptOpenJDK：</h4><h5 id="是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"><a href="#是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。" class="headerlink" title="是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"></a>是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。</h5></li></ol><h6 id="这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。"><a href="#这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。" class="headerlink" title="这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。"></a>这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。</h6>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
