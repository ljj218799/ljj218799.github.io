<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JVM垃圾回收</title>
      <link href="/2023/08/30/jvm-la-ji-hui-shou/"/>
      <url>/2023/08/30/jvm-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<h1 id="三、垃圾回收"><a href="#三、垃圾回收" class="headerlink" title="三、垃圾回收"></a>三、垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1.如何判断对象可以回收"></a>1.如何判断对象可以回收</h2><h4 id="1-1-引用计数器"><a href="#1-1-引用计数器" class="headerlink" title="1.1.引用计数器"></a>1.1.引用计数器</h4><h5 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>垃圾回收引用计数法（Reference Counting Garbage Collection）是一种常用的垃圾回收算法，它的基本思想是对每个对象记录它的引用计数，当引用计数为0时，就可以将这个对象回收掉。</li></ul><h5 id="2-基本原理"><a href="#2-基本原理" class="headerlink" title="2.基本原理"></a>2.基本原理</h5><ul><li>为每个对象维护一个引用计数器，记录当前有多少个指针引用了这个对象。</li><li>当有一个指针指向了这个对象时，引用计数器加1；当有一个指针不再引用这个对象时，引用计数器减1。</li><li>当引用计数器为0时，说明这个对象已经没有任何指针引用它了，可以将这个对象回收掉。</li></ul><h5 id="3-优缺点"><a href="#3-优缺点" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><p><strong>优点</strong></p><p>​可以实现快速的内存回收，因为它不需要遍历整个堆内存，只需要回收引用计数为0的对象即可。</p><p><strong>缺点</strong></p><p>​实现比较复杂，需要为每个对象维护引用计数器，而且容易出现循环引用的问题，导致内存泄漏。</p><p><img src="/./img%5C6.5.png"></p><p>​<strong>循环引用指的是两个或多个对象之间相互引用，形成了一个闭环，如果这些对象的引用计数都不为0，那么它们将永远无法被回收，从而导致内存泄漏。</strong></p><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2.可达性分析算法"></a>1.2.可达性分析算法</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><p>​可达性分析算法（Reachability Analysis Algorithm）是现代垃圾回收算法中最常用的一种。它的基本思想是从一组根对象开始，通过<strong>遍历对象之间的引用关系</strong>，找到所有可以被访问到的对象，并将这些对象标记为存<strong>活对象</strong>。所有未被标记的对象则可以被视为<strong>垃圾对象</strong>，可以被回收</p><h5 id="2-基本流程"><a href="#2-基本流程" class="headerlink" title="2.基本流程"></a>2.基本流程</h5><ol><li><p>从一组根对象(gc_roots)开始，例如Java虚拟机中的堆栈、静态变量等。</p></li><li><p>遍历所有根对象能够访问到的对象，将这些对象标记为存活对象。</p></li><li><p>遍历所有已标记的存活对象，找到它们所引用的对象，将这些对象也标记为存活对象。</p></li><li><p>重复步骤3，直到所有可达对象都被标记为存活对象。</p></li><li><p>将未被标记的对象作为垃圾对象，进行回收。</p><p><strong>根对象(gc_roots)的查看（MAT工具）</strong></p><p><img src="/./img%5C6.6.png"></p></li></ol><h4 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3.四种引用"></a>1.3.四种引用</h4><p><img src="/./img%5C6.7.png"></p><h5 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h5><ul><li>强引用是最常见的引用类型</li><li>只有所有GC Roots对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li><li>通过<strong>new关键字创建一个对象</strong>，该对象具有强引用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h5 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h5><ul><li>软引用是一种相对强引用弱化了一些的引用类型。</li><li>仅有软引用引用该对象时，在垃圾回收后，<strong>内存仍不足时</strong>会再次出发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li><li>常用于<strong>缓存对象，例如，图片缓存、数据缓存</strong>等。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h5><ul><li>弱引用比软引用还要弱化一些。</li><li>仅有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用对象</li><li>可以配合引用队列来释放弱引用自身</li><li>常用于<strong>ThreadLocal、WeakHashMap</strong>等</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token operator">&lt;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;&gt;</span> weakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h5><ul><li><p>虚引用是最弱化的引用类型。</p></li><li><p>如果一个对象只具有虚引用，那么无法通过虚引用获取到该对象，也无法通过虚引用对该对象进行任何操作。</p></li><li><p>虚引用主要用于在对象被回收时收到一个系统通知，例如，当一个对象被回收时，可以在虚引用的引用队列中收到通知。</p></li><li><p>必须配合引用队列使用，主要配合 <strong>ByteBuffer</strong>使用，被引用对象回收时，会将虚引用入队，由<strong>Reference Handler</strong>线程调用虚引用相关方法释放直接内存</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> referenceQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> phantomRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PhantomReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> referenceQueue<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="5-终结器引用"><a href="#5-终结器引用" class="headerlink" title="5.终结器引用"></a>5.终结器引用</h5><ul><li>终结器引用是一种特殊的引用类型，用于在对象被回收之前执行特定的清理操作。</li><li>无需手动编码，但其内部配合引用队列使用</li><li>终结器引用入队（被引用对象暂时没有被回收)，再由<strong>Finalizer线程</strong>通过终结器引用找到被引用对象并调用它的<strong>finalize方法</strong>，第二次GC时才能回收被引用对象</li></ul><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2.垃圾回收算法"></a>2.垃圾回收算法</h2><h4 id="2-1-标记清除"><a href="#2-1-标记清除" class="headerlink" title="2.1.标记清除"></a>2.1.标记清除</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记清除（Mark and Sweep）是一种垃圾回收算法，用于自动内存管理。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法分为两个阶段：标记和清除。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在清除阶段，垃圾回收器清除未被标记的对象，释放它们占用的内存。</li></ul><p><img src="/./img%5C7.1.png"></p><h5 id="3-优缺点-1"><a href="#3-优缺点-1" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点：可以处理循环引用的情况，即当两个或多个对象相互引用时，它们之间的引用关系会被正确地识别和处理。</li><li>缺点：清除内存的过程可能会导致内存碎片化。</li></ul><h4 id="2-2-标记整理"><a href="#2-2-标记整理" class="headerlink" title="2.2.标记整理"></a>2.2.标记整理</h4><h5 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h5><p>标记整理（Mark and Compact）是标记清除算法的改进版本，在标记和清除阶段之后，还会对内存进行<strong>整理</strong>，以解决标记清除算法可能导致的内存碎片化问题。</p><h5 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h5><p>算法也分为两个阶段：标记和整理。</p><ul><li>在标记阶段，垃圾回收器遍历程序中的所有对象，并标记那些仍然被程序使用的对象。</li><li>在整理阶段，垃圾回收器将所有标记为“存活”的对象移动到内存的一端，将未被标记的对象移动到内存的另一端，然后将这些未被标记的内存区域释放掉，以形成一块<strong>连续的内存空间</strong>。</li></ul><p><img src="/./img%5C7.2.png"></p><h5 id="3-优缺点-2"><a href="#3-优缺点-2" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以解决标记清除算法可能导致的内存碎片化问题，从而减少了内存分配失败的概率。</li><li>缺点在于它需要在程序暂停时执行垃圾回收操作，可能会影响程序的性能。</li></ul><h4 id="2-3-复制"><a href="#2-3-复制" class="headerlink" title="2.3.复制"></a>2.3.复制</h4><h5 id="1-定义-4"><a href="#1-定义-4" class="headerlink" title="1.定义"></a>1.定义</h5><p>复制（Copying）是将内存分为两个区域，每次只使用其中的一半。当当前区域的内存使用率达到一定阈值时，垃圾回收器会扫描当前区域中的存活对象，将它们复制到另一个空闲区域中，然后将当前区域清空，以便下一轮内存分配使用。</p><h5 id="2-作用-2"><a href="#2-作用-2" class="headerlink" title="2.作用"></a>2.作用</h5><p>该算法的主要步骤如下：</p><ol><li><p>将内存分为两个大小相等的区域，分别称为“From Space”和“To Space”。初始时，所有对象存放在From Space中。当From Space中的内存使用率达到一定阈值时，垃圾回收器开始扫描From Space中的存活对象。</p><p><img src="/./img%5C8.1.png"></p></li><li><p>垃圾回收器将这些存活对象复制到To Space中，并按照它们在From Space中的顺序排列。</p><p><img src="/./img%5C8.2.png"></p></li><li><p>垃圾回收器清空From Space，使其成为空闲空间。<img src="/./img%5C8.3.png"></p></li><li><p>交换From Space和To Space的角色，使To Space成为新的From Space，From Space成为空闲空间。</p><p><img src="/./img%5C8.4.png"></p></li></ol><h5 id="3-优缺点-3"><a href="#3-优缺点-3" class="headerlink" title="3.优缺点"></a>3.优缺点</h5><ul><li>优点在于它可以避免内存碎片化问题，因为每次复制存活对象时，都会将它们按顺序排列在新的空间中，从而形成一块连续的内存空间。另外，复制算法不需要执行标记和清除或标记和整理等额外的操作，因此执行起来比较高效。</li><li>缺点在于它需要使用双倍的内存空间来执行复制操作，这可能会导致<strong>内存使用率较低</strong>。此外，复制算法不能有效地处理长时间存活的对象，因为这些对象需要被反复复制，导致垃圾回收的效率降低。因此，复制算法通常用于<strong>处理生命周期短的对象</strong>，例如临时变量和函数调用栈中的对象。</li></ul><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3.分代垃圾回收"></a>3.分代垃圾回收</h2><h5 id="1-定义-5"><a href="#1-定义-5" class="headerlink" title="1.定义"></a>1.定义</h5><ul><li>Minor GC（新生代垃圾回收）是指针对新生代内存区域进行的垃圾回收，新生代内存区域通常是指年轻代和幸存者代。</li><li>Full GC（老年代垃圾回收）是指针对整个堆内存进行的垃圾回收。堆内存通常是指整个Java虚拟机中的内存区域，包括新生代和老年代。</li></ul><h5 id="2-作用-3"><a href="#2-作用-3" class="headerlink" title="2.作用"></a>2.作用</h5><p><img src="/./img%5C8.5.png"></p><ul><li><p>对象首先分配在伊甸园区域</p><p>当一个大对象内存大于伊甸园的内存时，就直接进入老年代</p><p>大对象内存也大于老年代的内存时，就会进行full gc</p></li><li><p>新生代空间不足时，<strong>触发minor gc</strong>，伊甸园和from存活的对象使用copy复制到to中，存活的对象年龄加1并且交换from to</p></li><li><p>minor gc 会引发stop the world，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行当对象寿命超过阈值时，会晋升至老年代，最大寿命是15 (4bit)</p></li><li><p>当老年代空间不足，会先尝试触发minor gc，如果之后空间仍不足，那么<strong>触发full gc</strong>，STW的时间更长</p></li></ul><p>3.相关jvm参数</p><table><thead><tr><th>含义</th><th>参数</th></tr></thead><tbody><tr><td>堆初始大小</td><td>-Xms</td></tr><tr><td>堆最大大小</td><td>-Xmx 或-XX:MaxHeapSize=size</td></tr><tr><td>新生代大小</td><td>-Xmn或(-XX:NewSize=size +-XX:MaxNewSize=size )</td></tr><tr><td>幸存区比例(动态)</td><td>-xX:InitialSurvivorRatio=ratio和-XX:+UseAdaptiveSizePolicy</td></tr><tr><td>幸存区比例</td><td>-xx:SurvivorRatio=ratio</td></tr><tr><td>晋升阈值</td><td>-XX:MaxTenuringThreshold=threshold</td></tr><tr><td>晋升详情</td><td>-XX:+PrintTenuringDistribution</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+PrintGCDetails -verbose:gc</td></tr><tr><td>FullGC前MinorGC</td><td>-XX:+ScavengeBeforeFullGC</td></tr></tbody></table><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4.垃圾回收器"></a>4.垃圾回收器</h2><h4 id="4-1-串行回收器"><a href="#4-1-串行回收器" class="headerlink" title="4.1.串行回收器"></a>4.1.串行回收器</h4><h5 id="1-单线程"><a href="#1-单线程" class="headerlink" title="1.单线程"></a>1.单线程</h5><h5 id="2-堆内存较小，适合个人电脑"><a href="#2-堆内存较小，适合个人电脑" class="headerlink" title="2.堆内存较小，适合个人电脑"></a>2.堆内存较小，适合个人电脑</h5><p><strong>serial、Serial old收集器</strong>（Hotspot中Client模式下默认的新生代垃圾收集器）</p><p><strong>算法：复制算法、串行回收和”Stop The World”机制的方式执行内存回收</strong></p><p>​<strong>除新生代之外，Serial还提供用于老年代垃圾回收的Serial Old收集器。Serial Old同样采用了串行回收和”Stop The World”，只不过内存回收算法使用的是标记-压缩算法</strong></p><p><img src="/./img%5Ca1.png"></p><h4 id="4-2-并行回收器"><a href="#4-2-并行回收器" class="headerlink" title="4.2.并行回收器"></a>4.2.并行回收器</h4><h5 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu"><a href="#2-堆内存较大，多核cpu" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-单位时间内，stw时间最短"><a href="#3-单位时间内，stw时间最短" class="headerlink" title="3.单位时间内，stw时间最短"></a>3.单位时间内，stw时间最短</h5><p><strong>Parallel收集器</strong>(jdk8默认使用)、ParNew、Parallel scavenge、Parallel old</p><p><strong>算法：复制算法、并行回收、”Stop The World”</strong></p><p>​<strong>Parallel在JDK1.6提供了用于执行老年代的Parallel Old，用来代替Serial Old<br>​Parallel Old采用了标记-压缩算法，但同样是基于并行回收、”Stop The World”</strong></p><p><strong>目标：是达到一个可控制的吞吐量，也被称为吞吐量优先的垃圾回收器</strong><br>           <strong>自适应调节策略也是Parallel Scavenge和ParNew的区别</strong></p><p>高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。因此，常见在服务器环境中使用。例如：执行<strong>批量处理、订单处理、工资支付、科学计算</strong>的应用程序</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><p>-XX:+UseParallelGC~-XX:+UseParalleloldGc</p><p><img src="/./img%5Cb1.png"></p><h4 id="4-3-并发回收器"><a href="#4-3-并发回收器" class="headerlink" title="4.3.并发回收器"></a>4.3.并发回收器</h4><h5 id="1-多线程-1"><a href="#1-多线程-1" class="headerlink" title="1.多线程"></a>1.多线程</h5><h5 id="2-堆内存较大，多核cpu-1"><a href="#2-堆内存较大，多核cpu-1" class="headerlink" title="2.堆内存较大，多核cpu"></a>2.堆内存较大，多核cpu</h5><h5 id="3-尽可能让单次的stw时间最短"><a href="#3-尽可能让单次的stw时间最短" class="headerlink" title="3.尽可能让单次的stw时间最短"></a>3.尽可能让单次的stw时间最短</h5><h5 id="4-3-1-CMS收集器"><a href="#4-3-1-CMS收集器" class="headerlink" title="4.3.1.CMS收集器"></a>4.3.1.CMS收集器</h5><p><strong>算法：CMS采用标记-清除算法，也会有STW</strong></p><p><strong>目的：尽可能缩短垃圾回收时用户线程的停顿时间。停顿时间越短就越适合与用户交互的程序，良好的响应速度能提升用户体验</strong></p><p>过程：</p><ol><li>初始标记阶段(Initial-Mark)：所有的工作线程会因为STW而出现短暂的停顿，这个阶段的主要任务仅仅只是标记除GC Roots能直接关联到的对象。一旦标记完成后就会恢复之前的应用线程。由于直接关联对象比较小，所以这里速度非常快</li><li>并发标记(Concurrent-Mark)：从GC Roots的直接关联对象开始遍历整个对象图的过程，耗时较长但是不需要停顿用户线程，可以与垃圾回收线程并发运行</li><li>重新标记(Remark)：由于在并发标记阶段中，程序的工作线程会和垃圾回收线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短</li><li>并发清除(Concurrent-Sweep)：清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程并发的</li></ol><h6 id="-1"><a href="#-1" class="headerlink" title=""></a></h6><p>-XX:+UseConcMarkSweepGC~ -XX :+UseParNewGC ~ Serialold</p><p><img src="/./img%5Cc1.png"></p><h5 id="4-3-2-G1"><a href="#4-3-2-G1" class="headerlink" title="4.3.2.G1"></a>4.3.2.G1</h5><p><img src="/./img%5Cd1.png"></p><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><p>   G1（Garbage First）收集器是 JDK7 提供的一个新收集器，在 JDK9 中更被指定为官方GC收集器，与CMS收集器相比，最突出的改进是：</p><blockquote><ul><li>基于 “标记-整理” 算法，收集后不会产生内存碎片。</li><li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li></ul></blockquote><p> G1 收集器不采用传统的新生代和老年代物理隔离的布局方式，仅在逻辑上划分新生代和老年代，将整个堆内存划分为2048个大小相等的独立内存块Region，每个Region是逻辑连续的一段内存并使用不同的Region来表示新生代和老年代，G1不再要求相同类型的 Region 在物理内存上相邻，而是通过Region的动态分配方式实现逻辑上的连续。</p><p>​        G1收集器通过跟踪Region中的垃圾堆积情况，每次根据设置的垃圾回收时间，回收优先级最高的区域，避免整个新生代或整个老年代的垃圾回收，使得stop the world的时间更短、更可控，同时在有限的时间内可以获得最高的回收效率。</p><p>​        通过区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率。</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>G1垃圾回收器的工作过程主要包括以下几个步骤：</p><ol><li><p>初始标记阶段（Initial Mark）：这个阶段是G1垃圾回收器的STW（Stop-The-World）阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的根对象，并标记所有的年轻代对象和部分老年代对象。这个阶段的主要目的是确定哪些对象是存活的，哪些对象可以被回收。</p></li><li><p>并发标记阶段（Concurrent Mark）：这个阶段是G1垃圾回收器的并发标记阶段，即在应用程序运行的同时，对存活对象进行标记。在这个阶段，G1会对所有的老年代对象进行标记。这个阶段的主要目的是标记所有的存活对象，为下一阶段的回收做准备。</p></li><li><p>并发预清理阶段（Concurrent Preclean）：这个阶段是G1垃圾回收器的并发预清理阶段，即在应用程序运行的同时，对标记的对象进行清理。在这个阶段，G1会清理掉一些无用的对象，以便在下一阶段的回收中提高效率。</p></li><li><p>最终标记阶段（Final Mark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记所有的存活对象，以及在并发标记阶段和并发预清理阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>筛选回收阶段（Live Data Counting and Evacuation）：这个阶段是G1垃圾回收器的并发筛选回收阶段，即在应用程序运行的同时，对标记的对象进行筛选和回收。在这个阶段，G1会根据区域的垃圾比例和空间利用率等因素，动态选择回收对象，以最大化回收效率。这个阶段的主要目的是回收垃圾最多的区域，以最大化回收效率。</p></li><li><p>再次标记阶段（Remark）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会标记在筛选回收阶段中可能被遗漏的对象。这个阶段的主要目的是确保所有的存活对象都被标记。</p></li><li><p>清理阶段（Cleanup）：这个阶段是G1垃圾回收器的STW阶段，即暂停应用程序的运行。在这个阶段，G1会回收所有未被标记的对象，并进行内存整理。这个阶段的主要目的是回收内存空间，为应用程序提供足够的可用内存。</p></li></ol><h6 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h6><ul><li>同时注重吞吐量(Throughput)和低延迟(Low latency)，默认的暂停目标是200 ms</li><li>超大堆内存，会将堆划分为多个大小相等的Region<br>整体上是标记+整理算法，两个区域之间是复制算法</li><li>缺点，例如在回收大对象时的性能可能不如其他垃圾回收器。</li></ul><h6 id="相关JVM参数"><a href="#相关JVM参数" class="headerlink" title="相关JVM参数"></a>相关JVM参数</h6><p>-XX : +UseG1GC<br>-XX:G1HeapRegionsize=size|<br>-XX:MaxGCPauseMillis=time</p><h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p><img src="/./img%5C12.png"></p><p>最小化地使用内存和并行开销，请选serial GC;</p><p>最大化应用程序的吞吐量，请选Parallel GC;</p><p>最小化Gc的中断或停顿时间，请选CMs GC。</p><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5.垃圾回收调优"></a>5.垃圾回收调优</h2><h5 id="1-案例"><a href="#1-案例" class="headerlink" title="1.案例"></a>1.案例</h5><p><strong>案例1：Full GC和Minor GC频繁</strong></p><p>​在此情形下，需要先确定应用程序的内存使用情况，例如堆内存大小、对象创建和销毁的频率等。如果堆内存过小，可能会导致垃圾收集的频率增加，从而影响应用程序的性能。可以通过增加堆内存大小来减少垃圾收集的频率。</p><p>​另外，需要分析垃圾收集的日志，查看Full GC和Minor GC的发生频率和原因。如果Full GC和Minor GC的发生频率过高，可能是因为应用程序中存在大量的无用对象或内存泄漏。可以使用一些内存分析工具来识别和优化这些问题，例如查看内存堆转储（heap dump）中的对象信息、分析对象引用关系等。</p><p><strong>案例2：请求高峰期发生Full GC，单次暂停时间特别长（CMS）</strong></p><p>​在此情形下，需要增加CMS收集器的并发线程数，以提高CMS收集器的并发处理能力，减少单次Full GC的暂停时间。可以使用参数”-XX:CMSConcurrentMTEnabled”来启用CMS收集器的多线程并发模式。</p><p>​另外，需要分析Full GC的日志，查看Full GC的原因和持续时间。如果Full GC的持续时间过长，可能是因为CMS收集器的老年代空间不足，导致Full GC无法回收足够的内存空间。可以通过增加老年代的空间大小来解决这个问题。</p><p><strong>案例3：老年代充裕情况下，发生Full GC（1.7）</strong></p><p>​在此情形下，可能是因为应用程序中存在大量的长时间存活的对象，导致老年代空间被占满，无法再分配新的对象。可以通过增加老年代的空间大小来解决这个问题。</p><p>​另外，还可以考虑使用G1收集器来改善垃圾收集的效率和性能。G1收集器可以根据应用程序的实际情况，动态调整垃圾回收的策略和参数，以最小化暂停时间和最大化吞吐量。可以通过使用参数”-XX:+UseG1GC”来启用G1收集器。</p>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM的内存结构</title>
      <link href="/2023/08/30/jvm-nei-cun-jie-gou/"/>
      <url>/2023/08/30/jvm-nei-cun-jie-gou/</url>
      
        <content type="html"><![CDATA[<h1 id="二、内存结构"><a href="#二、内存结构" class="headerlink" title="二、内存结构"></a>二、内存结构</h1><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1.程序计数器"></a>1.程序计数器</h2><h4 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1.定义"></a>1.1.定义</h4><ul><li><h5 id="JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"><a href="#JVM程序计数器的英文全称是Program-Counter-Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。" class="headerlink" title="JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。"></a>JVM程序计数器的英文全称是Program Counter Register，又叫程序计数寄存器。Register的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。CPU只有把数据装载到寄存器才能够运行。JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟，每个线程都有一个程序计数器，它是线程私有的，线程切换时会保存和恢复计数器的值。</h5></li></ul><h4 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2.作用"></a>1.2.作用</h4><p><img src="/./img%5C2.1.png"></p><ol><li><h5 id="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"><a href="#用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。" class="headerlink" title="用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。"></a>用于存储下一条指令的地址。详细的说PC寄存器是用来存储指向下一条指令的地址，也就是即将将要执行的指令代码。由执行引擎读取下一条指令。</h5></li><li><h5 id="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"><a href="#实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。" class="headerlink" title="实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。"></a>实现线程间的协作：程序计数器还可以实现线程间的协作。例如，当线程执行一个被同步锁保护的代码块时，如果该代码块被另外一个线程占用，则当前线程会被挂起，等待锁的释放。在等待期间，程序计数器会记录当前线程的执行位置，以便在锁被释放后，恢复线程的执行状态，从而继续执行代码块。</h5></li></ol><h4 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3.特点"></a>1.3.特点</h4><ol><li><h5 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h5></li><li><h5 id="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"><a href="#是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区" class="headerlink" title="是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区"></a>是在Java虚拟机规范中规定的唯一一个不会存在内存溢出的区</h5></li><li><h5 id="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"><a href="#执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空" class="headerlink" title="执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空"></a>执行java方法时，程序计数器是有值的，执行native本地方法时，程序计数器的值为空</h5></li></ol><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2.虚拟机栈"></a>2.虚拟机栈</h2><p><img src="/./img%5C2.png"></p><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1.定义"></a>2.1.定义</h4><h5 id="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"><a href="#JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在-Java-中，每个方法的调用都会创建一个新的栈帧（Stack-Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。" class="headerlink" title="JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。"></a>JVM栈是一块内存区域，用于存储方法的执行状态和局部变量。每个线程都拥有自己的栈，栈是线程私有的，线程之间不共享栈。在 Java 中，每个方法的调用都会创建一个新的栈帧（Stack Frame），栈帧中保存了方法的局部变量、操作数栈、返回地址和异常表等信息。</h5><p><img src="/./img%5C2.2.PNG"></p><ul><li><h5 id="每个线程运行是所需要的内存，称为虚拟机栈"><a href="#每个线程运行是所需要的内存，称为虚拟机栈" class="headerlink" title="每个线程运行是所需要的内存，称为虚拟机栈"></a>每个线程运行是所需要的内存，称为虚拟机栈</h5></li><li><h5 id="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"><a href="#每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存" class="headerlink" title="每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存"></a>每个栈由多个栈帧（Frame）组成，对应着每次方法调用是所占的内存</h5></li><li><h5 id="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"><a href="#每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法" class="headerlink" title="每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法"></a>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</h5><h5 id="问题解析："><a href="#问题解析：" class="headerlink" title="问题解析："></a>问题解析：</h5><p><strong>(1).垃圾回收是否涉及栈内存?</strong></p><p>​垃圾回收（Garbage Collection）一般是针对堆内存（Heap Memory）的，而与栈内存（Stack Memory）没有直接关系。</p><p><strong>(2).栈内存分配越大越好吗?</strong></p><p>​栈内存的大小应该根据具体的需求和系统资源进行合理分配，不是越大越好。</p><p><strong>(3).方法内的局部变量是否线程安全?│</strong></p><h5 id="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"><a href="#–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的" class="headerlink" title="–如果方法内局部变量没有逃离方法的作用访问，它是线程安全的"></a>–<strong>如果方法内局部变量没有逃离方法的作用访问，它是线程安全的</strong></h5><h5 id="–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全"><a href="#–如果是局部变量引用了对象，并逃离方法的作用方法-被方法返回-，需要考虑线程安全" class="headerlink" title="–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全"></a>–如果是局部变量引用了对象，并逃离方法的作用方法(被方法返回)，需要考虑线程安全</h5></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2.栈内存溢出"></a>2.2.栈内存溢出</h4><h5 id="–出现StackOverflowError-异常"><a href="#–出现StackOverflowError-异常" class="headerlink" title="–出现StackOverflowError 异常"></a>–出现StackOverflowError 异常</h5><ul><li><h5 id="栈帧过多导致栈内存溢出-方法调用层次过深"><a href="#栈帧过多导致栈内存溢出-方法调用层次过深" class="headerlink" title="栈帧过多导致栈内存溢出(方法调用层次过深)"></a>栈帧过多导致栈内存溢出(方法调用层次过深)</h5><p><img src="/./img%5C%E6%A0%881.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><h5 id="栈帧过大导致栈内存溢出-方法中创建过多的局部变量"><a href="#栈帧过大导致栈内存溢出-方法中创建过多的局部变量" class="headerlink" title="栈帧过大导致栈内存溢出(方法中创建过多的局部变量)"></a>栈帧过大导致栈内存溢出(方法中创建过多的局部变量)</h5><p><img src="/./img%5C%E6%A0%882.PNG"></p><p>示例</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackOverflowExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">StackOverflowExample</span> example <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StackOverflowExample</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        example<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">1000000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="设置虚拟机栈大小-："><a href="#设置虚拟机栈大小-：" class="headerlink" title="设置虚拟机栈大小  ："></a>设置虚拟机栈大小  ：</h5><ol><li>-Xss：用于设置单个线程的栈大小。</li><li>-XX:ThreadStackSize：也可以使用这个参数来设置单个线程的栈大小。</li><li>在启动 Java 应用程序时通过指定这些参数来设置虚拟机栈的大小，例如：java -Xss1m MyClass</li></ol></li></ul><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3.线程运行诊断"></a>2.3.线程运行诊断</h4><ul><li><h5 id="cpu占用过多"><a href="#cpu占用过多" class="headerlink" title="cpu占用过多"></a>cpu占用过多</h5><p><strong>定位:</strong></p><h6 id="a-用top定位哪个进程对cpu的占用过高"><a href="#a-用top定位哪个进程对cpu的占用过高" class="headerlink" title="a.用top定位哪个进程对cpu的占用过高"></a>a.用top定位哪个进程对cpu的占用过高</h6><h6 id="b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高"><a href="#b-ps-H-eo-pid-tid-cpu-grep进程id-用ps命令进一步定位是哪个线程引起的cpu占用过高" class="headerlink" title="b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)"></a>b.ps H -eo pid,tid,%cpu | grep进程id(用ps命令进一步定位是哪个线程引起的cpu占用过高)</h6><h6 id="c-jstack-进程id"><a href="#c-jstack-进程id" class="headerlink" title="c.jstack 进程id"></a>c.jstack 进程id</h6><h6 id="可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号"><a href="#可以根据线程id找到有问题的线程-进一步定位到问题代码的源码行号" class="headerlink" title="可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号"></a>可以根据线程id找到有问题的线程,进一步定位到问题代码的源码行号</h6></li><li><h5 id="程序运行很长时间没有结果"><a href="#程序运行很长时间没有结果" class="headerlink" title="程序运行很长时间没有结果"></a>程序运行很长时间没有结果</h5><p><img src="/./img%5Cx.png"></p></li></ul><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3.本地方法栈"></a>3.本地方法栈</h2><p><img src="/./img%5C3.png"></p><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1.定义"></a>3.1.定义</h4><h5 id="本地方法栈的主要功能是为执行本地方法时提供栈空间"><a href="#本地方法栈的主要功能是为执行本地方法时提供栈空间" class="headerlink" title="本地方法栈的主要功能是为执行本地方法时提供栈空间"></a>本地方法栈的主要功能是为执行本地方法时提供栈空间</h5><h5 id="本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"><a href="#本地方法-可以让-Java-程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。" class="headerlink" title="本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。"></a>本地方法:可以让 Java 程序调用底层系统的资源和功能，例如操作系统的文件系统、网络接口、硬件设备等。</h5><h6 id="JVM-中的本地方法主要有以下两种类型："><a href="#JVM-中的本地方法主要有以下两种类型：" class="headerlink" title="JVM 中的本地方法主要有以下两种类型："></a>JVM 中的本地方法主要有以下两种类型：</h6><ul><li>​-Native 方法：Native 方法是指在 Java 中声明的本地方法，其实现由本地代码编写。</li><li>​-JNI 方法：JNI 方法是指在本地代码中实现的 Java 方法</li></ul><h4 id="3-2-举例"><a href="#3-2-举例" class="headerlink" title="3.2.举例"></a>3.2.举例</h4><ul><li><p>java.lang.System：System 类包含一些与系统操作相关的本地方法，例如获取系统属性、读取标准输入输出流等。</p></li><li><p>java.io.FileDescriptor：FileDescriptor 类封装了一个操作系统文件描述符，它的本地方法用于创建、读写和关闭文件。</p></li><li><p>java.net.SocketImpl：SocketImpl 类是一个网络套接字的实现类，它的本地方法用于创建和管理底层的网络连接。</p></li><li><p>java.util.zip.Inflater：Inflater 类是一个压缩解压缩器，它的本地方法用于解压缩数据。</p></li><li><p>java.util.Random：Random 类是一个随机数生成器，它的本地方法用于获取随机数种子和生成随机数。</p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4.堆"></a>4.堆</h2><p><img src="/./img%5C4.png"></p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1.定义"></a>4.1.定义</h4><h5 id="1-Heap-堆"><a href="#1-Heap-堆" class="headerlink" title="1.Heap 堆"></a>1.Heap 堆</h5><h5 id="堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"><a href="#堆是-Java-虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。" class="headerlink" title="堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（通过new关键字创建对象）等数据。"></a>堆是 Java 虚拟机管理的内存区域之一，用于存储对象实例和数组（<strong>通过new关键字创建对象）等数据。</strong></h5><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><ul><li><h5 id="是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器"><a href="#是线程共享的-堆中对象要考虑线程安全的问题–-线程栈和程序计数器" class="headerlink" title="是线程共享的:  堆中对象要考虑线程安全的问题–> 线程栈和程序计数器"></a>是线程共享的:  堆中对象要考虑线程安全的问题–&gt; 线程栈和程序计数器</h5></li><li><h5 id="有垃圾回收机制"><a href="#有垃圾回收机制" class="headerlink" title="有垃圾回收机制"></a>有垃圾回收机制</h5></li><li><h5 id="动态分配-堆的空间大小是在-JVM-启动时动态分配的"><a href="#动态分配-堆的空间大小是在-JVM-启动时动态分配的" class="headerlink" title="动态分配:  堆的空间大小是在 JVM 启动时动态分配的"></a>动态分配:  堆的空间大小是在 JVM 启动时动态分配的</h5></li><li><h5 id="分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象"><a href="#分代管理：分为新生代和老年代-–-新创建的对象-经过多次垃圾回收的对象" class="headerlink" title="分代管理：分为新生代和老年代 –>  新创建的对象,经过多次垃圾回收的对象"></a>分代管理：分为新生代和老年代 –&gt;  新创建的对象,经过多次垃圾回收的对象</h5></li><li><h5 id="物理实现：由操作系统的虚拟内存来实现的"><a href="#物理实现：由操作系统的虚拟内存来实现的" class="headerlink" title="物理实现：由操作系统的虚拟内存来实现的"></a>物理实现：由操作系统的虚拟内存来实现的</h5></li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2.堆内存溢出"></a>4.2.堆内存溢出</h4><h5 id="–出现OutOfMemoryError异常"><a href="#–出现OutOfMemoryError异常" class="headerlink" title="–出现OutOfMemoryError异常"></a>–出现OutOfMemoryError异常</h5><ol><li><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序会不断地创建字符串对象并添加到列表中，当字符串的数量太大时，就会导致堆内存溢出错误，抛出 OutOfMemoryError 异常。</p></li><li><h5 id="设置虚拟机堆大小"><a href="#设置虚拟机堆大小" class="headerlink" title="设置虚拟机堆大小"></a>设置虚拟机堆大小</h5><h5 id="Xms：设置-Java-堆的初始大小。"><a href="#Xms：设置-Java-堆的初始大小。" class="headerlink" title="-Xms：设置 Java 堆的初始大小。"></a>-Xms：设置 Java 堆的初始大小。</h5><h5 id="Xmx：设置-Java-堆的最大大小。"><a href="#Xmx：设置-Java-堆的最大大小。" class="headerlink" title="-Xmx：设置 Java 堆的最大大小。"></a>-Xmx：设置 Java 堆的最大大小。</h5></li></ol><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3.堆内存诊断"></a>4.3.堆内存诊断</h4><ul><li><h5 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h5></li></ul><ol><li>jps 指令<br>查看当前系统中有哪些java进程</li><li>jmap-heap {pid}  指令<br>查看堆内存占用情况</li><li>jconsole指令  -&gt;工具<br>图形界面的，多功能的监测工具，可以连续监测</li><li>jvisualvm 指令</li></ol><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5.方法区"></a>5.方法区</h2><p><img src="/./img%5C5.png"></p><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"><a href="#JVM（Java虚拟机）方法区（Method-Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。" class="headerlink" title="JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。"></a>JVM（Java虚拟机）方法区（Method Area）是JVM中的一个内存区域，用于存储已被加载的类信息、常量、静态变量、即编译器编译后的代码等数据。</h5><h4 id="2-组成"><a href="#2-组成" class="headerlink" title="2.组成"></a>2.组成</h4><p><img src="/./img%5C5.1.png"></p><ul><li><h5 id="在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"><a href="#在JDK-1-6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。" class="headerlink" title="在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。"></a>在JDK 1.6中，Java虚拟机方法区的实现是基于永久代（PermGen）的。永久代是一种堆区的一部分，用于存储类信息、常量池、静态变量等数据。由于永久代的大小是有限制的，因此在大量使用动态生成类、反射、动态代理等技术时容易出现永久代溢出的情况，导致Java虚拟机崩溃。</h5></li><li><h5 id="在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"><a href="#在JDK-1-8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。" class="headerlink" title="在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。"></a>在JDK 1.8中，Java虚拟机方法区的实现采用了元空间（Metaspace）的实现方式。元空间是使用本地内存来存储类信息、常量池、静态变量等数据。由于元空间的大小可以动态调整，可以有效地避免Java虚拟机崩溃的情况。</h5></li></ul><h4 id="3-方法区内存溢出"><a href="#3-方法区内存溢出" class="headerlink" title="3.方法区内存溢出"></a>3.方法区内存溢出</h4><h5 id="出现OutOfMemoryError-Metaspace-异常"><a href="#出现OutOfMemoryError-Metaspace-异常" class="headerlink" title="-出现OutOfMemoryError:Metaspace 异常"></a>-出现OutOfMemoryError:Metaspace 异常</h5><ol><li><p><strong>示例：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span><span class="token class-name">IOException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Files</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Path</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>file<span class="token punctuation">.</span></span><span class="token class-name">Paths</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MetaspaceOOM</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"com.example.DynamicClass"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            <span class="token class-name">String</span> classPath <span class="token operator">=</span> className<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">".class"</span><span class="token punctuation">;</span>            <span class="token class-name">Path</span> path <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>classPath<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>className<span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>**调整元空间的大小   **</p><p><strong>-XX:MaxMetaspaceSize = 8m</strong></p><p><strong>jdk1.6的情况 -XX:MaxPermSize=8m</strong></p></li></ol><h4 id="4-运行时常量池"><a href="#4-运行时常量池" class="headerlink" title="4.运行时常量池"></a>4.运行时常量池</h4><h5 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1.定义"></a>1.定义</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConstantPoolExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 常量池中的字符串常量</span>                <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将"Hello, world!"字符串常量放入常量池中</span>        <span class="token comment">// 在编译时将"Hello, world!"字符串常量放入常量池中并将str2指向常量池中的同一个字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">;</span>         <span class="token comment">// 在运行时，创建一个新的字符串对象，并将其指向堆中新建的一个对象</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个字符串常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为它们指向不同的对象</span>                <span class="token comment">// 常量池中的数字常量</span>        <span class="token keyword">int</span> num1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 在编译时，将数字常量100放入常量池中</span>        <span class="token keyword">int</span> num2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 将数字常量100放入常量池中，并将num2指向常量池中的同一个数字常量</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num1 <span class="token operator">==</span> num2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为它们指向同一个数字常量</span>                <span class="token comment">// 常量池中的类引用</span>        <span class="token comment">// 在编译时，将ConstantPoolExample类的引用放入常量池中</span>        <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> clazz <span class="token operator">=</span> <span class="token class-name">ConstantPoolExample</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>         <span class="token comment">// 在编译时，将字符串常量"ConstantPoolExample"放入常量池中</span>        <span class="token class-name">String</span> className <span class="token operator">=</span> <span class="token string">"ConstantPoolExample"</span><span class="token punctuation">;</span> <span class="token comment">// true，它们都指向常量池中的同一个类引用</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clazz <span class="token operator">==</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>className<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。</strong>**</li><li><em><em>运行时常量池，常量池是</em>.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</em>*</li></ul><h4 id="5-StringTable"><a href="#5-StringTable" class="headerlink" title="5.StringTable"></a>5.StringTable</h4><h5 id="1-定义-2"><a href="#1-定义-2" class="headerlink" title="1.定义"></a>1.定义</h5><p>StringTable 是 Java 虚拟机（JVM）中的一个<strong>数据结构</strong>(JDK 8 中基于字符串哈希值的分离链接哈希表)，用于存储字符串常量。</p><h5 id="2-作用"><a href="#2-作用" class="headerlink" title="2.作用"></a>2.作用</h5><p>StringTable 的作用是<strong>优化字符串的存储和共享</strong>，从而减少内存的开销。</p><p>在 Java 应用程序中，字符串常量通常占用较大的内存空间，如果每次都创建新的字符串对象，会导致内存占用量增加，从而影响应用程序的性能。为了避免这种情况，Java 使用了 StringTable 来存储字符串常量，并在<strong>需要使用(延迟加载)字符串常量时直接引用 StringTable 中的对象</strong>，从而避免了重复创建字符串对象，减少了内存占用量。</p><h5 id="3-示例"><a href="#3-示例" class="headerlink" title="3.示例"></a>3.示例</h5><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableExample</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// 字符串常量</span>        <span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 字符串对象</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true，因为字符串常量是共享的</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false，因为字符串对象不是共享的</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/./img%5Cs.jpg"></p><ul><li>在String s4 = s1+s2 是通过new StringBuilder()…  –&gt;字符串变量 s4 是通过字符串变量 a 和 b 的拼接得到的，它是一个新的字符串对象，与字符串常量 “ab” 不相等，</li><li>String s5 = “a”+”b”  是在StringTable中取的已存在的”ab”   –&gt; 字符串常量 “ab” 和 “a” + “b” 的值相等</li></ul><h5 id="4-特性"><a href="#4-特性" class="headerlink" title="4.特性"></a>4.特性</h5><ol><li><p>常量池中的字符串仅是符号，第一次用到时才变为对象</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串变量拼接的原理是StringBuilder ( 1.8)</p></li><li><p>字符串常量拼接的原理是编译期优化</p></li><li><p>可以使用intern方法，主动将串池中还没有的字符串对象放入串池</p><p><strong>1.8将这个字符串对象尝试放入串池，如果有则并不会放入（还在堆区），如果没有则放入串池(堆区-&gt;常量池），会把串池中的对象返回</strong><br><strong>1.6将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份,放入串池,会把串池中的对象返回</strong></p><p>–示例一：   String s = new String(“a”)+new String (“b”)”写在String x = “ab前面</p><p><img src="/./img%5C51.png"></p><p>1.8中：”ab” 在串池中没有，会将s放入串池(s从堆区-&gt;常量池），得到的结果为：s==x 为true</p><p>1.6中：”ab” 在串池中没有，会将s拷贝一份再放入串池(s还在堆区），得到的结果为：s==x 为false</p><p>–示例二：如果将String x = “ab”写在String s = new String(“a”)+new String (“b”)前面</p><p>如果有则并不会放入–&gt;都不会进入串池 s==x  都为 false</p></li></ol><h5 id="5-位置"><a href="#5-位置" class="headerlink" title="5.位置"></a>5.位置</h5><p><img src="/./img%5C61.png"></p><ul><li><p>JDK 7 及之前的版本中，String Table 是一个固定大小的哈希表存储在永久代中，因此在运行时无法动态扩容</p></li><li><p>JDK 8 引入了一种叫做 <strong>Compact Strings</strong> 的技术，可以将字符串常量存储在堆中</p><p>Compact Strings 技术的实现方式是将较短的字符串常量（长度小于等于 16）存储为字节数组，而不是存储为 char 数组。</p></li></ul><h5 id="6-垃圾回收"><a href="#6-垃圾回收" class="headerlink" title="6.垃圾回收"></a>6.垃圾回收</h5><p><img src="/./img%5C62.png"></p><h5 id="7-调优"><a href="#7-调优" class="headerlink" title="7.调优"></a>7.调优</h5><ul><li>可通过参数 <code>-XX:StringTableSize</code> 来设置 StringTable 的桶大小</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringTableBenchmark</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">NUM_STRINGS</span> <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">BUCKET_SIZES</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">1009</span><span class="token punctuation">,</span> <span class="token number">8192</span><span class="token punctuation">,</span> <span class="token number">65536</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> size <span class="token operator">:</span> <span class="token constant">BUCKET_SIZES</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Testing with bucket size "</span> <span class="token operator">+</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">runBenchmark</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">runBenchmark</span><span class="token punctuation">(</span><span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> startTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 构造大量的字符串常量</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">NUM_STRINGS</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token string">"string"</span> <span class="token operator">+</span> i<span class="token punctuation">;</span>            s<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment">// 调整 StringTable 的桶大小</span>        <span class="token class-name">StringTable</span><span class="token punctuation">.</span><span class="token function">adjustSize</span><span class="token punctuation">(</span>bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印 StringTable 的统计信息</span>        <span class="token class-name">StringTableStats</span><span class="token punctuation">.</span><span class="token function">printStats</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> endTime <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 打印程序运行时间</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Time taken: "</span> <span class="token operator">+</span> <span class="token punctuation">(</span>endTime <span class="token operator">-</span> startTime<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">1009</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">1009</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">6.579</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">17</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">1267</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">8192</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">8192</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">1.219</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">6</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">891</span> ms<span class="token class-name">Testing</span> <span class="token keyword">with</span> <span class="token namespace">bucket</span> size <span class="token number">65536</span><span class="token class-name">StringTable</span> stats<span class="token operator">:</span> num_buckets<span class="token operator">=</span><span class="token number">65536</span><span class="token punctuation">,</span> average_bucket_size<span class="token operator">=</span><span class="token number">0.153</span><span class="token punctuation">,</span> max_bucket_size<span class="token operator">=</span><span class="token number">1</span><span class="token class-name">Time</span> taken<span class="token operator">:</span> <span class="token number">849</span> ms<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>可以考虑将字符串对象入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6.直接内存"></a>6.直接内存</h2><h4 id="1-定义-3"><a href="#1-定义-3" class="headerlink" title="1.定义"></a>1.定义</h4><h5 id="JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"><a href="#JVM直接内存（Direct-Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存" class="headerlink" title="JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存"></a>JVM直接内存（Direct Memory）是一种特殊的内存区域，它不是由Java虚拟机（JVM）管理的堆内存，而是由操作系统管理的原生内存</h5><ul><li>常见于NIO操作时，用于数据缓冲区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="2-作用-1"><a href="#2-作用-1" class="headerlink" title="2.作用"></a>2.作用</h4><p><strong>JVM直接内存可以通过Java NIO（New I/O）库中的ByteBuffer类来进行访问和操作，它的主要特点是可以提高I/O操作的效率，减少内存复制和上下文切换的开销。</strong></p><h5 id="–java的io操作-存在缓冲区的复制操作"><a href="#–java的io操作-存在缓冲区的复制操作" class="headerlink" title="–java的io操作(存在缓冲区的复制操作)"></a>–java的io操作(存在缓冲区的复制操作)</h5><p><img src="/./img%5C6.1.png"></p><h5 id="–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024"><a href="#–使直接内存后-ByteBuffer-bb-ByteBuffer-allocateDirect-1024-1024" class="headerlink" title="–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);"></a>–使直接内存后 ByteBuffer bb = ByteBuffer.allocateDirect(1024*1024);</h5><p>这个方法会在<strong>堆内存</strong>中分配一个DirectByteBuffer对象，并在<strong>操作系统</strong>中分配一块原生内存，用来存储ByteBuffer对象中的数据。</p><p><img src="/./img%5C6.2.png"></p><h4 id="3-原理"><a href="#3-原理" class="headerlink" title="3.原理"></a>3.原理</h4><h5 id="直接内存的释放："><a href="#直接内存的释放：" class="headerlink" title="直接内存的释放："></a>直接内存的释放：</h5><h5 id="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"><a href="#Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。" class="headerlink" title="Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。"></a>Java直接内存的释放需要手动进行，因为它不像Java堆内存那样受到JVM的自动内存管理控制。</h5><ol><li>调用DirectByteBuffer类的clear()方法</li><li>freeMemory(long address)：释放指定地址的内存块。</li></ol><p><img src="/./img%5C6.3.png"></p><h5 id="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"><a href="#由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存" class="headerlink" title="由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存"></a>由于Unsafe类的方法都是native方法，因此它可以绕过JVM的安全检查机制，直接操作内存</h5><p><strong>–ByteBuffer.allocateDirect(1024*1024)中对Unsafe的调用;</strong></p><p><img src="/./img%5C6.4.png"></p><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner(虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemor来释放直接内存</li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><h4 id="1-部分："><a href="#1-部分：" class="headerlink" title="1.部分："></a>1.部分：</h4><ol><li><h5 id="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"><a href="#堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。" class="headerlink" title="堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。"></a>堆（Heap）：用于存储对象实例和数组等数据。堆空间是Java程序中最大的一块内存空间，它被所有线程共享。</h5></li><li><h5 id="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"><a href="#栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。" class="headerlink" title="栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。"></a>栈（Stack）：用于存储方法调用的现场数据和操作数栈等信息。每个线程都有一个独立的栈空间，用于存储该线程当前执行方法的现场数据。</h5></li><li><h5 id="方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"><a href="#方法区（Method-Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。" class="headerlink" title="方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。"></a>方法区（Method Area）：用于存储类信息、常量池、静态变量等数据。方法区也是所有线程共享的空间。</h5></li><li><h5 id="本地方法栈（Native-Stack）：用于存储Native方法的现场数据。"><a href="#本地方法栈（Native-Stack）：用于存储Native方法的现场数据。" class="headerlink" title="本地方法栈（Native Stack）：用于存储Native方法的现场数据。"></a>本地方法栈（Native Stack）：用于存储Native方法的现场数据。</h5></li><li><h5 id="PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器（Program-Counter-Register）：用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。"></a>PC寄存器（Program Counter Register）：用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="2-特点："><a href="#2-特点：" class="headerlink" title="2.特点："></a>2.特点：</h4><ol><li><h5 id="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"><a href="#堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。" class="headerlink" title="堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。"></a>堆空间的扩展性：堆空间可以动态扩展，以适应不同程序的需要。</h5></li><li><h5 id="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"><a href="#栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。" class="headerlink" title="栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。"></a>栈空间的独立性：每个线程都有一个独立的栈空间，避免了线程之间的干扰。</h5></li><li><h5 id="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"><a href="#方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。" class="headerlink" title="方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。"></a>方法区的共享性：方法区是所有线程共享的空间，可以实现数据共享和复用。</h5></li><li><h5 id="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"><a href="#PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。" class="headerlink" title="PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。"></a>PC寄存器的独立性：每个线程都有一个独立的PC寄存器，用于存储当前线程执行的字节码指令地址。</h5></li></ol><h4 id="3-区别："><a href="#3-区别：" class="headerlink" title="3.区别："></a>3.区别：</h4><ol><li><h5 id="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>堆和栈：堆空间用于存储对象实例和数组等数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"><a href="#栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。" class="headerlink" title="栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。"></a>栈和方法区：栈空间是每个线程独立的空间，用于存储该线程当前执行方法的现场数据，而方法区是所有线程共享的空间，用于存储类信息、常量池、静态变量等数据。</h5></li><li><h5 id="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"><a href="#方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。" class="headerlink" title="方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。"></a>方法区和堆：方法区和堆都是所有线程共享的空间，但方法区用于存储类信息、常量池、静态变量等数据，而堆用于存储对象实例和数组等数据。</h5></li><li><h5 id="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"><a href="#本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。" class="headerlink" title="本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。"></a>本地方法栈和栈：本地方法栈用于存储Native方法的现场数据，而栈空间用于存储方法调用的现场数据和操作数栈等信息。</h5></li><li><h5 id="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"><a href="#PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。" class="headerlink" title="PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。"></a>PC寄存器和其他部分：PC寄存器用于存储当前线程执行的字节码指令地址，与其他部分没有直接的联系。</h5></li></ol>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM基本概念</title>
      <link href="/2023/08/30/jvm-ji-ben-gai-nian/"/>
      <url>/2023/08/30/jvm-ji-ben-gai-nian/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h1><h2 id="一、什么是-JVM？"><a href="#一、什么是-JVM？" class="headerlink" title="一、什么是 JVM？"></a>一、什么是 JVM？</h2><h4 id="JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。"><a href="#JVM（Java-Virtual-Machine）是一个可以在任何平台上运行的虚拟计算机，它是-Java-平台的核心组件之一，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。" class="headerlink" title="JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。"></a>JVM（Java Virtual Machine）是一个可以在任何平台上运行的虚拟计算机，它是 Java 平台的核心组件之一，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。</h4><h2 id="二、JVM-的组成"><a href="#二、JVM-的组成" class="headerlink" title="二、JVM 的组成"></a>二、JVM 的组成</h2><p><img src="/./img/jvm1.png"></p><ol><li><h4 id="类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器（Class-Loader）：负责将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器（Class Loader）：负责将字节码加载到 JVM 中，并生成对应的 Class 对象。</h4></li><li><h4 id="运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分："><a href="#运行时数据区（Runtime-Data-Area）：JVM-运行时数据区分为以下几个部分：" class="headerlink" title="运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分："></a>运行时数据区（Runtime Data Area）：JVM 运行时数据区分为以下几个部分：</h4><ul><li><h5 id="方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。"><a href="#方法区（Method-Area）：存储类的元数据信息，如类名、方法名、字段名等。" class="headerlink" title="方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。"></a>方法区（Method Area）：存储类的元数据信息，如类名、方法名、字段名等。</h5></li><li><h5 id="堆（Heap）：存储对象实例。"><a href="#堆（Heap）：存储对象实例。" class="headerlink" title="堆（Heap）：存储对象实例。"></a>堆（Heap）：存储对象实例。</h5></li><li><h5 id="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"><a href="#栈（Stack）：存储局部变量、操作数栈、方法返回值等。" class="headerlink" title="栈（Stack）：存储局部变量、操作数栈、方法返回值等。"></a>栈（Stack）：存储局部变量、操作数栈、方法返回值等。</h5></li><li><h5 id="本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。"><a href="#本地方法栈（Native-Method-Stack）：存储-JNI-调用信息。" class="headerlink" title="本地方法栈（Native Method Stack）：存储 JNI 调用信息。"></a>本地方法栈（Native Method Stack）：存储 JNI 调用信息。</h5></li><li><h5 id="PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。"><a href="#PC-寄存器（Program-Counter-Register）：存储正在执行的-Java-虚拟机字节码指令的地址。" class="headerlink" title="PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。"></a>PC 寄存器（Program Counter Register）：存储正在执行的 Java 虚拟机字节码指令的地址。</h5></li></ul></li><li><h4 id="执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。"><a href="#执行引擎（Execution-Engine）：负责将字节码解释成机器码执行。" class="headerlink" title="执行引擎（Execution Engine）：负责将字节码解释成机器码执行。"></a>执行引擎（Execution Engine）：负责将字节码解释成机器码执行。</h4></li><li><h4 id="本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。"><a href="#本地方法接口（Native-Interface）：允许-Java-应用程序调用本地方法。" class="headerlink" title="本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。"></a>本地方法接口（Native Interface）：允许 Java 应用程序调用本地方法。</h4></li><li><h4 id="JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。"><a href="#JVM-选项（JVM-Options）：用于配置-JVM-运行时的参数，如堆大小、栈大小、GC-策略等。" class="headerlink" title="JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。"></a>JVM 选项（JVM Options）：用于配置 JVM 运行时的参数，如堆大小、栈大小、GC 策略等。</h4></li></ol><h2 id="三、JVM-的工作原理"><a href="#三、JVM-的工作原理" class="headerlink" title="三、JVM 的工作原理"></a>三、JVM 的工作原理</h2><h4 id="JVM-的工作原理如下："><a href="#JVM-的工作原理如下：" class="headerlink" title="JVM 的工作原理如下："></a>JVM 的工作原理如下：</h4><p><img src="/./img/jvm2.png"></p><ol><li><h5 id="类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。"><a href="#类加载器将字节码加载到-JVM-中，并生成对应的-Class-对象。" class="headerlink" title="类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。"></a>类加载器将字节码加载到 JVM 中，并生成对应的 Class 对象。</h5></li><li><h5 id="执行引擎将字节码解释成机器码执行。"><a href="#执行引擎将字节码解释成机器码执行。" class="headerlink" title="执行引擎将字节码解释成机器码执行。"></a>执行引擎将字节码解释成机器码执行。</h5></li><li><h5 id="在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"><a href="#在执行过程中，JVM-运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。" class="headerlink" title="在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。"></a>在执行过程中，JVM 运行时数据区存储了程序运行时所需的数据，如对象实例、局部变量、操作数栈等。</h5></li><li><h5 id="执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"><a href="#执行过程中，JVM-会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。" class="headerlink" title="执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。"></a>执行过程中，JVM 会不断地进行垃圾回收，回收不再使用的对象占用的内存空间。</h5></li><li><h5 id="执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"><a href="#执行过程中，JVM-还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。" class="headerlink" title="执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。"></a>执行过程中，JVM 还会进行即时编译（JIT）优化，将频繁执行的字节码编译成机器码，提高程序的执行效率。</h5></li></ol><h2 id="四、JVM-的优化"><a href="#四、JVM-的优化" class="headerlink" title="四、JVM 的优化"></a>四、JVM 的优化</h2><h4 id="1-内存分配优化"><a href="#1-内存分配优化" class="headerlink" title="1.内存分配优化"></a>1.内存分配优化</h4><p>​可以通过调整堆大小、使用对象池等方式优化内存的分配和回收。</p><h4 id="2-垃圾回收优化"><a href="#2-垃圾回收优化" class="headerlink" title="2.垃圾回收优化"></a>2.垃圾回收优化</h4><pre><code> 可以通过选择不同的垃圾回收算法、调整垃圾回收参数等方式优化垃圾回收效率。</code></pre><h4 id="3-即时编译优化"><a href="#3-即时编译优化" class="headerlink" title="3.即时编译优化"></a>3.即时编译优化</h4><p>​可以通过调整 JIT 编译器的参数、选择不同的编译策略等方式优化即时编译效率。</p><h4 id="4-多线程优化"><a href="#4-多线程优化" class="headerlink" title="4.多线程优化"></a>4.多线程优化</h4><p>​可以通过合理地使用多线程技术，提高程序的并发性能。</p><h2 id="五、JVM-的调优工具"><a href="#五、JVM-的调优工具" class="headerlink" title="五、JVM 的调优工具"></a>五、JVM 的调优工具</h2><h4 id="1-jstat"><a href="#1-jstat" class="headerlink" title="1.jstat"></a>1.jstat</h4><p>​用于监控 JVM 运行时数据区的状态。</p><h4 id="2-jmap"><a href="#2-jmap" class="headerlink" title="2.jmap"></a>2.jmap</h4><p>​用于生成堆转储文件，分析堆内存使用情况。</p><h4 id="3-jconsole"><a href="#3-jconsole" class="headerlink" title="3.jconsole"></a>3.jconsole</h4><p>​用于监控 JVM 的运行状态，包括内存、线程、GC 等信息。</p><h4 id="4-VisualVM"><a href="#4-VisualVM" class="headerlink" title="4.VisualVM"></a>4.VisualVM</h4><p>​用于监控和分析 JVM 应用程序的性能，包括内存、线程、GC 等信息。</p><h4 id="5-jprofiler"><a href="#5-jprofiler" class="headerlink" title="5.jprofiler"></a>5.jprofiler</h4><p>​用于分析 JVM 应用程序的性能瓶颈，包括方法调用时间、线程状态、内存分配等信息。</p><h6 id="总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。"><a href="#总之，JVM-是-Java-平台的核心组件之一，它负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高-Java-程序的运行效率，可以进行各种-JVM-优化，并使用各种-JVM-调优工具进行监控和分析。" class="headerlink" title="总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。"></a>总之，JVM 是 Java 平台的核心组件之一，它负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。为了提高 Java 程序的运行效率，可以进行各种 JVM 优化，并使用各种 JVM 调优工具进行监控和分析。</h6><h2 id="六、JVM、JRE、JDK、JavaSE-和-JavaEE"><a href="#六、JVM、JRE、JDK、JavaSE-和-JavaEE" class="headerlink" title="六、JVM、JRE、JDK、JavaSE 和 JavaEE"></a>六、JVM、JRE、JDK、JavaSE 和 JavaEE</h2><p><img src="/./img/jvm_jre_jdk.png"></p><h4 id="1-JVM（Java-Virtual-Machine）"><a href="#1-JVM（Java-Virtual-Machine）" class="headerlink" title="1.JVM（Java Virtual Machine）"></a>1.JVM（Java Virtual Machine）</h4><h5 id="Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。"><a href="#Java-虚拟机是-Java-平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将-Java-代码编译成字节码并在运行时将字节码转换成机器码执行。JVM-是-Java-平台的核心，不同的-JVM-可以在不同的平台上运行，但是它们都能够执行相同的字节码。" class="headerlink" title="Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。"></a>Java 虚拟机是 Java 平台的核心组件之一，它是一个可以在任何平台上运行的虚拟计算机，负责将 Java 代码编译成字节码并在运行时将字节码转换成机器码执行。JVM 是 Java 平台的核心，不同的 JVM 可以在不同的平台上运行，但是它们都能够执行相同的字节码。</h5><h4 id="2-JRE（Java-Runtime-Environment）"><a href="#2-JRE（Java-Runtime-Environment）" class="headerlink" title="2.JRE（Java Runtime Environment）"></a>2.JRE（Java Runtime Environment）</h4><h5 id="Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。"><a href="#Java-运行时环境是一种包含了-JVM-和-Java-基本类库等组件的运行时环境，它提供了运行-Java-应用程序所需的基础设施。JRE-包含了-JVM、Java-类库、Java-运行时环境和其他一些支持文件，它可以让用户在不需要进行-Java-应用程序开发的情况下运行-Java-应用程序。" class="headerlink" title="Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。"></a>Java 运行时环境是一种包含了 JVM 和 Java 基本类库等组件的运行时环境，它提供了运行 Java 应用程序所需的基础设施。JRE 包含了 JVM、Java 类库、Java 运行时环境和其他一些支持文件，它可以让用户在不需要进行 Java 应用程序开发的情况下运行 Java 应用程序。</h5><h4 id="3-JDK（Java-Development-Kit）"><a href="#3-JDK（Java-Development-Kit）" class="headerlink" title="3.JDK（Java Development Kit）"></a>3.JDK（Java Development Kit）</h4><h5 id="Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。"><a href="#Java-开发工具包是一个用于开发-Java-应用程序的软件开发工具包，它包含了-Java-编译器、Java-运行环境、Java-API-文档、Java-开发工具等组件，提供了一系列用于开发、测试和部署-Java-应用程序的工具和技术。JDK-是-Java-开发者必备的工具之一。" class="headerlink" title="Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。"></a>Java 开发工具包是一个用于开发 Java 应用程序的软件开发工具包，它包含了 Java 编译器、Java 运行环境、Java API 文档、Java 开发工具等组件，提供了一系列用于开发、测试和部署 Java 应用程序的工具和技术。JDK 是 Java 开发者必备的工具之一。</h5><h4 id="4-JavaSE（Java-Platform-Standard-Edition）"><a href="#4-JavaSE（Java-Platform-Standard-Edition）" class="headerlink" title="4.JavaSE（Java Platform, Standard Edition）"></a>4.JavaSE（Java Platform, Standard Edition）</h4><h5 id="Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。"><a href="#Java-标准版是-Java-平台的基础版，它包含了-Java-编程语言、Java-类库和-Java-运行时环境等核心组件，是-Java-平台的基础。JavaSE-可以满足大多数应用程序的需求，是-Java-开发的基础。" class="headerlink" title="Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。"></a>Java 标准版是 Java 平台的基础版，它包含了 Java 编程语言、Java 类库和 Java 运行时环境等核心组件，是 Java 平台的基础。JavaSE 可以满足大多数应用程序的需求，是 Java 开发的基础。</h5><h4 id="5-JavaEE（Java-Platform-Enterprise-Edition）"><a href="#5-JavaEE（Java-Platform-Enterprise-Edition）" class="headerlink" title="5.JavaEE（Java Platform, Enterprise Edition）"></a>5.JavaEE（Java Platform, Enterprise Edition）</h4><h5 id="Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。"><a href="#Java-企业版是-Java-平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如-Java-Servlet、JavaServer-Pages（JSP）、Enterprise-JavaBeans（EJB）、Java-Persistence-API（JPA）等。JavaEE-是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的-API-和工具，帮助开发者更加高效地开发企业级应用程序。" class="headerlink" title="Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。"></a>Java 企业版是 Java 平台的企业级应用程序开发平台，它提供了一系列用于开发、部署和管理企业级应用程序的技术和规范，如 Java Servlet、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）、Java Persistence API（JPA）等。JavaEE 是为开发复杂的、分布式的、可伸缩的企业应用程序而设计的，它提供了丰富的 API 和工具，帮助开发者更加高效地开发企业级应用程序。</h5><h6 id="总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。"><a href="#总之，JVM、JRE、JDK、JavaSE-和-JavaEE-是-Java-平台中的一些重要概念，它们之间的关系是：JVM-是-Java-平台的核心组件，JRE-包含了-JVM-和-Java-基本类库等组件，JDK-包含了-JRE-并提供了用于开发-Java-应用程序的工具和技术，JavaSE-是-Java-平台的基础版，JavaEE-是-Java-平台的企业级应用程序开发平台。" class="headerlink" title="总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。"></a>总之，JVM、JRE、JDK、JavaSE 和 JavaEE 是 Java 平台中的一些重要概念，它们之间的关系是：JVM 是 Java 平台的核心组件，JRE 包含了 JVM 和 Java 基本类库等组件，JDK 包含了 JRE 并提供了用于开发 Java 应用程序的工具和技术，JavaSE 是 Java 平台的基础版，JavaEE 是 Java 平台的企业级应用程序开发平台。</h6><h3 id="七、常见的-JVM（Java-Virtual-Machine）"><a href="#七、常见的-JVM（Java-Virtual-Machine）" class="headerlink" title="七、常见的 JVM（Java Virtual Machine）"></a>七、常见的 JVM（Java Virtual Machine）</h3><p><img src="/./img/jvm%E5%AE%9E%E7%8E%B0.png"></p><ol><li><h4 id="Oracle-JDK（Java-Development-Kit）："><a href="#Oracle-JDK（Java-Development-Kit）：" class="headerlink" title="Oracle JDK（Java Development Kit）："></a>Oracle JDK（Java Development Kit）：</h4><h5 id="是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-Oracle-公司提供的官方-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 Oracle 公司提供的官方 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="OpenJDK："><a href="#OpenJDK：" class="headerlink" title="OpenJDK："></a>OpenJDK：</h4><h5 id="是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是一种开源的-JDK-实现，由多个开源社区维护和贡献，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是一种开源的 JDK 实现，由多个开源社区维护和贡献，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="IBM-JDK："><a href="#IBM-JDK：" class="headerlink" title="IBM JDK："></a>IBM JDK：</h4><h5 id="是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。"><a href="#是由-IBM-公司提供的-JDK，包含了完整的-Java-运行环境和开发工具包，支持各种操作系统。" class="headerlink" title="是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。"></a>是由 IBM 公司提供的 JDK，包含了完整的 Java 运行环境和开发工具包，支持各种操作系统。</h5></li><li><h4 id="Azul-Zulu-JDK："><a href="#Azul-Zulu-JDK：" class="headerlink" title="Azul Zulu JDK："></a>Azul Zulu JDK：</h4><h5 id="是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。"><a href="#是由-Azul-Systems-公司提供的-JDK，是-OpenJDK-的一个优化版本，提供了更好的性能和稳定性。" class="headerlink" title="是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。"></a>是由 Azul Systems 公司提供的 JDK，是 OpenJDK 的一个优化版本，提供了更好的性能和稳定性。</h5></li><li><h4 id="Amazon-Corretto-JDK："><a href="#Amazon-Corretto-JDK：" class="headerlink" title="Amazon Corretto JDK："></a>Amazon Corretto JDK：</h4><h5 id="是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。"><a href="#是由亚马逊公司提供的-JDK，是-OpenJDK-的一个免费、多平台的发行版，支持-Amazon-Linux、Windows、macOS-和其他-Linux-发行版。" class="headerlink" title="是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。"></a>是由亚马逊公司提供的 JDK，是 OpenJDK 的一个免费、多平台的发行版，支持 Amazon Linux、Windows、macOS 和其他 Linux 发行版。</h5></li><li><h4 id="AdoptOpenJDK："><a href="#AdoptOpenJDK：" class="headerlink" title="AdoptOpenJDK："></a>AdoptOpenJDK：</h4><h5 id="是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"><a href="#是一个社区驱动的-OpenJDK-发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。" class="headerlink" title="是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。"></a>是一个社区驱动的 OpenJDK 发行版，由多个开源社区合作维护和贡献，支持多种操作系统和硬件平台。</h5></li></ol><h6 id="这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。"><a href="#这些-JVM-都是-Java-应用程序运行的基础，提供了-Java-应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的-JVM-进行开发和部署。" class="headerlink" title="这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。"></a>这些 JVM 都是 Java 应用程序运行的基础，提供了 Java 应用程序运行所需的虚拟机、类库和工具等。开发者可以根据自己的需求选择合适的 JVM 进行开发和部署。</h6>]]></content>
      
      
      <categories>
          
          <category> – Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/30/hello-world/"/>
      <url>/2023/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
